

// The Module object: Our interface to the outside world. We import
// and export values on it. There are various ways Module can be used:
// 1. Not defined. We create it here
// 2. A function parameter, function(Module) { ..generated code.. }
// 3. pre-run appended it, var Module = {}; ..generated code..
// 4. External script tag defines var Module.
// We need to check if Module already exists (e.g. case 3 above).
// Substitution will be replaced with actual code on later stage of the build,
// this way Closure Compiler will not mangle it (e.g. case 4. above).
// Note that if you want to run closure, and also to use Module
// after the generated code, you will need to define   var Module = {};
// before the code. Then that object will be used in the code, and you
// can continue to use Module afterwards as well.
var Module = typeof Module !== 'undefined' ? Module : {};

// --pre-jses are emitted after the Module integration code, so that they can
// refer to Module (if they choose; they can also define Module)

  if (!Module.expectedDataFileDownloads) {
    Module.expectedDataFileDownloads = 0;
  }
  Module.expectedDataFileDownloads++;
  (function() {
   var loadPackage = function(metadata) {
  
    function runWithFS() {
  
      function assert(check, msg) {
        if (!check) throw msg + new Error().stack;
      }
  Module['FS_createPath']("/", "assets", true, true);
var fileData0 = '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';
Module['FS_createDataFile']('/assets', 'BuyComplete.wav', decodeBase64(fileData0), true, true, false);
var fileData1 = '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7e4A7xLvIu8y70LvV+9i73fvie+V76jvuO/G79zv5O/57wjwGfAq8DHwTPBV8G3wdfCE8JfwpfC08MTwzvDm8O/wA/EQ8RvxLvE88UrxWPFj8X7xgPGU8abxr/HD8cjx3PHn8ffxBfIV8iPytfLX8VDv+/vDF0ckjyGEIOQgxiCjIIggYiBGICQgASDlH78fqR+AH2QfQx8lHwcf5B7MHqceiR5rHk0eMR70HVYdcx8OH6gKGfHp6wnvCe/G7tvu8u777hTvH+8170PvU+9o73Tviu+U76vvte/I79bv6u/77wjwGPAm8DjwR/Bb8GLwdfCK8JPwp/C08MTw1PDf8PPwAPEQ8R7xK/E98U/xWfFn8Xbxg/GY8Z/xsvG78dHx1vHr8ffxCPIU8iDyMvI38k3yWPJn8nTyf/KR8pjyrvK08sfy0fLe8uvy+/ID8xXzHvMv8zfzSPNQ82XzZvN884PzlfOg86Dz4PNU9OnxSPMdCYshMyUqIjsiYiI6IhYi9CHTIaohkyFmIUwhKSEHIekgxiClIIcgYyBGIB8gBiDhH8Yfoh+KHwIfHh8YIjQaRP+v7dTupvAq8CPwOfBH8F7wZPB58IbwlvCq8LTwxvDP8OXw8/D/8BDxHfEt8T7xSvFh8WjxefGD8ZbxoPG18bvx1fHY8fDx9fEG8hXyIvIx8jzyT/JX8mbydPKD8pDynfKs8rLy6fJc8yrxOfJYBlsdDSEuHj4eYh49HiEeAB7nHcIdqx2IHW4dUB0xHRgd9RzdHLscoRyDHGscSxwvHBMc+BvfG7kbqBuGG3Ib8xoYG+IdNBb2/OHsGe6770/vSu9d72zvfe+S757vsu/A79Lv3u/y7/7vFfAd8DDwQ/BQ8F3wa/CZ8CHxOO8275EBwhkUHx0c/Rs8HA0c+hvaG74bphuIG20bURs4GxYbAhviGssarhqYGnQaYhpCGiwaDhr8GdkZxhmmGY8ZcxleGUMZLBkOGfkY2hjIGKgYmRh5GGUYShg0GBsY/xfuF88XuheiF4kXdRdZF0UXKxcVF/8W6hbPFroWohaRFnMWXRZLFi8WIRb/FfIV2BXHFbAVmBWEFWwVWxVGFSsVHRUAFfUUcRTKFIQXng7+9Enm/edy6QbpD+kq6T/pWelu6YLpnumw6crp2en56QPqI+ow6k7qYep36orqnOrY6ljrSOn66ZT9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D/Ea8SvxOvFK8VbxbPFx8Ybxj/Gi8a7xwfHN8dzx5/H78QDyFfId8jPyOfJN8lbyZ/Jx8oLyjfKd8qnytvLA8s/yNPPy8mvwKfhAD9IcYhv8GVcaTRoqGhYa+BncGccZrRmQGXgZXxlEGTAZFBn1GOIYyRiuGJYYfRhlGE8YMhgdGAUYtBd+F+4Z4hWaAPTucu5+8CbwFfAn8DvwSvBa8GrwefCI8JXwpvC28Mbw1PDk8PPwBvEM8SLxLPE+8UzxWfFp8XfxifGU8aXxsPHC8c7x3/Hq8fvxBvIV8ifyLfJC8kryWvJn8nbygvKR8qHyqfK48sXy1PLf8vHy+PIK8xXzIfMt8zfzSfNQ82fzavN/84TzlPOj86rzvPPE89Hz4PPm8/nzAfQM9Bn0IfQx9D30SPRZ9F30bfR39Ib0kfSZ9Kb0rvS99MT01/RH9ar0Y/KC/PETIh/uHPcbSRwxHBUc9RvhG74bpRuKG24bVhs0GyIb+xrnGssarhqUGnsaYRpHGioaEhr2Gd0ZyRlbGWQZ5BvPFUT/2e+U8Dfy0/HI8dzx6PH38QXyFfIj8i/yPfJI8lnyZfJw8oPyj/Kc8qvyu/LD8tHy3fLs8vryB/MP8yHzKfM880XzVfNf82rze/OE85Hzn/Os87vzwvPR89nz5/P18/7zDvQX9Cb0L/Q59Ef0VvRd9Gr0ePSA9I/0l/Sn9Kv0u/TD9NL02/Tl9PL0//QG9RX1G/Ur9TP1PvVM9VP1XvVr9XL1gfWM9ZD1n/Wk9bT1vvXH9dL12/Xp9ez1/PUI9o32dPXZ86YA6BdYIL4dJB11HVAdNh0WHfwc2BzDHKAcihxkHE0cMhwWHPgb3RvCG6QbihtpG1cbMRsiG/8a5xrPGksarRoKHWYUCP1R8ALyMvPM8s3y3PLr8vfyAvMU8xzzLvM480bzU/Ne82zzdfOG84/znfOp87PzwvPO89nz6fPu8wP0BPQb9B30NPQ39En0UPRf9Gv0dfSC9Ib0mvSf9K/0u/TC9ND01/Tm9PD0APUE9Q/1YvVR9QPza/iJDEoamRkUGGcYYBhBGDAYERgAGOAX0BewF6EXfhdwF1IXPxcnFxEX+BbjFssWshadFogWcBZYFkcWKRYfFrEV3RUVGKURF/1e8G/xvPJe8l7ybfJ88ozykfKt8qzyxvLJ8tvy4/L18gPzEPMa8yjz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';
Module['FS_createDataFile']('/assets', 'BuyNegative.wav', decodeBase64(fileData1), true, true, false);
var fileData2 = 'iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAAAXNSR0IArs4c6QAAAEpJREFUOI1jZMAC/v///x+bOCMjIyOGGDEa8RkEZxCrGd0QRnI0IxvCRI5GFEPItR0GKHbBqAGDIh3AGBQlZVINwZqZiDEIW3YGAK8PJBTnvghGAAAAAElFTkSuQmCC';
Module['FS_createDataFile']('/assets', 'Circle16.png', decodeBase64(fileData2), true, true, false);
var fileData3 = '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CAgICAgICAgKCAgIBQgFCQcFBwcHBwcGBwcDBQcDCgcHBwcGBwYHBwoHBwcGAwYKCQMJCA4OBwgICAgICAgLCAcHBwcDAwMDCAgICAgICAgICAgICAcHBwcHBwoHBwcHBwUFBgYHBwcHBwcHBwcHBwcMCgMDBwcQChIFAAQEBAgKCQsLBAUFCgkECAQJCAUICAgICAgICAQECQgJCQkJCQkJCAgJCQQJCQgOCQkJCQkJCQkJCwkJCQUJBQoIBQgICAgIBggIBAUIBAsICAgIBggGCAgLCAgIBgQGCwoECgkPDwgJCQkJCQkJDQkICAgIBAQEBAkJCQkJCQkJCQkJCQkICAgICAgLCAgICAgFBQYGCAgICAgICAgICAgIDgsEBAgIEgsTBgAEBAQICwoMDAQGBgsKBAgECggGCAgICAgICAgEBAoICgoKCgoKCggICgoECgoIDwoKCgoKCgoKCgwKCgoGCgYLCAYICAgICAcICAQGCAQMCAgICAcIBwgIDAgICAcEBwwLBAsKEREICgoKCgoKCg4KCAgICAQEBAQKCgoKCgoKCgoKCgoKCAgICAgIDAgICAgIBgYHBwgICAgICAgICAgICA8MBAQICBMMFQYABQUFCQwLDg4FBgYMCwUJBQsJBgkJCQkJCQkJBQULCQsLCwsLCwsJCQsLBQsLCRELCwsLCwsLCwsOCwsLBgsGDAkGCQkJCQkICQkFBgkFDgkJCQkICQgJCQ4JCQkIBQgODAUMCxISCQsLCwsLCwsPCwkJCQkFBQUFCwsLCwsLCwsLCwsLCwkJCQkJCQ4JCQkJCQYGCAgJCQkJCQkJCQkJCQkRDgUFCQkVDRcHAAUFBQoNCw8PBQcHDQsFCgULCgcKCgoKCgoKCgUFCwoLCwsLCwsLCgoLCwULCwoSCwsLCwsLCwsLDwsLCwcLBw0KBwoKCgoKCAoKBQcKBQ8KCgoKCAoICgoPCgoKCAUIDw0FDQsUFAoLCwsLCwsLEAsKCgoKBQUFBQsLCwsLCwsLCwsLCwsKCgoKCgoPCgoKCgoHBwgICgoKCgoKCgoKCgoKEg8FBQoKFw4ZBwAFBQULDgwQEAUHBw4MBQsFDAsHCwsLCwsLCwsFBQwLDAwMDAwMDAsLDAwFDAwLEwwMDAwMDAwMDBAMDAwHDAcOCwcLCwsLCwkLCwUHCwUQCwsLCwkLCQsLEAsLCwkFCRAOBQ4MFRULDAwMDAwMDBIMCwsLCwUFBQUMDAwMDAwMDAwMDAwMCwsLCwsLEAsLCwsLBwcJCQsLCwsLCwsLCwsLCxMQBQULCxkPGggABgYGCw8NEREGCAgPDQYLBg0LCAsLCwsLCwsLBgYNCw0NDQ0NDQ0LCw0NBg0NCxUNDQ0NDQ0NDQ0RDQ0NCA0IDwsICwsLCwsJCwsGCAsGEQsLCwsJCwkLCxELCwsJBgkRDwYPDRcXCw0NDQ0NDQ0TDQsLCwsGBgYGDQ0NDQ0NDQ0NDQ0NDQsLCwsLCxELCwsLCwgICQkLCwsLCwsLCwsLCwsVEQYGCwsaEBwIAAYGBgwQDhISBggIEA4GDAYODAgMDAwMDAwMDAYGDgwODg4ODg4ODAwODgYODgwWDg4ODg4ODg4OEg4ODggOCBAMCAwMDAwMCgwMBggMBhIMDAwMCgwKDAwSDAwMCgYKEhAGEA4YGAwODg4ODg4OFA4MDAwMBgYGBg4ODg4ODg4ODg4ODg4MDAwMDAwSDAwMDAwICAoKDAwMDAwMDAwMDAwMFhIGBgwMHBEeCQAGBgYNEQ8TEwYJCREPBg0GDw0JDQ0NDQ0NDQ0GBg8NDw8PDw8PDw0NDw8GDw8NFw8PDw8PDw8PDxMPDw8JDwkRDQkNDQ0NDQsNDQYJDQYTDQ0NDQsNCw0NEw0NDQsGCxMRBhEPGhoNDw8PDw8PDxUPDQ0NDQYGBgYPDw8PDw8PDw8PDw8PDQ0NDQ0NEw0NDQ0NCQkLCw0NDQ0NDQ0NDQ0NDRcTBgYNDR4SIAkABwcHDhIQFBQHCQkSEAcOBxAOCQ4ODg4ODg4OBwcQDhAQEBAQEBAODhAQBxAQDhkQEBAQEBAQEBAUEBAQCRAJEg4JDg4ODg4LDg4HCQ4HFA4ODg4LDgsODhQODg4LBwsUEgcSEBsbDhAQEBAQEBAXEA4ODg4HBwcHEBAQEBAQEBAQEBAQEA4ODg4ODhQODg4ODgkJCwsODg4ODg4ODg4ODg4ZFAcHDg4gEyEKAAcHBw4TERUVBwoKExEHDgcRDgoODg4ODg4ODgcHEQ4RERERERERDg4REQcREQ4aERERERERERERFREREQoRChMOCg4ODg4ODA4OBwoOBxUODg4ODA4MDg4VDg4ODAcMFRMHExEdHQ4RERERERERGBEODg4OBwcHBxEREREREREREREREREODg4ODg4VDg4ODg4KCgwMDg4ODg4ODg4ODg4OGhUHBw4OIRQjCgAICAgPFBIXFwgKChQSCA8IEg8KDw8PDw8PDw8ICBIPEhISEhISEg8PEhIIEhIPHBISEhISEhISEhcSEhIKEgoUDwoPDw8PDw0PDwgKDwgXDw8PDw0PDQ8PFw8PDw0IDRcUCBQSHh4PEhISEhISEhkSDw8PDwgICAgSEhISEhISEhISEhISDw8PDw8PFw8PDw8PCgoNDQ8PDw8PDw8PDw8PDxwXCAgPDyMVJQsACAgIEBUSGBgICwsVEggQCBIQCxAQEBAQEBAQCAgSEBISEhISEhIQEBISCBISEB0SEhISEhISEhIYEhISCxILFRALEBAQEBANEBAICxAIGBAQEBANEA0QEBgQEBANCA0YFQgVEiAgEBISEhISEhIaEhAQEBAICAgIEhISEhISEhISEhISEhAQEBAQEBgQEBAQEAsLDQ0QEBAQEBAQEBAQEBAdGAgIEBAlFicLAAgICBEWExkZCAsLFhMIEQgTEQsREREREREREQgIExETExMTExMTERETEwgTExEeExMTExMTExMTGRMTEwsTCxYRCxERERERDhERCAsRCBkRERERDhEOEREZERERDggOGRYIFhMhIRETExMTExMTHBMRERERCAgICBMTExMTExMTExMTExMREREREREZERERERELCw4OERERERERERERERERHhkICBERJxcoDAAJCQkRFxQaGgkMDBcUCREJFBEMEREREREREREJCRQRFBQUFBQUFBERFBQJFBQRIBQUFBQUFBQUFBoUFBQMFAwXEQwREREREQ4REQkMEQkaEREREQ4RDhERGhEREQ4JDhoXCRcUIyMRFBQUFBQUFB0UEREREQkJCQkUFBQUFBQUFBQUFBQUERERERERGhERERERDAwODhERERERERERERERESAaCQkRESgYKgwACQkJEhgVGxsJDAwYFQkSCRUSDBISEhISEhISCQkVEhUVFRUVFRUSEhUVCRUVEiEVFRUVFRUVFRUbFRUVDBUMGBIMEhISEhIPEhIJDBIJGxISEhIPEg8SEhsSEhIPCQ8bGAkYFSQkEhUVFRUVFRUeFRISEhIJCQkJFRUVFRUVFRUVFRUVFRISEhISEhsSEhISEgwMDw8SEhISEhISEhISEhIhGwkJEhIqAAAC2wGQAAUAAQK8AooAAACPArwCigAAAcUAMgEDAAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAEFsdHMAQAAgISIEZf8GAAAF3AD6AAAAAQAAgAAAAAF3A28AAGAABOYCdUZGRiBGb3J3YXJkICAgICD/////N////kZGRlIwMAAAAAAAAAABAAAAAQAACMgrx18PPPUAAAPoAAAAALstvKsAAAAAuy28q/98/oAGWQbaAAAAAwACAAEAAAAAAAEAAARl/wYAAAbW/3z/gwZZAAEAAAAAAAAAAAAAAAAAAACqAAEAAACqADQACwAAAAAAAgAIAEAACgAAAIcA6gABAAE=';
Module['FS_createDataFile']('/assets', 'fff-forward.regular.ttf', decodeBase64(fileData3), true, true, false);
var fileData4 = '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USVSJU4lTyVNJUslSyVSNU81UDVKNU01RzVKNUM1RzU+NUQ1OzU+NTo1OTU3NTU1NTUxNTA1LzUrNS01JjUpNSQ1IzUjNR01IzUYNR41FzUYNRQ1FjUONRM1DDUMNQs1CDUGNQY1AjUDNVooWShYKFcoVihSKFUoTShVKEkoUihIKEwoSShGKEgoRChEKEMoQChAKD4oPSg7KDooOig1KDgoMig3KC0oNigoKDUoXPBl8LLbttu427fbu9u627vbwNu828TbvtvF28LbxtvH28bbytvK28rbztvL29Hb0NvR29Lb1NvU29jb1tva29nb29ve29vb5dva2+jb3tvn2+Xb5tvo2+rb6dvt2+zb7dvx2/Db8Nv22/Hb99v32/fb+tv92/fbBNz42yIlGiUdJRglGyUUJRolESUWJRAlEiURJQwlDyUJJQwlCCUKJQQlByUDJQIlAiUAJf0k/yT7JP0k9yT6JPQk+CTzJPMk8yTvJBE0DjQMNAs0CTQGNAY0BDT/MwI0/DP9M/kz+jP0M/cz8DPzM+4z7jPrM+kz6DPmM+Qz4zPfM+Az2zPcM9kz1jPYM9Ez0zPPM84zzTPLM8czyDPEM8MzwjO1JLQktCSwJLEkrySuJK4kqCSsJKgkpySmJKUkoiSkJJ4koiSbJKAkmSSdJJUkmySTJJckkySSJJEkjySPJIskjiSIJJDmjeaT3JPcldyX3Jfcm9yY3J7cnNyd3KLcndym3KDcptyl3Kncp9yr3Kvcq9yv3K7crty23K7cudyx3Lrctty63Lrcu9y+3L7cv9zC3MLcxNzE3Mbcx9zI3MvcytzN3M/czNzU3M7c1tzR3Njc09zc3Nbc3tzZ3N/c3dzh3ODc49zj3OXc59zo3Ofc7dzm3PPc6tzy3O/c9Nzw3Pnc8dz63Pbc+9z63P7c/dz+3ADdAt0B3QfdAt0K3QXdDN0H3Q7dDN0P3Q/dE90O3RrdD90b3RPdG90a3RzdHN0f3R7dIt0i3SLdJ90k3SndJ90p3S3dLN0u3TDdLt0z3TPdM9043TXdOd053TvdPN0+3T7dQt0/3UXdQt1G3UfdRt1M3UjdTt1L3VDdT91S3VLdVN1V3VXdWt1X3VvdXN1b3WDdYN1e3WbdYN1o3WTdad1n3Wzdat1v3WzdcN1x3XHddN103XXded133XzdeN1/3X3df92B3YLdgt2G3YTdid2H3Yvdit2M3ZDdjd2R3ZLdkt2V3Zbdl92X3Zvdmt2d3Z7dnt2h3aHdo92l3aTdqt2l3azdqd2t3a7drt2y3a/dtN213bPdut223bndvN273b7dwN293cXdv93G3cbdxd3L3cbdzd3M3c7dzt3R3c/d193Q3drd0t3d3dTd4d3W3eLd3d3h3eLd4t3k3ebd593o3evd6N3v3evd8d3v3fPd8d323fTd+d333fvd+d3+3fzdAN4A3gLeBd4C3gfeB94H3g3eB94R3greEt4P3hPeEt4W3hXeF94Z3hneHN4d3h7eIN4f3iTeId4n3iTeKd4p3ineLd4r3i/eMt4u3jXeMd433jTeOt433j3eOd4/3j7eQN5B3kTeQt5I3kTeSd5K3kneTd5O3kzeVN5O3lXeVN5U3lneWN5Y3l7eWt5e3mLeXN5l3mHeZt4tJS8lKyUsJSglKCUlJSUlJCUgJSElHSUeJRolGiUZJRUlGCUQJRUlDyUPJQ4lDCUJJQ0lASUMJQAlBSUBJf8k/yT8JI8ojSiNMI4whzCJMIYwgjCDMIAwfDB/MHYwejB1MHQwcTBxMGwwbjBoMGkwZTBlMGAwYjBbMF4wVzBcMFAwWDBOMFMwTDBNMEcwTDBBMEgwPjBEMDowPjA4MDgwNzAxMDQwLTAvMC0wKDAoMCYwITAkMB4wHjAbMBkwGTAUMBQwEDARMAowEDAFMAkwBTADMAIw/y/8L/wv+C/4L/Qv9C/wL/Ev6i/vL+Qv6y/hL+Yv3y/gL9wv2i/ZL9Yv1i/RL9IvzC/PL8gvyi/GL8QvxC+/L78vvC+6L7gvty+0L7Evsi+sL6wvrC+lL6gvpC+fL6Mvmy+dL5ovli+XL5Evky+OL40vjC+JL4cvhC+DL4Ivfi9+L3kvei92L3YvcS9yL20vbi9qL2kvZS9mL2EvYS9eL1ovXC9YL1UvVS9RL08vTy9KL0ovSS9DL0YvPy9BLzsvPy81LzsvMi81Ly4vMy8mLzMvIi8rLyIvJC8dLyQvFC8iLxAvHi8MLxkvCy8QLwovCS8JLwUvBC8AL/8u/i76Lvou9C73LvAu8y7uLuwu6i7qLuQu5i7gLuIu3C7fLtcu2S7WLtIu0i7PLswuzS7ILscuxi7CLsAuwS65Lr4utS64LrIutS6sLrIuqS6sLqYupy6iLqIuny6dLpoumy6ULpgukC6TLo0ujy6HLoouhS6FLoEugC58Ln4udy56LnMudi5vLnEubC5rLmguaC5iLmYuXC5hLlouWy5WLlcuUi5ULk4uTi5LLkkuSC5ELkMuQS4+Lj0uOS45LjUuNi4uLjMuKy4tLiguJy4kLiUuHy4fLhwuGy4ZLhcuEy4TLhAuDS4OLgYuDC4BLgYuAC7/Lf4t+C37LfQt9i3xLfEt7C3tLegt6S3kLeQt4C3fLdwt3C3XLdgt0S3VLc0t0S3JLcotyC3ELcQtwS29Lb8tty29LbEtuS17J4En8R/vH+8f7R/qH+sf6B/mH+Yf4x/iH+If3R/eH90f2B/dH9If2x/RH9cfzx/TH8wf0B/JH80fxh/KH8Mfxh/BH8MfvR9P20bbUttM21TbUttU21jbVttc21rbXtte22PbYttk22fbZ9tq22zbbNtw23Dbddty23fbd9t5233bfNuA23/bhduA24vbgtuO24jbj9uO25DbktuV25Pbm9uV257bnNuf26Hboduk26bbp9up26zbq9ux267btNuy27Xbudu3277butvA27/bw9vD28fbxNvM28jb0NvL29Pb0dvU29fb1dvb29nb3tve29/b5dvg2+vb4dvx2+Pb89vr2/Hb89vy2/fb9tv82/jbANz82wPcAdwE3AXcB9wL3AncENwK3BXcD9wX3BTcGdwY3B7cG9wh3B7cJNwj3CfcJ9wq3CzcLNww3DHcMtw33DTcOtw53DzcPtxA3EDcRNxC3EjcR9xL3E3cTNxQ3FHcVNxV3FbcWtxY3GDcW9xj3F7caNxi3GvcZdxv3Gncctxu3HLcc9x33HXcfNx53H7cftyA3IPchNyG3InchtyR3Ijck9yP3JPcltyV3Jncmtyc3J7cn9yj3KHcqNyk3KzcqNyv3Kzcstyx3LXctdy43Ljcvdy83L/cwdzC3MTcyNzG3Mvcy9zO3M/c0tzT3NTc19zZ3Nnc4NzY3Obc3Nzp3OHc6tzo3Orc79zs3PLc89zx3Prc9Nz83Prc/9z93ATd/9wI3QXdC90J3Q7dDd0R3RLdE90X3RfdGt0a3R3dId0e3SbdIN0p3SjdKd0t3SzdMN0y3TLdN9013TzdON1A3TzdQt1C3UTdR91H3UrdS91O3U/dUd1U3VLdWt1X3VzdXN1f3WDdY91j3WbdaN1q3Wrdb91t3XLddN103XjdeN163X/de92C3YLdgt2J3YXdi92M3Yzdkt2P3ZTdld2W3Zrdmd2d3Z7dod2j3aPdqN2k3a7dqN2w3a3dtN2w3brds9283bndvd2/3cDdw93D3cjdx93M3crdz9123HrcwNXB1cXVxdXJ1czVzNXS1c/V19XW1djV3tXa1eXV3dXs1eHV7tXq1e7V89Vd1s7WO9eo1xfYhNjy2F/Zz9k52qraFduE2/HbYNzI3D3dod0Y3n3e8N5Z38nfMuCi4A/heeHq4VLiweIx45bjC+Rv5OPkSeW85SDmlOb75mjn1eeG6urq0+0o7m/xtvHE9UxJU1RKAAAASU5GT0lDUkQMAAAAMjAxNi0wNC0wNgAASVNGVCoAAABTb255IFNvdW5kIEZvcmdlIDcuMCAobGlic25kZmlsZS0xLjAuMjQpAABpZDMgSAAAAElEMwMAAAAAAD1URFJDAAAACwAAADIwMTYtMDQtMDZUWFhYAAAAHgAAAFNvZnR3YXJlAFNvbnkgU291bmQgRm9yZ2UgNy4wAA==';
Module['FS_createDataFile']('/assets', 'HitWall.wav', decodeBase64(fileData4), true, true, false);
var fileData5 = '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jPiG+Ib4gfiB+Hz4fPh3+Hf4cvhy+G34bfho+Gj4Y/hj+F74XvhZ+Fn4VPhU+E/4T/hK+Er4RfhF+ED4QPg7+Dv4Nvg2+DL4Mvgt+C34Kfgp+CT4JPgf+B/4G/gb+Bb4FvgS+BL4DfgN+An4CfgE+AT4APgA+Pz3/Pf49/j38/fz9+/37/fr9+v35vfm9+L34vfe99732vfa99b31vfS99L3zvfO98r3yvfG98b3wvfC9773vve697r3tve297L3sveu9673qveq96f3p/ej96P3n/ef95z3nPeY95j3lPeU95H3kfeN9433iveK94b3hveC94L3f/d/93v3e/d493j3dPd093H3cfdt9233avdq92f3Z/dj92P3YPdg9133XfdZ91n3VvdW91P3U/dQ91D3TPdM90n3SfdG90b3Q/dD90D3QPc99z33Ofc59zb3Nvc09zT3MPcw9y33Lfcq9yr3J/cn9yT3JPch9yH3Hvce9xz3HPcZ9xn3FvcW9xP3E/cQ9xD3DfcN9wv3C/cI9wj3BfcF9wL3Avf/9v/2/fb99vr2+vb39vf29fb19vL28vbw9vD27fbt9ur26vbo9uj25fbl9uP24/bg9uD23vbe9tv22/bZ9tn21vbW9tT21PbR9tH2z/bP9sz2zPbK9sr2yPbI9sX2xfbD9sP2wfbB9r72vva89rz2uva69rj2uPZICUgJQglCCT0JPQk3CTcJMQkxCSsJKwklCSUJIAkgCRoJGgkUCRQJDgkOCQgJCAkDCQMJ/Qj9CPcI9wjxCPEI6wjrCOYI5gjgCOAI2gjaCNQI1AjOCM4IyQjJCMMIwwi9CL0Itwi3CLEIsQisCKwIpgimCKAIoAiaCJoIlAiUCI8IjwiJCIkIgwiDCH0IfQh3CHcIcQhxCGwIbAhmCGYIYAhgCFoIWghUCFQITghOCEkISQhDCEMIPQg9CDcINwgxCDEIKwgrCCYIJgggCCAIGggaCBQIFAgOCA4ICAgICAMIAwj9B/0H9wf3B/EH8QfrB+sH5QflB98H3wfZB9kH1AfUB84HzgfIB8gHwgfCB7wHvAe2B7YHsAewB6oHqgekB6QHnwefB5kHmQeTB5MHjQeNB4cHhweBB4EHewd7B3UHdQdvB28HaQdpB2MHYwddB10HVwdXB1EHUQdMB0wHRgdGB0AHQAc6BzoHNAc0By4H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ePp3+nf6dvp2+nX6dfp0+nT6c/pz+nL6cvpx+nH6cPpw+m/6b/pu+m76bfpt+mz6bPpr+mv6avpq+mn6afpp+mn6aPpo+mf6Z/pm+mb6Zfpl+mT6ZPpj+mP6Y/pj+mL6Yvph+mH6YPpg+l/6X/pe+l76Xvpe+l36Xfpc+lz6W/pb+lr6Wvpa+lr6WfpZ+lj6WPpY+lj6V/pX+lb6VvpV+lX6VfpV+lT6VPpT+lP6U/pT+lL6UvpR+lH6UfpR+lD6UPpP+k/6T/pP+k76TvpN+k36TfpN+kz6TPpM+kz6S/pL+kr6SvpK+kr6SfpJ+kn6SfpI+kj6SPpI+kf6R/pH+kf6RvpG+kb6RvpF+kX6RfpF+kT6RPpE+kT6Q/pD+kP6Q/pC+kL6QvpC+kH6QfpB+kH6QPpA+kD6QPpA+kD6P/o/+j/6P/o++j76Pvo++j36Pfo9+j36Pfo9+jz6PPo8+jz6O/o7+jv6O/o7+jv6Ovo6+jr6Ovo6+jr6Ofo5+jn6Ofo5+jn6Ofo5+jj6OPo4+jj6OPo4+jf6N/o3+jf6N/o3+jb6Nvo2+jb6Nvo2+jb6Nvo1+jX6Nfo1+jX6Nfo1+jX6Nfo1+jT6NPo0+jT6NPo0+jT6NPoz+jP6M/oz+jP6M/oz+jP6M/oz+jP6M/oy+jL6Mvoy+jL6Mvoy+jL6Mvoy+jL6Mvoy+jL6Mfox+jH6Mfox+jH6Mfox+jH6Mfox+jH6Mfox+jH6Mfox+jH6Mfox+jD6MPow+jD6MPow+jD6MPow+jD6MPow+jD6MPow+jD6MPow+jD6MPow+jD6MPow+jD6MPow+jD6MPow+jD6MPow+jD6MPow+jD6MPow+jD6MPow+jD6MPow+jD6MPow+jD6MPow+jD6MPow+jD6MPow+jD6Mfox+jH6Mfox+jH6Mfox+jH6Mfox+jH6Mfox+jH6Mfox+jH6Mfox+jH6Mfoy+jL6Mvoy+jL6Mvoy+jL6Mvoy+jL6Mvoy+jL6M/oz+jP6M/oz+jP6M/oz+jP6M/oz+jP6NPo0+jT6NPo0+jT6NPo0+jT6NPo1+jX6Nfo1+jX6Nfo1+jX6Nfo1+jb6Nvo2+jb6Nvo2+jb6Nvo2+jb6N/o3+jf6N/o3+jf6N/o3+jj6OPo4+jj6OPo4+jn6Ofo5+jn6Ofo5+jn6Ofo6+jr6Ovo6+jr6Ovo7+jv6O/o7+jv6O/o7+jv6PPo8+jz6PPo8+jz6Pfo9+j36Pfo9+j36Pvo++j76Pvo++j76P/o/+j/6P/o/+j/6QPpA+kD6QPpB+kH6QfpB+kH6QfpC+kL6QvpC+kL6QvpD+kP6Q/pD+kT6RPpE+kT6RPpE+kX6RfpF+kX6RvpG+kb6RvpH+kf6R/pH+kf6R/pI+kj6SPpI+kn6SfpJ+kn6SfpJ+kr6SvpK+kr6S/pL+kv6S/pM+kz6TPpM+k36TfpN+k36TvpO+k76TvpP+k/6T/pP+lD6UPpQ+lD6UfpR+lH6UfpS+lL6UvpS+lP6U/pT+lP6VPpU+lT6VPpV+lX6VfpV+lb6VvpW+lb6V/pX+lf6V/pY+lj6WfpZ+ln6Wfpa+lr6Wvpa+lv6W/pb+lv6XPpc+lz6XPpd+l36Xvpe+l76Xvpf+l/6X/pf+mD6YPpg+mD6Yfph+mL6Yvpi+mL6Y/pj+mP6Y/pk+mT6Zfpl+mX6Zfpm+mb6Z/pn+mf6Z/po+mj6aPpo+mn6afpq+mr6avpq+mv6a/ps+mz6bPps+m36bfpu+m76bvpu+m/6b/pw+nD6cPpw+nH6cfpy+nL6cvpy+nP6c/p0+nT6dPp0+nX6dfp2+nb6dvp2+nf6d/p4+nj6ePp4+nn6efp6+nr6e/p7+nv6e/p8+nz6ffp9+n36ffp++n76f/p/+oD6gPqA+oD6gfqB+oL6gvqD+oP6g/qD+oT6hPqF+oX6hvqG+ob6hvqH+of6iPqI+on6ifqJ+on6ivqK+ov6i/qM+oz6jPqM+o36jfqO+o76j/qP+pD6kPqQ+pD6kfqR+pL6kvqT+pP6lPqU+pT6lPqV+pX6lvqW+pf6l/qY+pj6mPqY+pn6mfqa+pr6m/qb+pz6nPqd+p36nfqd+p76nvqf+p/6oPqg+qH6ofqi+qL6ovqi+qP6o/qk+qT6pfql+qb6pvqn+qf6qPqo+qj6qPqp+qn6qvqq+qv6q/qs+qz6rfqt+q76rvqv+q/6r/qv+rD6sPqx+rH6svqy+rP6s/q0+rT6tfq1+rb6tvq3+rf6t/q3+rj6uPq5+rn6uvq6+rv6u/q8+rz6vfq9+r76vvq/+r/6wPrA+sH6wfrC+sL6w/rD+sP6w/rE+sT6xfrF+sb6xvrH+sf6yPrI+sn6yfrK+sr6y/rL+sz6zPrN+s36zvrO+s/6z/rQ+tD60frR+tL60vrT+tP61PrU+tX61frW+tb61/rX+tj62PrZ+tn62vra+tv62/rc+tz63frd+t763vrf+t/64Prg+uH64fri+uL64/rj+uT65Prl+uX65vrm+uf65/ro+uj66frp+ur66vrr+uv67Prs+u367fru+u767/rv+vD68Prx+vH68vry+vP68/r0+vT69fr1+vb69vr3+vf6+Pr4+vn6+fr6+vr6/Pr8+v36/fr++v76//r/+gD7APsB+wH7AvsC+wP7A/sE+wT7BfsF+wb7BvsH+wf7CPsI+wr7CvsL+wv7DPsM+w37DfsO+w77D/sP+xD7EPsR+xH7EvsS+xP7E/sV+xX7FvsW+xf7F/sY+xj7GfsZ+xr7Gvsb+xv7HPsc+x37Hfsf+x/7IPsg+yH7Ifsi+yL7I/sj+yT7JPsl+yX7J/sn+yj7KPsp+yn7Kvsq+yv7K/ss+yz7Lfst+y/7L/sw+zD7Mfsx+zL7Mvsz+zP7NPs0+zb7Nvs3+zf7OPs4+zn7Ofs6+zr7O/s7+z37Pfs++z77P/s/+0D7QPtB+0H7Q/tD+0T7RPtF+0X7RvtG+0f7R/tJ+0n7SvtK+0v7S/tM+0z7TftN+0/7T/tQ+1D7UftR+1L7UvtT+1P7VftV+1b7VvtX+1f7WPtY+1r7Wvtb+1v7XPtc+137Xfte+177YPtg+2H7Yfti+2L7Y/tj+2X7Zftm+2b7Z/tn+2j7aPtq+2r7a/tr+2z7bPtt+237b/tv+3D7cPtx+3H7c/tz+3T7dPt1+3X7dvt2+3j7ePt5+3n7evt6+3v7e/t9+337fvt++3/7f/uB+4H7gvuC+4P7g/uE+4T7hvuG+4f7h/uI+4j7ivuK+4v7i/uM+4z7jvuO+4/7j/uQ+5D7kfuR+5P7k/uU+5T7lfuV+5f7l/uY+5j7mfuZ+5v7m/uc+5z7nfud+5/7n/ug+6D7ofuh+6P7o/uk+6T7pful+6f7p/uo+6j7qfup+6v7q/us+6z7rfut+6/7r/uw+7D7sfux+7P7s/u0+7T7tvu2+7f7t/u4+7j7uvu6+7v7u/u8+7z7vvu++7/7v/vB+8H7wvvC+8P7w/vF+8X7xvvG+8f7x/vJ+8n7yvvK+8z7zPvN+837zvvO+9D70PvR+9H70/vT+9T71PvV+9X71/vX+9j72Pva+9r72/vb+9z73Pve+9773/vf++H74fvi++L75Pvk++X75fvm++b76Pvo++n76fvr++v77Pvs++777vvv++/78Pvw+/L78vvz+/P79fv1+/b79vv4+/j7+fv5+/v7+/v8+/z7/fv9+//7//sA/AD8AvwC/AP8A/wF/AX8BvwG/Aj8CPwJ/An8C/wL/Az8DPwO/A78D/wP/BH8EfwS/BL8FPwU/BX8FfwX/Bf8GPwY/Br8Gvwb/Bv8Hfwd/B78Hvwg/CD8Ifwh/CP8I/wk/CT8Jvwm/Cf8J/wp/Cn8Kvwq/Cz8LPwt/C38L/wv/DD8MPwy/DL8M/wz/DX8Nfw2/Db8OPw4/Dn8Ofw7/Dv8PPw8/D78PvxA/ED8QfxB/EP8Q/xE/ET8RvxG/Ef8R/xJ/En8SvxK/Ez8TPxO/E78T/xP/FH8UfxS/FL8VPxU/FX8VfxX/Ff8WfxZ/Fr8Wvxc/Fz8Xfxd/F/8X/xg/GD8Yvxi/GT8ZPxl/GX8Z/xn/Gj8aPxq/Gr8bPxs/G38bfxv/G/8cPxw/HL8cvx0/HT8dfx1/Hf8d/x5/Hn8evx6/Hz8fPx9/H38f/x//IH8gfyC/IL8hPyE/Ib8hvyH/If8ifyJ/Iv8i/yM/Iz8jvyO/I/8j/yR/JH8k/yT/JT8lPyW/Jb8mPyY/Jn8mfyb/Jv8nfyd/J78nvyg/KD8ovyi/KT8pPyl/KX8p/yn/Kn8qfyq/Kr8rPys/K78rvyv/K/8sfyx/LP8s/y0/LT8tvy2/Lj8uPy6/Lr8u/y7/L38vfy//L/8wPzA/ML8wvzE/MT8xvzG/Mf8x/zJ/Mn8y/zL/M38zfzO/M780PzQ/NL80vzU/NT81fzV/Nf81/zZ/Nn82/zb/Nz83Pze/N784Pzg/OL84vzk/OT85fzl/Of85/zp/On86/zr/Oz87Pzu/O788Pzw/PL88vz0/PT89fz1/Pf89/z5/Pn8+/z7/P38/fz//P/8AP0A/QL9Av0E/QT9Bv0G/Qj9CP0K/Qr9C/0L/Q39Df0P/Q/9Ef0R/RP9E/0V/RX9F/0X/Rj9GP0a/Rr9HP0c/R79Hv0g/SD9Iv0i/ST9JP0m/Sb9KP0o/Sn9Kf0r/Sv9Lf0t/S/9L/0x/TH9M/0z/TX9Nf03/Tf9Of05/Tv9O/09/T39P/0//UH9Qf1C/UL9RP1E/Ub9Rv1I/Uj9Sv1K/Uz9TP1O/U79UP1Q/VL9Uv1U/VT9Vv1W/Vj9WP1a/Vr9XP1c/V79Xv1g/WD9Yv1i/WT9ZP1m/Wb9aP1o/Wr9av1s/Wz9bv1u/XD9cP1y/XL9df11/Xf9d/15/Xn9e/17/X39ff1//X/9gf2B/YP9g/2F/YX9h/2H/Yn9if2L/Yv9jv2O/ZD9kP2S/ZL9lP2U/Zb9lv2Y/Zj9mv2a/Z39nf2f/Z/9of2h/aP9o/2l/aX9p/2n/ar9qv2s/az9rv2u/bD9sP2y/bL9tf21/bf9t/25/bn9u/27/b79vv3A/cD9wv3C/cT9xP3H/cf9yf3J/cv9y/3O/c790P3Q/dL90v3V/dX91/3X/dn92f3c/dz93v3e/eD94P3j/eP95f3l/ef95/3q/er97P3s/e/97/3x/fH98/3z/fb99v34/fj9+/37/f39/f0A/gD+Av4C/gX+Bf4H/gf+Cv4K/gz+DP4P/g/+Ef4R/hT+FP4X/hf+Gf4Z/hz+HP4e/h7+If4h/iT+JP4m/ib+Kf4p/iz+LP4u/i7+Mf4x/jT+NP42/jb+Of45/jz+PP4//j/+Qv5C/kT+RP5H/kf+Sv5K/k3+Tf5Q/lD+U/5T/lb+Vv5Y/lj+W/5b/l7+Xv5h/mH+ZP5k/mf+Z/5q/mr+bf5t/nH+cf50/nT+d/53/nr+ev59/n3+gP6A/oT+hP6H/of+iv6K/o3+jf6R/pH+lP6U/pf+l/6b/pv+nv6e/qL+ov6l/qX+qf6p/q3+rf6w/rD+tP60/rj+uP67/rv+v/6//sP+w/7H/sf+y/7L/s/+z/7T/tP+1/7X/tv+2/7g/uD+5P7k/uj+6P7t/u3+8f7x/vb+9v77/vv+//7//gT/BP8J/wn/Dv8O/xT/FP8Z/xn/Hv8e/yT/JP8q/yr/MP8w/zb/Nv89/z3/Q/9D/0r/Sv9R/1H/Wf9Z/2H/Yf9q/2r/c/9z/33/ff+H/4f/k/+T/6H/of+y/7L/AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA==';
Module['FS_createDataFile']('/assets', 'Hit_Hurt2.wav', decodeBase64(fileData5), true, true, false);
var fileData6 = 'AAEAAAAPAIAAAwBwR1BPU7XUtogAALS4AAADOkdTVUJ1m2xLAAC39AAAAgBPUy8yrOMy3AAAAXgAAABgVkRNWHT4fHYAAAqAAAAF4GNtYXAqVFD/AAAQYAAAFThnYXNw//8AAwAAtLAAAAAIZ2x5Zi+gDY8AACWYAABzKGhlYWQPYHPdAAAA/AAAADZoaGVhBF0DQQAAATQAAAAkaG10eLwAjugAAAHYAAAIqGtlcm794wFoAACdGAAAAmpsb2NhGf/8tAAAmMAAAARWbWF4cAI+AH4AAAFYAAAAIG5hbWXIJx42AACfhAAABEtwb3N0m+W1wAAAo9AAABDgAAEAAAAFAAADiSexXw889QAJA+gAAAAA1+aXJAAAAADX5phP/Tb/OAM8BEwAAAAJAAIAAAAAAAAAAQAAA+j/OAAAAzz9Nv6iAzwAAQAAAAAAAAAAAAAAAAAAAioAAQAAAioASAALADQABQABAAAAAAAAAAAAAAAAAAMAAQADAzwBkAAFAAQB9AH0AAAAAAH0AfQAAAH0ADEB9AAAAgEGCQIBAgIDBKAAAs8QAEATAAAAAAAAAABUWVBPAEAAF/j/AyD/OADIA+gAyCAAAZ8AAAAAArwCvAAAACAAAwM8AKQDPAAAAzwAAAM8AKQDPACkAzwApAM8AEADPAByAzwAQAM8AToDPAFsAzwApAM8AEADPAByAzwBOgM8AKQDPAE6AzwAQAM8AEADPAByAzwAQAM8AEADPABAAzwAQAM8AEADPABAAzwAQAM8AEADPAE6AzwBOgM8AKQDPAByAzwApAM8AEADPABAAzwAQAM8AEADPABAAzwAQAM8AEADPABAAzwAQAM8AEADPAByAzwAQAM8AEADPABAAzwAQAM8AEADPABAAzwAQAM8AEADPABAAzwAQAM8AHIDPABAAzwAQAM8AEADPABAAzwAcgM8AEADPAEIAzwAQAM8AKQDPACkAzwAQAM8AQgDPAEIAzwBOgM8AKQDPAByAzwAAAM8AKQDPAB+AzwAQAM8AKQDPAByAzwBOgM8AEADPACkAzwAQAM8ANYDPABAAzwAcgM8AEADPAEIAzwApAM8AHIDPACkAzwApAM8AQgDPABAAzwAQAM8AToDPAEIAzwApAM8ANYDPABAAzwAQAM8AEADPABAAzwAQAM8AEADPABAAzwAQAM8AEADPABAAzwAQAM8AA4DPABAAzwAQAM8AEADPABAAzwAQAM8AHIDPAByAzwAcgM8AHIDPABAAzwAQAM8AEADPABAAzwAQAM8AEADPABAAzwApAM8AEADPABAAzwAQAM8AEADPABAAzwAcgM8AEADPAByAzwAcgM8AEADPABAAzwAQAM8AEADPABAAzwAQAM8AEADPABAAzwAQAM8AEADPABAAzwAQAM8AEADPABAAzwAQAM8AEADPABAAzwAQAM8AAADPAByAzwAcgM8AHIDPAByAzwAcgM8ACYDPABAAzwAQAM8AEADPABAAzwAQAM8AEADPABAAzwAQAM8AEADPABAAzwAQAM8AEADPABAAzwAEgM8AEADPABAAzwAQAM8AEADPABAAzwAQAM8AEADPAByAzwAcgM8AHIDPABAAzwAQAM8AEADPABAAzwAQAM8AEADPABAAzwAcgM8AEADPABAAzwAQAM8AEADPABAAzwAQAM8AEADPABAAzwA1gM8AEADPABAAzwAQAM8AEADPABAAzwAQAM8AEADPABAAzwAQAM8AEADPACkAzwApAM8ANYDPAE6AzwBCAM8AQgDPADWAzwAcgAA/cwAAP3MAAD9aAAA/ZoAAP3MAAD9mgAA/f4AAP1oAAD9zAAA/cwAAP02AAD9aAAA/f4AAP3+AAD9/gAA/cwAAP3MAAD9aAAA/cwDPAFsAzwAQAM8AEADPAE6AzwAQAM8AEADPABAAzwAQAM8AEADPABAAzwAQAM8AEADPABAAzwAQAM8AEADPABAAzwAQAM8AEADPABAAzwAQAM8AEADPABAAzwAQAM8AEADPABAAzwAQAM8AEADPABAAzwAQAM8AEADPABAAzwAQAM8AEADPABAAzwAQAM8AEADPABAAzwAQAM8AEADPABAAzwAQAM8AEADPABAAzwAQAM8AEADPAAkAzwAQAM8AEADPABAAzwAQAM8AEADPABAAzwAQAM8AEADPABAAzwAQAM8AEADPABAAzwAQAM8AEADPABAAzwAQAM8AEADPABAAzwAQAM8AEADPABAAzwAQAM8AHIDPAByAzwAQAM8AEADPABAAzwAQAM8AEADPABAAzwAQAM8AEADPABAAzwAQAM8AEADPABAAzwAQAM8AEADPABAAzwAQAM8AEADPABAAzwAQAM8AEADPABAAzwAQAM8AEADPABAAzwAQAM8AEADPABAAzwAJAM8AEADPABAAzwAQAM8AEADPABAAzwAQAM8AEADPABAAzwAQAM8AEADPABAAzwAQAM8AEADPABAAzwAQAM8AEADPABAAzwAQAM8AEADPABAAzwAQAM8AEADPABAAzwAcgM8AHIDPABAAzwAQAM8AEADPABAAzwAQAM8AEADPABAAzwAQAM8AEADPABAAzwAQAM8AEADPABAAzwAQAM8AEADPABAAzwAQAM8AEADPABAAzwAQAM8AEADPABAAzwAQAM8AEADPABAAzwAcgM8AHIDPABAAzwAQAM8AEADPABAAzwAQAM8AEADPABAAzwAQAM8AEADPAAOAzwAQAM8AEADPABAAzwAQAM8AEADPABAAzwAQAM8AEADPABAAzwAcgM8AHIDPAAAAzwAQAM8AAADPAE6AzwBOgM8AToDPACkAzwApAM8AKQDPACkAzwApAM8AQgDPABAAzwAQAM8AQgDPABAAzwApAM8AQgAAP6iAzwApAM8AKQDPACkAzwApAM8AKQDPACkAzwApAM8AKQDPACkAzwApAM8AKQDPACkAzwApAM8AKQDPACkAzwApAM8AKQDPABAAzwAQAM8AEADPABAAzwAQAM8AHIDPABAAzwAQAM8AEADPAByAzwAcgM8AEADPAAOAzwAQAM8AEADPACkAzwAQAM8AEADPABAAzwAQAM8AEADPABAAzwAQAM8AEADPABAAzwAQAM8AEADPABAAzwAQAM8AEADPABAAzwAQAM8AEADPAByAzwAQAM8AEADPADWAzwAcgM8AEADPACkAzwApAM8AEADPACkAzwAQAM8AEADPABAAzwAQAM8AEADPABAAzwAQAM8AKQDPABAAzwAQAM8AEADPABAAzwAQAM8AEADPACkAzwAQAM8AEADPABAAzwBCAM8AQgDPACkAzwAQAM8AEADPABAAzwAQAM8AEADPAAAAzwAQAM8AToDPAByAzwAQAM8AEADPAAkAzwAQAM8AEADPABAAzwAQAM8AEADPABAAzwAQAM8AEADPABAAzwAQAM8AEADPABAAzwAQAM8AEADPABAAzwAQAM8AEADPABAAzwAJAM8AEADPABAAzwAQAM8AEADPABAAzwAQAM8AEADPABAAzwAJAM8AEADPABAAzwAQAM8AAAAAAAAAAAAAQABAQEBAQAMAPgI/wAIAAj//gAJAAn//gAKAAr//gALAAv//QAMAAz//QANAA3//QAOAA7//QAPAA///QAQABD//AARABH//AASABL//AATABP//AAUABT//AAVABX/+wAWABb/+wAXABf/+wAYABj/+wAZABn/+wAaABr/+gAbABv/+gAcABz/+gAdAB3/+gAeAB7/+gAfAB//+QAgACD/+QAhACH/+QAiACL/+QAjACP/+QAkACT/+AAlACX/+AAmACb/+AAnACf/+AAoACj/+AApACn/9wAqACr/9wArACv/9wAsACz/9wAtAC3/9wAuAC7/9gAvAC//9gAwADD/9gAxADH/9gAyADL/9gAzADP/9QA0ADT/9QA1ADX/9QA2ADb/9QA3ADf/9QA4ADj/9AA5ADn/9AA6ADr/9AA7ADv/9AA8ADz/9AA9AD3/8wA+AD7/8wA/AD//8wBAAED/8wBBAEH/8wBCAEL/8gBDAEP/8gBEAET/8gBFAEX/8gBGAEb/8gBHAEf/8QBIAEj/8QBJAEn/8QBKAEr/8QBLAEv/8QBMAEz/8ABNAE3/8ABOAE7/8ABPAE//8ABQAFD/8ABRAFH/7wBSAFL/7wBTAFP/7wBUAFT/7wBVAFX/7wBWAFb/7gBXAFf/7gBYAFj/7gBZAFn/7gBaAFr/7gBbAFv/7QBcAFz/7QBdAF3/7QBeAF7/7QBfAF//7QBgAGD/7ABhAGH/7ABiAGL/7ABjAGP/7ABkAGT/7ABlAGX/6wBmAGb/6wBnAGf/6wBoAGj/6wBpAGn/6wBqAGr/6gBrAGv/6gBsAGz/6gBtAG3/6gBuAG7/6gBvAG//6QBwAHD/6QBxAHH/6QByAHL/6QBzAHP/6QB0AHT/6AB1AHX/6AB2AHb/6AB3AHf/6AB4AHj/6AB5AHn/5wB6AHr/5wB7AHv/5wB8AHz/5wB9AH3/5wB+AH7/5gB/AH//5gCAAID/5gCBAIH/5gCCAIL/5gCDAIP/5QCEAIT/5QCFAIX/5QCGAIb/5QCHAIf/5QCIAIj/5ACJAIn/5ACKAIr/5ACLAIv/5ACMAIz/5ACNAI3/4wCOAI7/4wCPAI//4wCQAJD/4wCRAJH/4wCSAJL/4gCTAJP/4gCUAJT/4gCVAJX/4gCWAJb/4gCXAJf/4QCYAJj/4QCZAJn/4QCaAJr/4QCbAJv/4QCcAJz/4ACdAJ3/4ACeAJ7/4ACfAJ//4ACgAKD/4AChAKH/3wCiAKL/3wCjAKP/3wCkAKT/3wClAKX/3wCmAKb/3gCnAKf/3gCoAKj/3gCpAKn/3gCqAKr/3gCrAKv/3QCsAKz/3QCtAK3/3QCuAK7/3QCvAK//3QCwALD/3ACxALH/3ACyALL/3ACzALP/3AC0ALT/3AC1ALX/2wC2ALb/2wC3ALf/2wC4ALj/2wC5ALn/2wC6ALr/2gC7ALv/2gC8ALz/2gC9AL3/2gC+AL7/2gC/AL//2QDAAMD/2QDBAMH/2QDCAML/2QDDAMP/2QDEAMT/2ADFAMX/2ADGAMb/2ADHAMf/2ADIAMj/2ADJAMn/1wDKAMr/1wDLAMv/1wDMAMz/1wDNAM3/1wDOAM7/1gDPAM//1gDQAND/1gDRANH/1gDSANL/1gDTANP/1QDUANT/1QDVANX/1QDWANb/1QDXANf/1QDYANj/1ADZANn/1ADaANr/1ADbANv/1ADcANz/1ADdAN3/0wDeAN7/0wDfAN//0wDgAOD/0wDhAOH/0wDiAOL/0gDjAOP/0gDkAOT/0gDlAOX/0gDmAOb/0gDnAOf/0QDoAOj/0QDpAOn/0QDqAOr/0QDrAOv/0QDsAOz/0ADtAO3/0ADuAO7/0ADvAO//0ADwAPD/0ADxAPH/zwDyAPL/zwDzAPP/zwD0APT/zwD1APX/zwD2APb/zgD3APf/zgD4APj/zgD5APn/zgD6APr/zgD7APv/zQD8APz/zQD9AP3/zQD+AP7/zQD/AP//zQAAAAMAAAADAAALmAABAAAAAAAcAAMAAQAAAfgABgHcAAAAFwDpAAEAAAAAAAAAAAAAAAAAAAAAAAIAAwAEAAUABgAHAAgACQAKAAsADAANAA4ADwAQABEAEgATABQAFQAWABcAGAAZABoAGwAcAB0AHgAfACAAIQAiACMAJAAlACYAJwAoACkAKgArACwALQAuAC8AMAAxADIAMwA0ADUANgA3ADgAOQA6ADsAPAA9AD4APwBAAEEAQgAjACQAJQAmACcAKAApACoAKwAsAC0ALgAvADAAMQAyADMANAA1ADYANwA4ADkAOgA7ADwAQwBEAEUARgAAAGoAawBtAG8AdwB8AIIAZwBmAGgAagBpAGsAbQBvAG4AcABxAHMAcgB0AHUAdwB5AHgAegB8AHsAgAB/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AC8AMAD8ADEBAwAyAP4A/gA2ADsA/wA6AQABAQB1AIYA9QD2APcAbgBxAQQBBQEGADUAKwB1ACwBBwEIAQkBCgELAQwBDQAjAQ4AJAD5AQ8AJwEQAREBEgETAC0BFAAvACoAMQD9ADIAJQA2ARUA/wA6ACMBDgAkAPkBDwAnARABEQESARMALQEUAC8AKgAxAP0AMgAlADYBFQD/ADoAbgBxAQQBBQEGADUAKwB1ACwBRwFHASABIAEhASEBIgEiASMBIwEkASQBJQElASYBJgEnAScBKAEoASkBKQEqASoBKwErASwBLAEtAS0BLgEuAS8BLwEwATABMQExATIBMgA7ADsBMwEzATQBNAE1ATUBNgE2ATcBNwE4ATgBOQE5AToBOgIEATsBOwE8ATwBPQE9AT4BPgE/AT8BQAFAAUEBQQIEAIgAiABqAGoAbABsAJAAkADHAMcBQgFCAUMBQwFEAUQAFQAVAUUBRQFGAUYAfAB8AUcBRwFIAUgBSQFJAUoBSgFLAUsBTAFMAU0BTQFOAU4BTwFPAVABUAFRAVEBUgFSAVMBUwFUAVQAOQA5AVUBVQFWAVYBVwFXAVkBWQFaAVoBWwFbAVwBXAFdAV0BXgFeAV8BXwFgAWABYQFhAWIBYgFjAWMBZAFkAWUBZQFmAWYBZwFnAWgBaAFpAWkBagFqAWsBawFsAWwBbgFuAW8BbwFwAXABcQFxAXIBcgFzAXMBdAF0AXUBdQF2AXYBdwF3AXgBeAF5AXkBegF6AXsBewF8AXwBfQF9AX4BfgF/AX8BgAGAAYEBgQGCAYIBgwGDAYQBhAGFAYUBhgGGAYcBhwGIAYgBiQGJAYoBigGLAYsBjAGMAY0BjQGOAY4BjwGPAZABkAGRAZEBkgGSAZMBkwGUAZQBlQGVAZYBlgGXAZcBmAGYAgUCBQBnAG8CBgB5AgcCCAIJAgoCCwIMAGcAbwIGAHkCDQINAg4CDgIPAg8CEAIQAhECEQIHAgcAeAB4AhICEgITAhMCFAIUAhUCFQCHAIcAjwCPAhYCFwIXAhgCGACqAKoAqwCrAhkCGgIaAhsCGwIcAhwCHQIdAh4CHgIfAh8CIAIgAiECIQIiAiIBVwFXAiMCIwIkAiQCJQIlACgAKAImAiYABAmgAAABKAEAAAcAKAAXAGAAegB+AKwArQDeAPYBNwE+AUgBfgGB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AS4BLgEvAS8BMAEwATEBMQEyATIAOwA7ATMBMwE0ATQBNQE1ATYBNgE3ATcBOAE4ATkBOQE6AToCBAE7ATsBPAE8AT0BPQE+AT4BPwE/AUABQAFBAUECBACIAIgAagBqAGwAbACQAJAAxwDHAUIBQgFDAUMBRAFEABUAFQFFAUUBRgFGAHwAfAFHAUcBSAFIAUkBSQFKAUoBSwFLAUwBTAFNAU0BTgFOAU8BTwFQAVABUQFRAVIBUgFTAVMBVAFUADkAOQFVAVUBVgFWAVcBVwFZAVkBWgFaAVsBWwFcAVwBXQFdAV4BXgFfAV8BYAFgAWEBYQFiAWIBYwFjAWQBZAFlAWUBZgFmAWcBZwFoAWgBaQFpAWoBagFrAWsBbAFsAW4BbgFvAW8BcAFwAXEBcQFyAXIBcwFzAXQBdAF1AXUBdgF2AXcBdwF4AXgBeQF5AXoBegF7AXsBfAF8AX0BfQF+AX4BfwF/AYABgAGBAYEBggGCAYMBgwGEAYQBhQGFAYYBhgGHAYcBiAGIAYkBiQGKAYoBiwGLAYwBjAGNAY0BjgGOAY8BjwGQAZABkQGRAZIBkgGTAZMBlAGUAZUBlQGWAZYBlwGXAZgBmAIFAgUAZwBvAgYAeQIHAggCCQIKAgsCDABnAG8CBgB5Ag0CDQIOAg4CDwIPAhACEAIRAhECBwIHAHgAeAISAhICEwITAhQCFAIVAhUAhwCHAI8AjwIWAhcCFwIYAhgAqgCqAKsAqwIZAhoCGgIbAhsCHAIcAh0CHQIeAh4CHwIfAiACIAIhAiECIgIiAVcBVwIjAiMCJAIkAiUCJQAoACgCJgImAAIApP84ApgD6AADAAcAAAUhESEDESERApj+DAH0ZP7UyASw+7QD6PwYAAAAAgCkAAACmAK8AAsADwAAASMVIxUjFSMRMzUhASM1MwKYZGRkZGQBLP5wZGQB9GRkZAEsyP1EZAAEAKQBLAKYArwABQAJAA8AEwAAASM1IzUzAyM1MysBNSM1MwMjNTMCmGRkyGRkZMhkZMhkZGQBkGTI/nBkZMj+cGQAAAIApABkApgCWAAbAB8AACUjFSM1IxUjNSM1MzUjNTM1MxUzNTMVMxUjFTMjNSMVAphkZGRkZGRkZGRkZGRkZMhkyGRkZGRkZGRkZGRkZGRkZAAAAAEAQAAAAvwCvAAbAAAlIxUjFSM1IzUh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NTsBIzU7ASM1MwEjNTMB0GT+1GRkZGQBLGRkZGRkyMjIZGTIyMjIZGRkZGTIZGRkZGRkZGT9qGRkASxkZGRkZGRkZGRkZAH0ZGRk/ahkyGRkZGRkZP1EZAAIAED/nAL8AyAAGwAnAC8AMwA3ADsAPwBDAAABMxUzFTMVIzUjNSM1IzUhNTM1IzUzNTMRMxU7AhUzFSM1IzUjNTMRIzUzFTMVIwMjNTMlIzU7ASM1MwEjNTMHIzUzAdBkZGRkZGRk/tRkZGRkZGRkZGRkZGRkZGRkZMhkZAEsZGRkZGT+DGRkZGRkASxkZGRkZGRkZGRkZP7UZGRkZGRk/gxkZGQBLGTIZGT9qGTIZAAAAAAIAED/nAL8ArwAGwAjAC8ANwA7AD8AQwBHAAATIRUjFTMVMxUzFTMVMxUjNSM1IzUjNSM1IzUjASM1IzUzFTMhIzUjNTMVMxUzFSMHIzUzFTMVIxMjNTMBIzUzASM1MwEjNTNAASxkZGRkZGRkZGRkZGRkASxkyMhkASxkZGRkZGRkZGRkZGRkZP4MZGQCWGRk/gxkZAK8ZGRkZGRkZGRkZGRkZP5wZGRkZGRkZGTIZGRkAlhk/ahkAfRk/ahkAAAIAED/nAL8ArwAGQAhAC0ANQA5AD0AQQBFAAAlIzUjNSM1IzUjNSEVIxUzFTMVMxUzFTMVIyUjNSM1MxUzISM1IzUzFTMVMxUjByM1MxUzFSMTIzUzASM1MwEjNTMBIzUzAphkZGRkyAEsZGRkZGRkZP7UZMjIZAEsZGRkZGRkZGRkZGRkZGT+DGRkAlhkZP4MZGRkZGRkZMhkZGRkZGRkyGRkZGRkZGRkyGRkZAJYZP2oZAH0ZP2oZAAAAAsAQP+cAvwCvAAFABUAIQApAC0AMQA1ADkAPQBBAEUAABMhFSM1IwEjNSM1IzUzFTMVMxUzFSMRIzUjNTMVMxUzFSMHIzUzFTMVIwMjNTMlIzUzBTMVKwEzFSMBIzUzASM1OwEjNTNAASxkyAJYZGRkZGRkZGRkZGRkZGRkZGRkZMhkZAEsZGT+DGRkZGRkArxkZP2oZGRkZGQCvMhk/gxkZGRkZGRkASxkZGRkZMhkZGQBLGTIZGRkZAEsZP1EZGQAAAABAEAAAAL8ArwAEwAAISM1IzUjNSM1MzUzNTM1MxUhESEB0GRkZGRkZGRkASz+1GRkZGRkZGTI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FwwXGBcqF0oXaBeMF54XxBfuGA4YMhg+GFgYeBiEGLAY0hj2GRAZHBkoGTQZTBlqGYoZwBnoGgYaEhoqGkoaYhp6GpIarhrKGuobBhswG1YbfBuYG8gb6hwSHCQcPBxcHJIcwBzqHSAdUh18HZgdsh3UHgQeMB5GHmgelh6yHs4e7h8GHy4fWh9mH5Qfth/UH/QgFCA8IEggVCBgIGwgeCCcIKggtCDAIMwg2CDkIPghBCEgIVIhfiGmIcQh3CH4IhYiPiJKIlYifCKqIrYiwiLOIuoi9iMCIw4jGiMmI1AjXCNuI3ojhiOSI7gj4iPuJB4kMCRCJFQkZiR2JIgkmiSsJL4kziTqJRAlHCUuJUAlUiVkJXAllCWuJdAl+iYMJh4mMCZCJk4mWiZmJpImnibAJtom5ibyJv4nCicWJzQnQCdMJ0wnWidoJ34nlCeoJ8on7CgOKCIoQChOKGYonCiuKMgo5CkCKTApOilEKU4pWCliKWwpdimUKaopzCnsKgoqKCpKKmYqkiq0KvwrHitIK3ArnCu+K+IsFCxALFosgiymLMYs7C0WLTotWi2ILaYtyi4YLmouxC8kL4Iv5DACMCAwPjBcMIIwljDAMM4w9DEeMTQxZjGSMbwx5jH0MhgyPjJoMn4yojLQMx4zVjOAM6gzyjP0NBY0OjRkNHo0ljS8NOQ1ADUiNUw1hjW4Nfw2LjZgNqg2vDbKNtY24jbuNvo3BjcSNx43TDdYN2Q3cDeQN643ujfGN9I3/DgkOE44WjhmOJQ4oDisOLg4xDjQONw46Dj0OSQ5MDk8OWY5lDmUOZQAAAAAAAEAAAJmAAEAZAGAAAYA2AAIAA//wAAIADb/nAAIADj/nAAIADv/nAAJABP/nAAJABX/nAAJACP/6AAJACz/agAOABn/zgAOADb/agAOADv/zgAPABP/zgAPABX/zgAPABn/zgAPACv/nAAPACz/agAPADb/nAAPADr/zgAPADz/zgAQABn/agAQABv/zgAQACX/zgAQADX/7gAQADb/agAQADj/nAAQADv/nAARAAj/wAARABH/BgARACP/zgARACz/BgARADX/9gATAAn/nAATAA//nAATABb/zgATABn/wAATACX/zgAWABn/zgAXABn/zgAYABn/zgAZAA7/zgAZAA//zgAZABD/agAZABX/wAAZABb/zgAa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AOIBIQEiASMBJAElASYBJwCwASgBKQEqASsBLAD7AOQBLQEuAS8BMAExATIBMwE0ATUBNgE3ATgBOQDmAToBOwE8AT0BPgCmAT8BQAFBAUIBQwFEAUUBRgFHAUgA2ADhANsA3ADdAOAA2QDfAUkBSgFLAUwBTQFOAU8BUAFRAVIBUwFUAVUBVgFXAVgBWQFaAVsBXAFdAV4BXwFgAWEBYgFjAWQBZQFmAWcBaAFpAWoBawFsAW0BbgCfAW8AmwFwAXEBcgFzAXQBdQF2AXcBeAF5AXoBewF8AX0BfgF/AYABgQGCAYMBhAGFAYYBhwGIAYkBigGLAYwBjQGOAY8BkAGRAZIBkwGUAZUBlgGXAZgBmQGaAZsBnAGdAZ4BnwGgAaEBogGjAaQBpQGmAacBqAGpAaoBqwGsAa0BrgGvAbABsQGyAbMBtAG1AbYBtwG4AbkBugG7AbwBvQG+Ab8BwAHBAcIBwwHEAcUBxgHHAcgByQHKAcsBzAHNAc4BzwHQAdEB0gHTAdQB1QHWAdcB2AHZAdoB2wHcAd0B3gHfAeAB4QHiAeMB5AHlAeYB5wHoAekB6gHrAewB7QHuAe8B8AHxAfIB8wH0AfUB9gH3AfgB+QH6AfsB/AH9Af4B/wIAAgECAgIDAgQCBQCyALMAtgC3AMQAtAC1AMUAggDCAIcAqwDGAgYCBwC+AL8AvAIIAgkCCgILAgwCDQIOAg8CEAIRAhICEwIUAhUCFgIXAhgCGQIaAhsCHAIdAh4CHwIgAiECIgIjAiQCJQImAicCKAIpAioAjAIrAiwCLQIuAi8CMAIxAjICMwI0AjUAmACaAJkA7wClAJIAnACnAI8AlACVAjYAuQI3AjgCOQI6AjsCPAI9Aj4CPwJAAkECQgJDAkQCRQJGAkcCSAJJAkoCSwJMAk0CTgJPAlACUQJSAlMCVAJVAlYCVwJYAlkCWgJbAlwCXQJeAl8CYAJhAmICYwJkAmUCZgJnAmgCaQJqAmsCbAJtAm4CbwJwAnECcgJzAnQCdQJ2AAICdwd1bmkwMDE3Bm1hY3Jvbgd1bmkwMEI1DnBlcmlvZGNlbnRlcmVkB0FtYWNyb24GQWJyZXZlB0FvZ29uZWsHdW5pMDEwOApDZG90YWNjZW50BkRjYXJvbgdFbWFjcm9uBkVicmV2ZQpFZG90YWNjZW50B0VvZ29uZWsGRWNhcm9uB3VuaTAxMUMKR2RvdGFjY2VudAxHY29tbWFhY2NlbnQHdW5pMDEyNARIYmFyBkl0aWxkZQdJbWFjcm9uBklicmV2ZQdJb2dvbmVrCklkb3RhY2NlbnQCSUoHdW5pMDEzNAxLY29tbWFhY2NlbnQGTGFjdXRlDExjb21tYWFjY2VudAZMY2Fyb24GTmFjdXRlDE5jb21tYWFjY2VudAZOY2Fyb24DRW5nB09tYWNyb24GT2JyZXZlDU9odW5nYXJ1bWxhdXQGUmFjdXRlDFJjb21tYWFjY2VudAZSY2Fyb24GU2FjdXRlC1NjaXJjdW1mbGV4DFRjb21tYWFjY2VudAZUY2Fyb24EVGJhcgZVdGlsZGUHVW1hY3JvbgZVYnJldmUFVXJpbmcNVWh1bmdhcnVtbGF1dAdVb2dvbmVrC1djaXJjdW1mbGV4C1ljaXJjdW1mbGV4BlphY3V0ZQpaZG90YWNjZW50B3VuaTAxODEHdW5pMDE4Nwd1bmkwMThBB3VuaTAxOEUHdW5pMDE4Rgd1bmkwMTk0B3VuaTAxOTgHdW5pMDE5RAd1bmkwMUEwB3VuaTAxQUYHdW5pMDFCMwd1bmkwMUY0B3VuaTAxRjgHdW5pMDI0MQd1bmkwMjRDCWdyYXZlY29tYglhY3V0ZWNvbWIHdW5pMDMwMgl0aWxkZWNvbWIHdW5pMDMwNAd1bmkwMzA2B3VuaTAzMDcHdW5pMDMwOA1ob29rYWJvdmVjb21iB3VuaTAzMEEHdW5pMDMwQgd1bmkwMzBDB3VuaTAzMTMHdW5pMDMxQgxkb3RiZWxvd2NvbWIHdW5pMDMyNgd1bmkwMzI4B3VuaTAzMkQHdW5pMDM3NQV0b25vcw1kaWVyZXNpc3Rvbm9zCkFscGhhdG9ub3MJYW5vdGVsZWlhDEVwc2lsb250b25vcwhFdGF0b25vcwlJb3RhdG9ub3MMT21pY3JvbnRvbm9zDFVwc2lsb250b25vcwpPbWVnYXRvbm9zEWlvdGFkaWVyZXNpc3Rvbm9zB3VuaTA0MTMFRGVsdGEGTGFtYmRhAlhpB3VuaTA0MUYFU2lnbWEHdW5pMDQyNANQc2kUdXBzaWxvbmRpZXJlc2lzdG9ub3MHdW5pMDQwMgd1bmkwNDAzB3VuaTA0MDQHdW5pMDQwOQd1bmkwNDBBB3VuaTA0MEIHdW5pMDQwQwd1bmkwNDBEB3VuaTA0MEUHdW5pMDQwRgd1bmkwNDExB3VuaTA0MTQHdW5pMDQxNgd1bmkwNDE3B3VuaTA0MTgHdW5pMDQxOQd1bmkwNDFCB3VuaTA0MjMHdW5pMDQyNgd1bmkwNDI3B3VuaTA0MjgHdW5pMDQyOQd1bmkwNDJBB3VuaTA0MkIHdW5pMDQyQwd1bmkwNDJEB3VuaTA0MkUHdW5pMDQyRgd1bmkwNDc0B3VuaTA0OEEHdW5pMDQ4Qwd1bmkwNDhFB3VuaTA0OTAHdW5pMDQ5Mgd1bmkwNDk0B3VuaTA0OTYHdW5pMDQ5OAd1bmkwNDlBB3VuaTA0OUMHdW5pMDQ5RQd1bmkwNEEwB3VuaTA0QTIHdW5pMDRBNAd1bmkwNEE2B3VuaTA0QTgHdW5pMDRBQQd1bmkwNEFDB3VuaTA0QjAHdW5pMDRCMgd1bmkwNEI0B3VuaTA0QjYHdW5pMDRCOAd1bmkwNEJBB3VuaTA0QkMHdW5pMDRCRQd1bmkwNEMxB3VuaTA0QzMHdW5pMDRDNQd1bmkwNEM3B3VuaTA0QzkHdW5pMDRDQgd1bmkwNENEB3VuaTA0REEHdW5pMDREQwd1bmkwNERFB3VuaTA0RTIHdW5pMDRFNAd1bmkwNEU4B3VuaTA0RUEHdW5pMDRFQwd1bmkwNEVFB3VuaTA0RjAHdW5pMDRGMgd1bmkwNEY0B3VuaTA0RjYHdW5pMDRGOAd1bmkwNEZBB3VuaTA0RkMHdW5pMDRGRQd1bmkwNTEwB3VuaTA1MTIHdW5pMDUyNAd1bmkwNTI2B3VuaTA1MkUHdW5pMDU4Rgd1bmkxRTAyB3VuaTFFMEEHdW5pMUUwQwd1bmkxRTEyB3VuaTFFMUUHdW5pMUUyMgd1bmkxRTI0B3VuaTFFM0MHdW5pMUU0NAd1bmkxRTRBB3VuaTFFNTYHdW5pMUU1QQd1bmkxRTYwB3VuaTFFNjIHdW5pMUU2QQd1bmkxRTZDBldncmF2ZQZXYWN1dGUJV2RpZXJlc2lzB3VuaTFFOTIHdW5pMUU5RQd1bmkxRUEwB3VuaTFFQTIHdW5pMUVBNAd1bmkxRUE2B3VuaTFFQTgHdW5pMUVBQQd1bmkxRUFDB3VuaTFFQUUHdW5pMUVCMAd1bmkxRUIyB3VuaTFFQjQHdW5pMUVCNgd1bmkxRUI4B3VuaTFFQkEHdW5pMUVCQwd1bmkxRUJFB3VuaTFFQzAHdW5pMUVDMgd1bmkxRUM0B3VuaTFFQzYHdW5pMUVDOAd1bmkxRUNBB3VuaTFFQ0MHdW5pMUVDRQd1bmkxRUQwB3VuaTFFRDIHdW5pMUVENAd1bmkxRUQ2B3VuaTFFRDgHdW5pMUVEQQd1bmkxRURDB3VuaTFFREUHdW5pMUVFMAd1bmkxRUUyB3VuaTFFRTQHdW5pMUVFNgd1bmkxRUU4B3VuaTFFRUEHdW5pMUVFQwd1bmkxRUVFB3VuaTFFRjAGWWdyYXZlB3VuaTFFRjYJemVyb3NwYWNlB3VuaTIwMzIHdW5pMjAzMwx6ZXJvc3VwZXJpb3IMZm91cnN1cGVyaW9yDGZpdmVzdXBlcmlvcgtzaXhzdXBlcmlvcg1zZXZlbnN1cGVyaW9yDWVpZ2h0c3VwZXJpb3IMbmluZXN1cGVyaW9yDHplcm9pbmZlcmlvcgtvbmVpbmZlcmlvcgt0d29pbmZlcmlvcg10aHJlZWluZmVyaW9yDGZvdXJpbmZlcmlvcgxmaXZlaW5mZXJpb3ILc2l4aW5mZXJpb3INc2V2ZW5pbmZlcmlvcg1laWdodGluZmVyaW9yDG5pbmVpbmZlcmlvcgd1bmkyMEE5B3VuaTIwQUEEZG9uZwRFdXJvB3VuaTIwQUQHdW5pMjBBRQd1bmkyMEIxB3VuaTIwQjIHdW5pMjBCNAd1bmkyMEI4B3VuaTIwQjkHdW5pMjBCQQd1bmkyMEJDB3VuaTIwQkQHdW5pMjBCRQVsaXRyZQd1bmkyMTE2B3VuaTIxMTcHdW5pMjEyRQhvbmV0aGlyZAl0d290aGlyZHMJb25lZWlnaHRoDHRocmVlZWlnaHRocwtmaXZlZWlnaHRocwxzZXZlbmVpZ2h0aHMHdW5pMjE5MAd1bmkyMTkxB3VuaTIxOTIHdW5pMjE5MwVibG9jawd1bmkyNjA1B3VuaTI2MDYHdW5pMjYxMAd1bmkyNjExB3VuaTI2MTIHdW5pMjYzQQd1bmkyNjNCB3VuaTI2NDAHdW5pMjY0Mgd1bmkyNjYwB3VuaTI2NjMFaGVhcnQHdW5pMjY2Ngd1bmkyNjY3B3VuaTI2NjkHdW5pMjY2QQd1bmkyNjZCB3VuaTI2NkMHdW5pMjY2RAd1bmkyNjZFB3VuaTI2NkYHdW5pMjZBMgd1bmkyNkEzB3VuaTI2QTQHdW5pMjZBNQd1bmkyNkE2B3VuaTI2QTcJb2xkLmVxdWFsA0kuMQd1bmlGNDNBB3VuaUY0NjIHdW5pRjQ2NAd1bmlGNDY1B3VuaUY0NjYHdW5pRjQ2Nwd1bmlGNDY4B3VuaUY0NjkHdW5pRjQ5OAd1bmlGNDlBB3VuaUY0OUMHdW5pRjQ5RQd1bmlGNEM2B3VuaUY0RDQHdW5pRjRENgd1bmlGNEQ4B3VuaUY1MEEHdW5pRjUxMgd1bmlGNTE0B3VuaUY1MTYHdW5pRjUxQwd1bmlGNTFFB3VuaUY1MjAHdW5pRjUyMgd1bmlGNTI0B3VuaUY1MjYHdW5pRjUyOAd1bmlGNTJBB3VuaUY1MkMHdW5pRjUyRQd1bmlGNTMyB3VuaUY1MzYHdW5pRjUzOAd1bmlGNTNFB3VuaUY4RkYFLm51bGwAAAAB//8AAgABAAAACgAwAEoAAkRGTFQADmxhdG4AGgAEAAAAAP//AAEAAAAEAAAAAP//AAEAAQACa2VybgAOa2VybgAUAAAAAQAAAAAAAQAAAAEABAACAAAAAQAIAAECngAEAAAAIQBMAF4AdACCAKwA0gD0AQoBEAEWARwBMgE4AT4BUAFWAXABigGYAaoByAHeAfgCHgIsAjICSAJSAmQCagJwAnYCgAAEAA//wAA2/5wAOP+cADv/nAAFABP/nAAV/5wAI//oACz/agEU/2oAAwAZ/84ANv9qADv/zgAKABP/zgAV/84AGf/OACv/nAAs/2oANv+cADr/zgA8/84BFP9qARr/nAAJABn/agAb/84AJf/OADX/7gA2/2oAOP+cADv/nAEX/2oBGv9qAAgACP/AABH/BgAj/84ALP8GADX/9gEU/zgBGgA5AR//7gAFAAn/nAAP/5wAFv/OABn/wAAl/84AAQAZ/84AAQAZ/84AAQAZ/84ABQAO/84AD//OABD/agAV/8AAFv/OAAEAGf/OAAEAEP/OAAQACf/zACH/zgA2/84BF//nAAEBFP/OAAYAEP/OABH/pgAT/84AK//OADb/zgEU/84ABgAI/+cAEP9qABH/agAj/+cAJf/OACz/nAADAA//nAAl/84ALP/vAAQAD/+cACX/5wAs/84BGgAyAAcACf9qAA//agAh/2oAJf/OADb/nAA4/5wAO/+cAAUAEP+cABH/agAr//QALP+cART/nAAGAAn/5wAR//IAK//nADb/nAA4/+4AO//OAAkACP/OAA7/agAP/5wAEP9qABH/nAAj/84ALP9qART/agEaADIAAwAQ/5wAEf9qACz/nAABAA//zgAFAA7/zgAQ/5wAEf+cACz/agEU/2oAAgAP/+cALP/OAAQANv9qART/zgEX/84BGv+cAAEBFP/OAAEBFP/sAAEACf/OAAIAIf9qARf/nAAHAAn/zgAh/zgANv+cADv/zgEU/84BF//OARr/nAABACEACAAJAA4ADwAQABEAEwAWABcAGAAZABoAGwAjACUAJgAoACsALQAuADIANQA2ADgAOgA7ADwBDgERARUBFgEaARwAAAABAAAACgA4AIoAAkRGTFQADmxhdG4AHgAEAAAAAP//AAMAAAACAAQABAAAAAD//wADAAEAAwAFAAZmcmFjACZmcmFjADBzaW5mADpzaW5mAEBzdXBzAEZzdXBzAEwAAAADAAAAAQACAAAAAwAAAAEAAgAAAAEABAAAAAEABAAAAAEAAwAAAAEAAwAGAA4AFgAeACgAMAA4AAQAAAABADIAAQAAAAEAngAGAAAAAgCyAMQAAQAAAAEAzAABAAAAAQDeAAEAAAABANwAAQDuAAUAEAA6AEYAXABoAAQACgASABoAIgBjAAMAEQAUAdEAAwARABUAYgADABEAFgHTAAMAEQAaAAEABAHSAAMAEQAVAAIABgAOAGQAAwARABYB1AADABEAGgABAAQB1QADABEAGgABAAQB1gADABEAGgACAIgACwGrAawAXwBYAFkBrQGuAa8BsAGxAbIAAwABAHYAAQB8AAAAAQAAAAUAAwABAIAAAQBqAAAAAQAAAAUAAgB4AAoBrABfAFgAWQGtAa4BrwGwAbEBsgABAF4BoQACADgACgG1AbYBtAGzAbcBuAG5AboBuwG8AAEABQATABQAFQAXABkAAgABABEAGwAAAAEAAQGrAAIAAwBYAFkAAABfAF8AAgGsAbIAAwACAAEBswG8AAAAAgABABIAGwAA';
Module['FS_createDataFile']('/assets', 'joystix monospace.ttf', decodeBase64(fileData6), true, true, false);
var fileData7 = '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';
Module['FS_createDataFile']('/assets', 'pickup.wav', decodeBase64(fileData7), true, true, false);
var fileData8 = 'iVBORw0KGgoAAAANSUhEUgAAABIAAAASCAYAAABWzo5XAAAAAXNSR0IArs4c6QAAAK5JREFUOI3t1LENhDAMBVDbA1AgChZgM2agggoqZshmLEBxomCAcJWtEIzxSVfyy4AeP5EDgpK6anptnbN+lilfQwMYb5xBAwVKkBEAYC4LVem2/QQyhjnCQMCoQu1BKSgYpVuZywICxluEPxAwcmPZPj0drCd11fTcSNp4k7ci+3V/XsgPDd22y7B50h50GkrSLuCvySdbWlnN+HnaBuDfl1bBBFRi/0YM8BLtXL9Rd1ceQ6P/LwAAAABJRU5ErkJggg==';
Module['FS_createDataFile']('/assets', 'Turret.png', decodeBase64(fileData8), true, true, false);
var fileData9 = 'iVBORw0KGgoAAAANSUhEUgAAABQAAAAUCAYAAACNiR0NAAAAAXNSR0IArs4c6QAAAFpJREFUOI1jYBgFwx8wElIgIaL6H8Z+8eY2QfVMxBjWJcSHYTjJLkQ3jIGBgaHs3SdC5jGw4JPsEuJjcBIVRPAJGkfAy+QAqnsZb6whGwozjFBMUz3ZjIKRAADGuhyUo0DcXgAAAABJRU5ErkJggg==';
Module['FS_createDataFile']('/assets', 'TurretBarrel.png', decodeBase64(fileData9), true, true, false);
var fileData10 = 'iVBORw0KGgoAAAANSUhEUgAAABIAAAASCAYAAABWzo5XAAAAAXNSR0IArs4c6QAAANtJREFUOI3t1DESRDAYBeCXzF7AjMIBKLgCvVbnAA6hoaJxCAfYTqtfV6DgAAozrrCNZMT+iH5fl4z5Jn8mDwMRy3Qyal9kXsbyuMcugOLEySlQQjukAIA6SEgl+dQKKDB2RARQDW8S8gwfANBMrYLx/Sh1kKAa3qcIAPRrh37txInl+PzuYnVimU7GNqiI7BD92j0CPMOXI/K7j3Xzh/ShvJla+dh0krqx8ig5VcCnmZexfO3WeTO1txVJ3RiA7Jws8GlpIzskoW0ciSilJTAJErn+jVyAP6Hu9QsU1VpDeXhiDwAAAABJRU5ErkJggg==';
Module['FS_createDataFile']('/assets', 'TurretWormSpawn.png', decodeBase64(fileData10), true, true, false);
var fileData11 = 'iVBORw0KGgoAAAANSUhEUgAAABQAAAAUCAYAAACNiR0NAAAAAXNSR0IArs4c6QAAAGJJREFUOI1jYBgFwx8wElIgIaL6H8Z+8eY2QfVMxBgWoOKOYTjJLkQ3jIGBgWHDnZ2EzGNgwScZoOLO4CshgyTijlMtDOD1MjkArwshXiTNy3hjDTkcYYYRimmqJ5tRMBIAACEjHRCRulKnAAAAAElFTkSuQmCC';
Module['FS_createDataFile']('/assets', 'TurretWormSpawnBarrel.png', decodeBase64(fileData11), true, true, false);
var fileData12 = 'iVBORw0KGgoAAAANSUhEUgAAAAwAAAAMCAYAAABWdVznAAAAAXNSR0IArs4c6QAAAHVJREFUKJGNUsENACEIA8dwDtdyGtZiDtbwXpiWGM++BNqCqEqBmS2M55yKsVbiGIMM3J2EeiOfRC2TSY6ITcwzGqmZLST33skdc+4uDYtZiIjtXg1I8AISoCt2Q+wtne5R56ct5epwZiRTh+wi8vhwiL+v8QGoSU3KbuRMxwAAAABJRU5ErkJggg==';
Module['FS_createDataFile']('/assets', 'Worm.png', decodeBase64(fileData12), true, true, false);

    }
    if (Module['calledRun']) {
      runWithFS();
    } else {
      if (!Module['preRun']) Module['preRun'] = [];
      Module["preRun"].push(runWithFS); // FS is not initialized yet, wait for it
    }
  
   }
   loadPackage({"files": []});
  
  })();
  


// Sometimes an existing Module object exists with properties
// meant to overwrite the default module functionality. Here
// we collect those properties and reapply _after_ we configure
// the current environment's defaults to avoid having to be so
// defensive during initialization.
var moduleOverrides = {};
var key;
for (key in Module) {
  if (Module.hasOwnProperty(key)) {
    moduleOverrides[key] = Module[key];
  }
}

var arguments_ = [];
var thisProgram = './this.program';
var quit_ = function(status, toThrow) {
  throw toThrow;
};

// Determine the runtime environment we are in. You can customize this by
// setting the ENVIRONMENT setting at compile time (see settings.js).

// Attempt to auto-detect the environment
var ENVIRONMENT_IS_WEB = typeof window === 'object';
var ENVIRONMENT_IS_WORKER = typeof importScripts === 'function';
// N.b. Electron.js environment is simultaneously a NODE-environment, but
// also a web environment.
var ENVIRONMENT_IS_NODE = typeof process === 'object' && typeof process.versions === 'object' && typeof process.versions.node === 'string';
var ENVIRONMENT_IS_SHELL = !ENVIRONMENT_IS_WEB && !ENVIRONMENT_IS_NODE && !ENVIRONMENT_IS_WORKER;

// `/` should be present at the end if `scriptDirectory` is not empty
var scriptDirectory = '';
function locateFile(path) {
  if (Module['locateFile']) {
    return Module['locateFile'](path, scriptDirectory);
  }
  return scriptDirectory + path;
}

// Hooks that are implemented differently in different runtime environments.
var read_,
    readAsync,
    readBinary,
    setWindowTitle;

var nodeFS;
var nodePath;

if (ENVIRONMENT_IS_NODE) {
  if (ENVIRONMENT_IS_WORKER) {
    scriptDirectory = require('path').dirname(scriptDirectory) + '/';
  } else {
    scriptDirectory = __dirname + '/';
  }

// include: node_shell_read.js


read_ = function shell_read(filename, binary) {
  if (!nodeFS) nodeFS = require('fs');
  if (!nodePath) nodePath = require('path');
  filename = nodePath['normalize'](filename);
  return nodeFS['readFileSync'](filename, binary ? null : 'utf8');
};

readBinary = function readBinary(filename) {
  var ret = read_(filename, true);
  if (!ret.buffer) {
    ret = new Uint8Array(ret);
  }
  assert(ret.buffer);
  return ret;
};

readAsync = function readAsync(filename, onload, onerror) {
  if (!nodeFS) nodeFS = require('fs');
  if (!nodePath) nodePath = require('path');
  filename = nodePath['normalize'](filename);
  nodeFS['readFile'](filename, function(err, data) {
    if (err) onerror(err);
    else onload(data.buffer);
  });
};

// end include: node_shell_read.js
  if (process['argv'].length > 1) {
    thisProgram = process['argv'][1].replace(/\\/g, '/');
  }

  arguments_ = process['argv'].slice(2);

  if (typeof module !== 'undefined') {
    module['exports'] = Module;
  }

  process['on']('uncaughtException', function(ex) {
    // suppress ExitStatus exceptions from showing an error
    if (!(ex instanceof ExitStatus)) {
      throw ex;
    }
  });

  process['on']('unhandledRejection', abort);

  quit_ = function(status, toThrow) {
    if (keepRuntimeAlive()) {
      process['exitCode'] = status;
      throw toThrow;
    }
    process['exit'](status);
  };

  Module['inspect'] = function () { return '[Emscripten Module object]'; };

} else

// Note that this includes Node.js workers when relevant (pthreads is enabled).
// Node.js workers are detected as a combination of ENVIRONMENT_IS_WORKER and
// ENVIRONMENT_IS_NODE.
if (ENVIRONMENT_IS_WEB || ENVIRONMENT_IS_WORKER) {
  if (ENVIRONMENT_IS_WORKER) { // Check worker, not web, since window could be polyfilled
    scriptDirectory = self.location.href;
  } else if (typeof document !== 'undefined' && document.currentScript) { // web
    scriptDirectory = document.currentScript.src;
  }
  // blob urls look like blob:http://site.com/etc/etc and we cannot infer anything from them.
  // otherwise, slice off the final part of the url to find the script directory.
  // if scriptDirectory does not contain a slash, lastIndexOf will return -1,
  // and scriptDirectory will correctly be replaced with an empty string.
  if (scriptDirectory.indexOf('blob:') !== 0) {
    scriptDirectory = scriptDirectory.substr(0, scriptDirectory.lastIndexOf('/')+1);
  } else {
    scriptDirectory = '';
  }

  // Differentiate the Web Worker from the Node Worker case, as reading must
  // be done differently.
  {

// include: web_or_worker_shell_read.js


  read_ = function(url) {
      var xhr = new XMLHttpRequest();
      xhr.open('GET', url, false);
      xhr.send(null);
      return xhr.responseText;
  };

  if (ENVIRONMENT_IS_WORKER) {
    readBinary = function(url) {
        var xhr = new XMLHttpRequest();
        xhr.open('GET', url, false);
        xhr.responseType = 'arraybuffer';
        xhr.send(null);
        return new Uint8Array(/** @type{!ArrayBuffer} */(xhr.response));
    };
  }

  readAsync = function(url, onload, onerror) {
    var xhr = new XMLHttpRequest();
    xhr.open('GET', url, true);
    xhr.responseType = 'arraybuffer';
    xhr.onload = function() {
      if (xhr.status == 200 || (xhr.status == 0 && xhr.response)) { // file URLs can return 0
        onload(xhr.response);
        return;
      }
      onerror();
    };
    xhr.onerror = onerror;
    xhr.send(null);
  };

// end include: web_or_worker_shell_read.js
  }

  setWindowTitle = function(title) { document.title = title };
} else
{
}

// Set up the out() and err() hooks, which are how we can print to stdout or
// stderr, respectively.
var out = Module['print'] || console.log.bind(console);
var err = Module['printErr'] || console.warn.bind(console);

// Merge back in the overrides
for (key in moduleOverrides) {
  if (moduleOverrides.hasOwnProperty(key)) {
    Module[key] = moduleOverrides[key];
  }
}
// Free the object hierarchy contained in the overrides, this lets the GC
// reclaim data used e.g. in memoryInitializerRequest, which is a large typed array.
moduleOverrides = null;

// Emit code to handle expected values on the Module object. This applies Module.x
// to the proper local x. This has two benefits: first, we only emit it if it is
// expected to arrive, and second, by using a local everywhere else that can be
// minified.

if (Module['arguments']) arguments_ = Module['arguments'];

if (Module['thisProgram']) thisProgram = Module['thisProgram'];

if (Module['quit']) quit_ = Module['quit'];

// perform assertions in shell.js after we set up out() and err(), as otherwise if an assertion fails it cannot print the message




var STACK_ALIGN = 16;

function alignMemory(size, factor) {
  if (!factor) factor = STACK_ALIGN; // stack alignment (16-byte) by default
  return Math.ceil(size / factor) * factor;
}

function getNativeTypeSize(type) {
  switch (type) {
    case 'i1': case 'i8': return 1;
    case 'i16': return 2;
    case 'i32': return 4;
    case 'i64': return 8;
    case 'float': return 4;
    case 'double': return 8;
    default: {
      if (type[type.length-1] === '*') {
        return 4; // A pointer
      } else if (type[0] === 'i') {
        var bits = Number(type.substr(1));
        assert(bits % 8 === 0, 'getNativeTypeSize invalid bits ' + bits + ', type ' + type);
        return bits / 8;
      } else {
        return 0;
      }
    }
  }
}

function warnOnce(text) {
  if (!warnOnce.shown) warnOnce.shown = {};
  if (!warnOnce.shown[text]) {
    warnOnce.shown[text] = 1;
    err(text);
  }
}

// include: runtime_functions.js


// Wraps a JS function as a wasm function with a given signature.
function convertJsFunctionToWasm(func, sig) {

  // If the type reflection proposal is available, use the new
  // "WebAssembly.Function" constructor.
  // Otherwise, construct a minimal wasm module importing the JS function and
  // re-exporting it.
  if (typeof WebAssembly.Function === "function") {
    var typeNames = {
      'i': 'i32',
      'j': 'i64',
      'f': 'f32',
      'd': 'f64'
    };
    var type = {
      parameters: [],
      results: sig[0] == 'v' ? [] : [typeNames[sig[0]]]
    };
    for (var i = 1; i < sig.length; ++i) {
      type.parameters.push(typeNames[sig[i]]);
    }
    return new WebAssembly.Function(type, func);
  }

  // The module is static, with the exception of the type section, which is
  // generated based on the signature passed in.
  var typeSection = [
    0x01, // id: section,
    0x00, // length: 0 (placeholder)
    0x01, // count: 1
    0x60, // form: func
  ];
  var sigRet = sig.slice(0, 1);
  var sigParam = sig.slice(1);
  var typeCodes = {
    'i': 0x7f, // i32
    'j': 0x7e, // i64
    'f': 0x7d, // f32
    'd': 0x7c, // f64
  };

  // Parameters, length + signatures
  typeSection.push(sigParam.length);
  for (var i = 0; i < sigParam.length; ++i) {
    typeSection.push(typeCodes[sigParam[i]]);
  }

  // Return values, length + signatures
  // With no multi-return in MVP, either 0 (void) or 1 (anything else)
  if (sigRet == 'v') {
    typeSection.push(0x00);
  } else {
    typeSection = typeSection.concat([0x01, typeCodes[sigRet]]);
  }

  // Write the overall length of the type section back into the section header
  // (excepting the 2 bytes for the section id and length)
  typeSection[1] = typeSection.length - 2;

  // Rest of the module is static
  var bytes = new Uint8Array([
    0x00, 0x61, 0x73, 0x6d, // magic ("\0asm")
    0x01, 0x00, 0x00, 0x00, // version: 1
  ].concat(typeSection, [
    0x02, 0x07, // import section
      // (import "e" "f" (func 0 (type 0)))
      0x01, 0x01, 0x65, 0x01, 0x66, 0x00, 0x00,
    0x07, 0x05, // export section
      // (export "f" (func 0 (type 0)))
      0x01, 0x01, 0x66, 0x00, 0x00,
  ]));

   // We can compile this wasm module synchronously because it is very small.
  // This accepts an import (at "e.f"), that it reroutes to an export (at "f")
  var module = new WebAssembly.Module(bytes);
  var instance = new WebAssembly.Instance(module, {
    'e': {
      'f': func
    }
  });
  var wrappedFunc = instance.exports['f'];
  return wrappedFunc;
}

var freeTableIndexes = [];

// Weak map of functions in the table to their indexes, created on first use.
var functionsInTableMap;

function getEmptyTableSlot() {
  // Reuse a free index if there is one, otherwise grow.
  if (freeTableIndexes.length) {
    return freeTableIndexes.pop();
  }
  // Grow the table
  try {
    wasmTable.grow(1);
  } catch (err) {
    if (!(err instanceof RangeError)) {
      throw err;
    }
    throw 'Unable to grow wasm table. Set ALLOW_TABLE_GROWTH.';
  }
  return wasmTable.length - 1;
}

// Add a wasm function to the table.
function addFunctionWasm(func, sig) {
  // Check if the function is already in the table, to ensure each function
  // gets a unique index. First, create the map if this is the first use.
  if (!functionsInTableMap) {
    functionsInTableMap = new WeakMap();
    for (var i = 0; i < wasmTable.length; i++) {
      var item = wasmTable.get(i);
      // Ignore null values.
      if (item) {
        functionsInTableMap.set(item, i);
      }
    }
  }
  if (functionsInTableMap.has(func)) {
    return functionsInTableMap.get(func);
  }

  // It's not in the table, add it now.

  var ret = getEmptyTableSlot();

  // Set the new value.
  try {
    // Attempting to call this with JS function will cause of table.set() to fail
    wasmTable.set(ret, func);
  } catch (err) {
    if (!(err instanceof TypeError)) {
      throw err;
    }
    var wrapped = convertJsFunctionToWasm(func, sig);
    wasmTable.set(ret, wrapped);
  }

  functionsInTableMap.set(func, ret);

  return ret;
}

function removeFunction(index) {
  functionsInTableMap.delete(wasmTable.get(index));
  freeTableIndexes.push(index);
}

// 'sig' parameter is required for the llvm backend but only when func is not
// already a WebAssembly function.
function addFunction(func, sig) {

  return addFunctionWasm(func, sig);
}

// end include: runtime_functions.js
// include: runtime_debug.js


// end include: runtime_debug.js
var tempRet0 = 0;

var setTempRet0 = function(value) {
  tempRet0 = value;
};

var getTempRet0 = function() {
  return tempRet0;
};



// === Preamble library stuff ===

// Documentation for the public APIs defined in this file must be updated in:
//    site/source/docs/api_reference/preamble.js.rst
// A prebuilt local version of the documentation is available at:
//    site/build/text/docs/api_reference/preamble.js.txt
// You can also build docs locally as HTML or other formats in site/
// An online HTML version (which may be of a different version of Emscripten)
//    is up at http://kripken.github.io/emscripten-site/docs/api_reference/preamble.js.html

var wasmBinary;
if (Module['wasmBinary']) wasmBinary = Module['wasmBinary'];
var noExitRuntime = Module['noExitRuntime'] || true;

if (typeof WebAssembly !== 'object') {
  abort('no native wasm support detected');
}

// include: runtime_safe_heap.js


// In MINIMAL_RUNTIME, setValue() and getValue() are only available when building with safe heap enabled, for heap safety checking.
// In traditional runtime, setValue() and getValue() are always available (although their use is highly discouraged due to perf penalties)

/** @param {number} ptr
    @param {number} value
    @param {string} type
    @param {number|boolean=} noSafe */
function setValue(ptr, value, type, noSafe) {
  type = type || 'i8';
  if (type.charAt(type.length-1) === '*') type = 'i32'; // pointers are 32-bit
    switch (type) {
      case 'i1': HEAP8[((ptr)>>0)] = value; break;
      case 'i8': HEAP8[((ptr)>>0)] = value; break;
      case 'i16': HEAP16[((ptr)>>1)] = value; break;
      case 'i32': HEAP32[((ptr)>>2)] = value; break;
      case 'i64': (tempI64 = [value>>>0,(tempDouble=value,(+(Math.abs(tempDouble))) >= 1.0 ? (tempDouble > 0.0 ? ((Math.min((+(Math.floor((tempDouble)/4294967296.0))), 4294967295.0))|0)>>>0 : (~~((+(Math.ceil((tempDouble - +(((~~(tempDouble)))>>>0))/4294967296.0)))))>>>0) : 0)],HEAP32[((ptr)>>2)] = tempI64[0],HEAP32[(((ptr)+(4))>>2)] = tempI64[1]); break;
      case 'float': HEAPF32[((ptr)>>2)] = value; break;
      case 'double': HEAPF64[((ptr)>>3)] = value; break;
      default: abort('invalid type for setValue: ' + type);
    }
}

/** @param {number} ptr
    @param {string} type
    @param {number|boolean=} noSafe */
function getValue(ptr, type, noSafe) {
  type = type || 'i8';
  if (type.charAt(type.length-1) === '*') type = 'i32'; // pointers are 32-bit
    switch (type) {
      case 'i1': return HEAP8[((ptr)>>0)];
      case 'i8': return HEAP8[((ptr)>>0)];
      case 'i16': return HEAP16[((ptr)>>1)];
      case 'i32': return HEAP32[((ptr)>>2)];
      case 'i64': return HEAP32[((ptr)>>2)];
      case 'float': return HEAPF32[((ptr)>>2)];
      case 'double': return HEAPF64[((ptr)>>3)];
      default: abort('invalid type for getValue: ' + type);
    }
  return null;
}

// end include: runtime_safe_heap.js
// Wasm globals

var wasmMemory;

//========================================
// Runtime essentials
//========================================

// whether we are quitting the application. no code should run after this.
// set in exit() and abort()
var ABORT = false;

// set by exit() and abort().  Passed to 'onExit' handler.
// NOTE: This is also used as the process return code code in shell environments
// but only when noExitRuntime is false.
var EXITSTATUS;

/** @type {function(*, string=)} */
function assert(condition, text) {
  if (!condition) {
    abort('Assertion failed: ' + text);
  }
}

// Returns the C function with a specified identifier (for C++, you need to do manual name mangling)
function getCFunc(ident) {
  var func = Module['_' + ident]; // closure exported function
  assert(func, 'Cannot call unknown function ' + ident + ', make sure it is exported');
  return func;
}

// C calling interface.
/** @param {string|null=} returnType
    @param {Array=} argTypes
    @param {Arguments|Array=} args
    @param {Object=} opts */
function ccall(ident, returnType, argTypes, args, opts) {
  // For fast lookup of conversion functions
  var toC = {
    'string': function(str) {
      var ret = 0;
      if (str !== null && str !== undefined && str !== 0) { // null string
        // at most 4 bytes per UTF-8 code point, +1 for the trailing '\0'
        var len = (str.length << 2) + 1;
        ret = stackAlloc(len);
        stringToUTF8(str, ret, len);
      }
      return ret;
    },
    'array': function(arr) {
      var ret = stackAlloc(arr.length);
      writeArrayToMemory(arr, ret);
      return ret;
    }
  };

  function convertReturnValue(ret) {
    if (returnType === 'string') return UTF8ToString(ret);
    if (returnType === 'boolean') return Boolean(ret);
    return ret;
  }

  var func = getCFunc(ident);
  var cArgs = [];
  var stack = 0;
  if (args) {
    for (var i = 0; i < args.length; i++) {
      var converter = toC[argTypes[i]];
      if (converter) {
        if (stack === 0) stack = stackSave();
        cArgs[i] = converter(args[i]);
      } else {
        cArgs[i] = args[i];
      }
    }
  }
  var ret = func.apply(null, cArgs);
  var asyncMode = opts && opts.async;
  var runningAsync = typeof Asyncify === 'object' && Asyncify.currData;
  var prevRunningAsync = typeof Asyncify === 'object' && Asyncify.asyncFinalizers.length > 0;
  // Check if we started an async operation just now.
  if (runningAsync && !prevRunningAsync) {
    // If so, the WASM function ran asynchronous and unwound its stack.
    // We need to return a Promise that resolves the return value
    // once the stack is rewound and execution finishes.
    return new Promise(function(resolve) {
      Asyncify.asyncFinalizers.push(function(ret) {
        if (stack !== 0) stackRestore(stack);
        resolve(convertReturnValue(ret));
      });
    });
  }

  ret = convertReturnValue(ret);
  if (stack !== 0) stackRestore(stack);
  // If this is an async ccall, ensure we return a promise
  if (opts && opts.async) return Promise.resolve(ret);
  return ret;
}

/** @param {string=} returnType
    @param {Array=} argTypes
    @param {Object=} opts */
function cwrap(ident, returnType, argTypes, opts) {
  argTypes = argTypes || [];
  // When the function takes numbers and returns a number, we can just return
  // the original function
  var numericArgs = argTypes.every(function(type){ return type === 'number'});
  var numericRet = returnType !== 'string';
  if (numericRet && numericArgs && !opts) {
    return getCFunc(ident);
  }
  return function() {
    return ccall(ident, returnType, argTypes, arguments, opts);
  }
}

var ALLOC_NORMAL = 0; // Tries to use _malloc()
var ALLOC_STACK = 1; // Lives for the duration of the current function call

// allocate(): This is for internal use. You can use it yourself as well, but the interface
//             is a little tricky (see docs right below). The reason is that it is optimized
//             for multiple syntaxes to save space in generated code. So you should
//             normally not use allocate(), and instead allocate memory using _malloc(),
//             initialize it with setValue(), and so forth.
// @slab: An array of data.
// @allocator: How to allocate memory, see ALLOC_*
/** @type {function((Uint8Array|Array<number>), number)} */
function allocate(slab, allocator) {
  var ret;

  if (allocator == ALLOC_STACK) {
    ret = stackAlloc(slab.length);
  } else {
    ret = _malloc(slab.length);
  }

  if (slab.subarray || slab.slice) {
    HEAPU8.set(/** @type {!Uint8Array} */(slab), ret);
  } else {
    HEAPU8.set(new Uint8Array(slab), ret);
  }
  return ret;
}

// include: runtime_strings.js


// runtime_strings.js: Strings related runtime functions that are part of both MINIMAL_RUNTIME and regular runtime.

// Given a pointer 'ptr' to a null-terminated UTF8-encoded string in the given array that contains uint8 values, returns
// a copy of that string as a Javascript String object.

var UTF8Decoder = typeof TextDecoder !== 'undefined' ? new TextDecoder('utf8') : undefined;

/**
 * @param {number} idx
 * @param {number=} maxBytesToRead
 * @return {string}
 */
function UTF8ArrayToString(heap, idx, maxBytesToRead) {
  var endIdx = idx + maxBytesToRead;
  var endPtr = idx;
  // TextDecoder needs to know the byte length in advance, it doesn't stop on null terminator by itself.
  // Also, use the length info to avoid running tiny strings through TextDecoder, since .subarray() allocates garbage.
  // (As a tiny code save trick, compare endPtr against endIdx using a negation, so that undefined means Infinity)
  while (heap[endPtr] && !(endPtr >= endIdx)) ++endPtr;

  if (endPtr - idx > 16 && heap.subarray && UTF8Decoder) {
    return UTF8Decoder.decode(heap.subarray(idx, endPtr));
  } else {
    var str = '';
    // If building with TextDecoder, we have already computed the string length above, so test loop end condition against that
    while (idx < endPtr) {
      // For UTF8 byte structure, see:
      // http://en.wikipedia.org/wiki/UTF-8#Description
      // https://www.ietf.org/rfc/rfc2279.txt
      // https://tools.ietf.org/html/rfc3629
      var u0 = heap[idx++];
      if (!(u0 & 0x80)) { str += String.fromCharCode(u0); continue; }
      var u1 = heap[idx++] & 63;
      if ((u0 & 0xE0) == 0xC0) { str += String.fromCharCode(((u0 & 31) << 6) | u1); continue; }
      var u2 = heap[idx++] & 63;
      if ((u0 & 0xF0) == 0xE0) {
        u0 = ((u0 & 15) << 12) | (u1 << 6) | u2;
      } else {
        u0 = ((u0 & 7) << 18) | (u1 << 12) | (u2 << 6) | (heap[idx++] & 63);
      }

      if (u0 < 0x10000) {
        str += String.fromCharCode(u0);
      } else {
        var ch = u0 - 0x10000;
        str += String.fromCharCode(0xD800 | (ch >> 10), 0xDC00 | (ch & 0x3FF));
      }
    }
  }
  return str;
}

// Given a pointer 'ptr' to a null-terminated UTF8-encoded string in the emscripten HEAP, returns a
// copy of that string as a Javascript String object.
// maxBytesToRead: an optional length that specifies the maximum number of bytes to read. You can omit
//                 this parameter to scan the string until the first \0 byte. If maxBytesToRead is
//                 passed, and the string at [ptr, ptr+maxBytesToReadr[ contains a null byte in the
//                 middle, then the string will cut short at that byte index (i.e. maxBytesToRead will
//                 not produce a string of exact length [ptr, ptr+maxBytesToRead[)
//                 N.B. mixing frequent uses of UTF8ToString() with and without maxBytesToRead may
//                 throw JS JIT optimizations off, so it is worth to consider consistently using one
//                 style or the other.
/**
 * @param {number} ptr
 * @param {number=} maxBytesToRead
 * @return {string}
 */
function UTF8ToString(ptr, maxBytesToRead) {
  return ptr ? UTF8ArrayToString(HEAPU8, ptr, maxBytesToRead) : '';
}

// Copies the given Javascript String object 'str' to the given byte array at address 'outIdx',
// encoded in UTF8 form and null-terminated. The copy will require at most str.length*4+1 bytes of space in the HEAP.
// Use the function lengthBytesUTF8 to compute the exact number of bytes (excluding null terminator) that this function will write.
// Parameters:
//   str: the Javascript string to copy.
//   heap: the array to copy to. Each index in this array is assumed to be one 8-byte element.
//   outIdx: The starting offset in the array to begin the copying.
//   maxBytesToWrite: The maximum number of bytes this function can write to the array.
//                    This count should include the null terminator,
//                    i.e. if maxBytesToWrite=1, only the null terminator will be written and nothing else.
//                    maxBytesToWrite=0 does not write any bytes to the output, not even the null terminator.
// Returns the number of bytes written, EXCLUDING the null terminator.

function stringToUTF8Array(str, heap, outIdx, maxBytesToWrite) {
  if (!(maxBytesToWrite > 0)) // Parameter maxBytesToWrite is not optional. Negative values, 0, null, undefined and false each don't write out any bytes.
    return 0;

  var startIdx = outIdx;
  var endIdx = outIdx + maxBytesToWrite - 1; // -1 for string null terminator.
  for (var i = 0; i < str.length; ++i) {
    // Gotcha: charCodeAt returns a 16-bit word that is a UTF-16 encoded code unit, not a Unicode code point of the character! So decode UTF16->UTF32->UTF8.
    // See http://unicode.org/faq/utf_bom.html#utf16-3
    // For UTF8 byte structure, see http://en.wikipedia.org/wiki/UTF-8#Description and https://www.ietf.org/rfc/rfc2279.txt and https://tools.ietf.org/html/rfc3629
    var u = str.charCodeAt(i); // possibly a lead surrogate
    if (u >= 0xD800 && u <= 0xDFFF) {
      var u1 = str.charCodeAt(++i);
      u = 0x10000 + ((u & 0x3FF) << 10) | (u1 & 0x3FF);
    }
    if (u <= 0x7F) {
      if (outIdx >= endIdx) break;
      heap[outIdx++] = u;
    } else if (u <= 0x7FF) {
      if (outIdx + 1 >= endIdx) break;
      heap[outIdx++] = 0xC0 | (u >> 6);
      heap[outIdx++] = 0x80 | (u & 63);
    } else if (u <= 0xFFFF) {
      if (outIdx + 2 >= endIdx) break;
      heap[outIdx++] = 0xE0 | (u >> 12);
      heap[outIdx++] = 0x80 | ((u >> 6) & 63);
      heap[outIdx++] = 0x80 | (u & 63);
    } else {
      if (outIdx + 3 >= endIdx) break;
      heap[outIdx++] = 0xF0 | (u >> 18);
      heap[outIdx++] = 0x80 | ((u >> 12) & 63);
      heap[outIdx++] = 0x80 | ((u >> 6) & 63);
      heap[outIdx++] = 0x80 | (u & 63);
    }
  }
  // Null-terminate the pointer to the buffer.
  heap[outIdx] = 0;
  return outIdx - startIdx;
}

// Copies the given Javascript String object 'str' to the emscripten HEAP at address 'outPtr',
// null-terminated and encoded in UTF8 form. The copy will require at most str.length*4+1 bytes of space in the HEAP.
// Use the function lengthBytesUTF8 to compute the exact number of bytes (excluding null terminator) that this function will write.
// Returns the number of bytes written, EXCLUDING the null terminator.

function stringToUTF8(str, outPtr, maxBytesToWrite) {
  return stringToUTF8Array(str, HEAPU8,outPtr, maxBytesToWrite);
}

// Returns the number of bytes the given Javascript string takes if encoded as a UTF8 byte array, EXCLUDING the null terminator byte.
function lengthBytesUTF8(str) {
  var len = 0;
  for (var i = 0; i < str.length; ++i) {
    // Gotcha: charCodeAt returns a 16-bit word that is a UTF-16 encoded code unit, not a Unicode code point of the character! So decode UTF16->UTF32->UTF8.
    // See http://unicode.org/faq/utf_bom.html#utf16-3
    var u = str.charCodeAt(i); // possibly a lead surrogate
    if (u >= 0xD800 && u <= 0xDFFF) u = 0x10000 + ((u & 0x3FF) << 10) | (str.charCodeAt(++i) & 0x3FF);
    if (u <= 0x7F) ++len;
    else if (u <= 0x7FF) len += 2;
    else if (u <= 0xFFFF) len += 3;
    else len += 4;
  }
  return len;
}

// end include: runtime_strings.js
// include: runtime_strings_extra.js


// runtime_strings_extra.js: Strings related runtime functions that are available only in regular runtime.

// Given a pointer 'ptr' to a null-terminated ASCII-encoded string in the emscripten HEAP, returns
// a copy of that string as a Javascript String object.

function AsciiToString(ptr) {
  var str = '';
  while (1) {
    var ch = HEAPU8[((ptr++)>>0)];
    if (!ch) return str;
    str += String.fromCharCode(ch);
  }
}

// Copies the given Javascript String object 'str' to the emscripten HEAP at address 'outPtr',
// null-terminated and encoded in ASCII form. The copy will require at most str.length+1 bytes of space in the HEAP.

function stringToAscii(str, outPtr) {
  return writeAsciiToMemory(str, outPtr, false);
}

// Given a pointer 'ptr' to a null-terminated UTF16LE-encoded string in the emscripten HEAP, returns
// a copy of that string as a Javascript String object.

var UTF16Decoder = typeof TextDecoder !== 'undefined' ? new TextDecoder('utf-16le') : undefined;

function UTF16ToString(ptr, maxBytesToRead) {
  var endPtr = ptr;
  // TextDecoder needs to know the byte length in advance, it doesn't stop on null terminator by itself.
  // Also, use the length info to avoid running tiny strings through TextDecoder, since .subarray() allocates garbage.
  var idx = endPtr >> 1;
  var maxIdx = idx + maxBytesToRead / 2;
  // If maxBytesToRead is not passed explicitly, it will be undefined, and this
  // will always evaluate to true. This saves on code size.
  while (!(idx >= maxIdx) && HEAPU16[idx]) ++idx;
  endPtr = idx << 1;

  if (endPtr - ptr > 32 && UTF16Decoder) {
    return UTF16Decoder.decode(HEAPU8.subarray(ptr, endPtr));
  } else {
    var str = '';

    // If maxBytesToRead is not passed explicitly, it will be undefined, and the for-loop's condition
    // will always evaluate to true. The loop is then terminated on the first null char.
    for (var i = 0; !(i >= maxBytesToRead / 2); ++i) {
      var codeUnit = HEAP16[(((ptr)+(i*2))>>1)];
      if (codeUnit == 0) break;
      // fromCharCode constructs a character from a UTF-16 code unit, so we can pass the UTF16 string right through.
      str += String.fromCharCode(codeUnit);
    }

    return str;
  }
}

// Copies the given Javascript String object 'str' to the emscripten HEAP at address 'outPtr',
// null-terminated and encoded in UTF16 form. The copy will require at most str.length*4+2 bytes of space in the HEAP.
// Use the function lengthBytesUTF16() to compute the exact number of bytes (excluding null terminator) that this function will write.
// Parameters:
//   str: the Javascript string to copy.
//   outPtr: Byte address in Emscripten HEAP where to write the string to.
//   maxBytesToWrite: The maximum number of bytes this function can write to the array. This count should include the null
//                    terminator, i.e. if maxBytesToWrite=2, only the null terminator will be written and nothing else.
//                    maxBytesToWrite<2 does not write any bytes to the output, not even the null terminator.
// Returns the number of bytes written, EXCLUDING the null terminator.

function stringToUTF16(str, outPtr, maxBytesToWrite) {
  // Backwards compatibility: if max bytes is not specified, assume unsafe unbounded write is allowed.
  if (maxBytesToWrite === undefined) {
    maxBytesToWrite = 0x7FFFFFFF;
  }
  if (maxBytesToWrite < 2) return 0;
  maxBytesToWrite -= 2; // Null terminator.
  var startPtr = outPtr;
  var numCharsToWrite = (maxBytesToWrite < str.length*2) ? (maxBytesToWrite / 2) : str.length;
  for (var i = 0; i < numCharsToWrite; ++i) {
    // charCodeAt returns a UTF-16 encoded code unit, so it can be directly written to the HEAP.
    var codeUnit = str.charCodeAt(i); // possibly a lead surrogate
    HEAP16[((outPtr)>>1)] = codeUnit;
    outPtr += 2;
  }
  // Null-terminate the pointer to the HEAP.
  HEAP16[((outPtr)>>1)] = 0;
  return outPtr - startPtr;
}

// Returns the number of bytes the given Javascript string takes if encoded as a UTF16 byte array, EXCLUDING the null terminator byte.

function lengthBytesUTF16(str) {
  return str.length*2;
}

function UTF32ToString(ptr, maxBytesToRead) {
  var i = 0;

  var str = '';
  // If maxBytesToRead is not passed explicitly, it will be undefined, and this
  // will always evaluate to true. This saves on code size.
  while (!(i >= maxBytesToRead / 4)) {
    var utf32 = HEAP32[(((ptr)+(i*4))>>2)];
    if (utf32 == 0) break;
    ++i;
    // Gotcha: fromCharCode constructs a character from a UTF-16 encoded code (pair), not from a Unicode code point! So encode the code point to UTF-16 for constructing.
    // See http://unicode.org/faq/utf_bom.html#utf16-3
    if (utf32 >= 0x10000) {
      var ch = utf32 - 0x10000;
      str += String.fromCharCode(0xD800 | (ch >> 10), 0xDC00 | (ch & 0x3FF));
    } else {
      str += String.fromCharCode(utf32);
    }
  }
  return str;
}

// Copies the given Javascript String object 'str' to the emscripten HEAP at address 'outPtr',
// null-terminated and encoded in UTF32 form. The copy will require at most str.length*4+4 bytes of space in the HEAP.
// Use the function lengthBytesUTF32() to compute the exact number of bytes (excluding null terminator) that this function will write.
// Parameters:
//   str: the Javascript string to copy.
//   outPtr: Byte address in Emscripten HEAP where to write the string to.
//   maxBytesToWrite: The maximum number of bytes this function can write to the array. This count should include the null
//                    terminator, i.e. if maxBytesToWrite=4, only the null terminator will be written and nothing else.
//                    maxBytesToWrite<4 does not write any bytes to the output, not even the null terminator.
// Returns the number of bytes written, EXCLUDING the null terminator.

function stringToUTF32(str, outPtr, maxBytesToWrite) {
  // Backwards compatibility: if max bytes is not specified, assume unsafe unbounded write is allowed.
  if (maxBytesToWrite === undefined) {
    maxBytesToWrite = 0x7FFFFFFF;
  }
  if (maxBytesToWrite < 4) return 0;
  var startPtr = outPtr;
  var endPtr = startPtr + maxBytesToWrite - 4;
  for (var i = 0; i < str.length; ++i) {
    // Gotcha: charCodeAt returns a 16-bit word that is a UTF-16 encoded code unit, not a Unicode code point of the character! We must decode the string to UTF-32 to the heap.
    // See http://unicode.org/faq/utf_bom.html#utf16-3
    var codeUnit = str.charCodeAt(i); // possibly a lead surrogate
    if (codeUnit >= 0xD800 && codeUnit <= 0xDFFF) {
      var trailSurrogate = str.charCodeAt(++i);
      codeUnit = 0x10000 + ((codeUnit & 0x3FF) << 10) | (trailSurrogate & 0x3FF);
    }
    HEAP32[((outPtr)>>2)] = codeUnit;
    outPtr += 4;
    if (outPtr + 4 > endPtr) break;
  }
  // Null-terminate the pointer to the HEAP.
  HEAP32[((outPtr)>>2)] = 0;
  return outPtr - startPtr;
}

// Returns the number of bytes the given Javascript string takes if encoded as a UTF16 byte array, EXCLUDING the null terminator byte.

function lengthBytesUTF32(str) {
  var len = 0;
  for (var i = 0; i < str.length; ++i) {
    // Gotcha: charCodeAt returns a 16-bit word that is a UTF-16 encoded code unit, not a Unicode code point of the character! We must decode the string to UTF-32 to the heap.
    // See http://unicode.org/faq/utf_bom.html#utf16-3
    var codeUnit = str.charCodeAt(i);
    if (codeUnit >= 0xD800 && codeUnit <= 0xDFFF) ++i; // possibly a lead surrogate, so skip over the tail surrogate.
    len += 4;
  }

  return len;
}

// Allocate heap space for a JS string, and write it there.
// It is the responsibility of the caller to free() that memory.
function allocateUTF8(str) {
  var size = lengthBytesUTF8(str) + 1;
  var ret = _malloc(size);
  if (ret) stringToUTF8Array(str, HEAP8, ret, size);
  return ret;
}

// Allocate stack space for a JS string, and write it there.
function allocateUTF8OnStack(str) {
  var size = lengthBytesUTF8(str) + 1;
  var ret = stackAlloc(size);
  stringToUTF8Array(str, HEAP8, ret, size);
  return ret;
}

// Deprecated: This function should not be called because it is unsafe and does not provide
// a maximum length limit of how many bytes it is allowed to write. Prefer calling the
// function stringToUTF8Array() instead, which takes in a maximum length that can be used
// to be secure from out of bounds writes.
/** @deprecated
    @param {boolean=} dontAddNull */
function writeStringToMemory(string, buffer, dontAddNull) {
  warnOnce('writeStringToMemory is deprecated and should not be called! Use stringToUTF8() instead!');

  var /** @type {number} */ lastChar, /** @type {number} */ end;
  if (dontAddNull) {
    // stringToUTF8Array always appends null. If we don't want to do that, remember the
    // character that existed at the location where the null will be placed, and restore
    // that after the write (below).
    end = buffer + lengthBytesUTF8(string);
    lastChar = HEAP8[end];
  }
  stringToUTF8(string, buffer, Infinity);
  if (dontAddNull) HEAP8[end] = lastChar; // Restore the value under the null character.
}

function writeArrayToMemory(array, buffer) {
  HEAP8.set(array, buffer);
}

/** @param {boolean=} dontAddNull */
function writeAsciiToMemory(str, buffer, dontAddNull) {
  for (var i = 0; i < str.length; ++i) {
    HEAP8[((buffer++)>>0)] = str.charCodeAt(i);
  }
  // Null-terminate the pointer to the HEAP.
  if (!dontAddNull) HEAP8[((buffer)>>0)] = 0;
}

// end include: runtime_strings_extra.js
// Memory management

function alignUp(x, multiple) {
  if (x % multiple > 0) {
    x += multiple - (x % multiple);
  }
  return x;
}

var HEAP,
/** @type {ArrayBuffer} */
  buffer,
/** @type {Int8Array} */
  HEAP8,
/** @type {Uint8Array} */
  HEAPU8,
/** @type {Int16Array} */
  HEAP16,
/** @type {Uint16Array} */
  HEAPU16,
/** @type {Int32Array} */
  HEAP32,
/** @type {Uint32Array} */
  HEAPU32,
/** @type {Float32Array} */
  HEAPF32,
/** @type {Float64Array} */
  HEAPF64;

function updateGlobalBufferAndViews(buf) {
  buffer = buf;
  Module['HEAP8'] = HEAP8 = new Int8Array(buf);
  Module['HEAP16'] = HEAP16 = new Int16Array(buf);
  Module['HEAP32'] = HEAP32 = new Int32Array(buf);
  Module['HEAPU8'] = HEAPU8 = new Uint8Array(buf);
  Module['HEAPU16'] = HEAPU16 = new Uint16Array(buf);
  Module['HEAPU32'] = HEAPU32 = new Uint32Array(buf);
  Module['HEAPF32'] = HEAPF32 = new Float32Array(buf);
  Module['HEAPF64'] = HEAPF64 = new Float64Array(buf);
}

var TOTAL_STACK = 5242880;

var INITIAL_MEMORY = Module['INITIAL_MEMORY'] || 16777216;

// include: runtime_init_table.js
// In regular non-RELOCATABLE mode the table is exported
// from the wasm module and this will be assigned once
// the exports are available.
var wasmTable;

// end include: runtime_init_table.js
// include: runtime_stack_check.js


// end include: runtime_stack_check.js
// include: runtime_assertions.js


// end include: runtime_assertions.js
var __ATPRERUN__  = []; // functions called before the runtime is initialized
var __ATINIT__    = []; // functions called during startup
var __ATMAIN__    = []; // functions called when main() is to be run
var __ATEXIT__    = []; // functions called during shutdown
var __ATPOSTRUN__ = []; // functions called after the main() is called

var runtimeInitialized = false;
var runtimeExited = false;
var runtimeKeepaliveCounter = 0;

function keepRuntimeAlive() {
  return noExitRuntime || runtimeKeepaliveCounter > 0;
}

function preRun() {

  if (Module['preRun']) {
    if (typeof Module['preRun'] == 'function') Module['preRun'] = [Module['preRun']];
    while (Module['preRun'].length) {
      addOnPreRun(Module['preRun'].shift());
    }
  }

  callRuntimeCallbacks(__ATPRERUN__);
}

function initRuntime() {
  runtimeInitialized = true;

  
if (!Module["noFSInit"] && !FS.init.initialized)
  FS.init();
FS.ignorePermissions = false;

TTY.init();
  callRuntimeCallbacks(__ATINIT__);
}

function preMain() {
  
  callRuntimeCallbacks(__ATMAIN__);
}

function exitRuntime() {
  runtimeExited = true;
}

function postRun() {

  if (Module['postRun']) {
    if (typeof Module['postRun'] == 'function') Module['postRun'] = [Module['postRun']];
    while (Module['postRun'].length) {
      addOnPostRun(Module['postRun'].shift());
    }
  }

  callRuntimeCallbacks(__ATPOSTRUN__);
}

function addOnPreRun(cb) {
  __ATPRERUN__.unshift(cb);
}

function addOnInit(cb) {
  __ATINIT__.unshift(cb);
}

function addOnPreMain(cb) {
  __ATMAIN__.unshift(cb);
}

function addOnExit(cb) {
}

function addOnPostRun(cb) {
  __ATPOSTRUN__.unshift(cb);
}

// include: runtime_math.js


// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Math/imul

// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Math/fround

// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Math/clz32

// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Math/trunc

// end include: runtime_math.js
// A counter of dependencies for calling run(). If we need to
// do asynchronous work before running, increment this and
// decrement it. Incrementing must happen in a place like
// Module.preRun (used by emcc to add file preloading).
// Note that you can add dependencies in preRun, even though
// it happens right before run - run will be postponed until
// the dependencies are met.
var runDependencies = 0;
var runDependencyWatcher = null;
var dependenciesFulfilled = null; // overridden to take different actions when all run dependencies are fulfilled

function getUniqueRunDependency(id) {
  return id;
}

function addRunDependency(id) {
  runDependencies++;

  if (Module['monitorRunDependencies']) {
    Module['monitorRunDependencies'](runDependencies);
  }

}

function removeRunDependency(id) {
  runDependencies--;

  if (Module['monitorRunDependencies']) {
    Module['monitorRunDependencies'](runDependencies);
  }

  if (runDependencies == 0) {
    if (runDependencyWatcher !== null) {
      clearInterval(runDependencyWatcher);
      runDependencyWatcher = null;
    }
    if (dependenciesFulfilled) {
      var callback = dependenciesFulfilled;
      dependenciesFulfilled = null;
      callback(); // can add another dependenciesFulfilled
    }
  }
}

Module["preloadedImages"] = {}; // maps url to image data
Module["preloadedAudios"] = {}; // maps url to audio data

/** @param {string|number=} what */
function abort(what) {
  if (Module['onAbort']) {
    Module['onAbort'](what);
  }

  what += '';
  err(what);

  ABORT = true;
  EXITSTATUS = 1;

  what = 'abort(' + what + '). Build with -s ASSERTIONS=1 for more info.';

  // Use a wasm runtime error, because a JS error might be seen as a foreign
  // exception, which means we'd run destructors on it. We need the error to
  // simply make the program stop.
  var e = new WebAssembly.RuntimeError(what);

  // Throw the error whether or not MODULARIZE is set because abort is used
  // in code paths apart from instantiation where an exception is expected
  // to be thrown when abort is called.
  throw e;
}

// {{MEM_INITIALIZER}}

// include: memoryprofiler.js


// end include: memoryprofiler.js
// include: URIUtils.js


// Prefix of data URIs emitted by SINGLE_FILE and related options.
var dataURIPrefix = 'data:application/octet-stream;base64,';

// Indicates whether filename is a base64 data URI.
function isDataURI(filename) {
  // Prefix of data URIs emitted by SINGLE_FILE and related options.
  return filename.startsWith(dataURIPrefix);
}

// Indicates whether filename is delivered via file protocol (as opposed to http/https)
function isFileURI(filename) {
  return filename.startsWith('file://');
}

// end include: URIUtils.js
var wasmBinaryFile;
  wasmBinaryFile = 'App.wasm';
  if (!isDataURI(wasmBinaryFile)) {
    wasmBinaryFile = locateFile(wasmBinaryFile);
  }

function getBinary(file) {
  try {
    if (file == wasmBinaryFile && wasmBinary) {
      return new Uint8Array(wasmBinary);
    }
    if (readBinary) {
      return readBinary(file);
    } else {
      throw "both async and sync fetching of the wasm failed";
    }
  }
  catch (err) {
    abort(err);
  }
}

function getBinaryPromise() {
  // If we don't have the binary yet, try to to load it asynchronously.
  // Fetch has some additional restrictions over XHR, like it can't be used on a file:// url.
  // See https://github.com/github/fetch/pull/92#issuecomment-140665932
  // Cordova or Electron apps are typically loaded from a file:// url.
  // So use fetch if it is available and the url is not a file, otherwise fall back to XHR.
  if (!wasmBinary && (ENVIRONMENT_IS_WEB || ENVIRONMENT_IS_WORKER)) {
    if (typeof fetch === 'function'
      && !isFileURI(wasmBinaryFile)
    ) {
      return fetch(wasmBinaryFile, { credentials: 'same-origin' }).then(function(response) {
        if (!response['ok']) {
          throw "failed to load wasm binary file at '" + wasmBinaryFile + "'";
        }
        return response['arrayBuffer']();
      }).catch(function () {
          return getBinary(wasmBinaryFile);
      });
    }
    else {
      if (readAsync) {
        // fetch is not available or url is file => try XHR (readAsync uses XHR internally)
        return new Promise(function(resolve, reject) {
          readAsync(wasmBinaryFile, function(response) { resolve(new Uint8Array(/** @type{!ArrayBuffer} */(response))) }, reject)
        });
      }
    }
  }

  // Otherwise, getBinary should be able to get it synchronously
  return Promise.resolve().then(function() { return getBinary(wasmBinaryFile); });
}

// Create the wasm instance.
// Receives the wasm imports, returns the exports.
function createWasm() {
  // prepare imports
  var info = {
    'env': asmLibraryArg,
    'wasi_snapshot_preview1': asmLibraryArg,
  };
  // Load the wasm module and create an instance of using native support in the JS engine.
  // handle a generated wasm instance, receiving its exports and
  // performing other necessary setup
  /** @param {WebAssembly.Module=} module*/
  function receiveInstance(instance, module) {
    var exports = instance.exports;

    exports = Asyncify.instrumentWasmExports(exports);

    Module['asm'] = exports;

    wasmMemory = Module['asm']['memory'];
    updateGlobalBufferAndViews(wasmMemory.buffer);

    wasmTable = Module['asm']['__indirect_function_table'];

    addOnInit(Module['asm']['__wasm_call_ctors']);

    removeRunDependency('wasm-instantiate');
  }
  // we can't run yet (except in a pthread, where we have a custom sync instantiator)
  addRunDependency('wasm-instantiate');

  // Prefer streaming instantiation if available.
  function receiveInstantiationResult(result) {
    // 'result' is a ResultObject object which has both the module and instance.
    // receiveInstance() will swap in the exports (to Module.asm) so they can be called
    // TODO: Due to Closure regression https://github.com/google/closure-compiler/issues/3193, the above line no longer optimizes out down to the following line.
    // When the regression is fixed, can restore the above USE_PTHREADS-enabled path.
    receiveInstance(result['instance']);
  }

  function instantiateArrayBuffer(receiver) {
    return getBinaryPromise().then(function(binary) {
      var result = WebAssembly.instantiate(binary, info);
      return result;
    }).then(receiver, function(reason) {
      err('failed to asynchronously prepare wasm: ' + reason);

      abort(reason);
    });
  }

  function instantiateAsync() {
    if (!wasmBinary &&
        typeof WebAssembly.instantiateStreaming === 'function' &&
        !isDataURI(wasmBinaryFile) &&
        // Don't use streaming for file:// delivered objects in a webview, fetch them synchronously.
        !isFileURI(wasmBinaryFile) &&
        typeof fetch === 'function') {
      return fetch(wasmBinaryFile, { credentials: 'same-origin' }).then(function (response) {
        var result = WebAssembly.instantiateStreaming(response, info);
        return result.then(receiveInstantiationResult, function(reason) {
            // We expect the most common failure cause to be a bad MIME type for the binary,
            // in which case falling back to ArrayBuffer instantiation should work.
            err('wasm streaming compile failed: ' + reason);
            err('falling back to ArrayBuffer instantiation');
            return instantiateArrayBuffer(receiveInstantiationResult);
          });
      });
    } else {
      return instantiateArrayBuffer(receiveInstantiationResult);
    }
  }

  // User shell pages can write their own Module.instantiateWasm = function(imports, successCallback) callback
  // to manually instantiate the Wasm module themselves. This allows pages to run the instantiation parallel
  // to any other async startup actions they are performing.
  if (Module['instantiateWasm']) {
    try {
      var exports = Module['instantiateWasm'](info, receiveInstance);
      exports = Asyncify.instrumentWasmExports(exports);
      return exports;
    } catch(e) {
      err('Module.instantiateWasm callback failed with error: ' + e);
      return false;
    }
  }

  instantiateAsync();
  return {}; // no exports yet; we'll fill them in later
}

// Globals used by JS i64 conversions (see makeSetValue)
var tempDouble;
var tempI64;

// === Body ===

var ASM_CONSTS = {
  50812: function() {if ((window.AudioContext || window.webkitAudioContext) === undefined) { return 0; } if (typeof(miniaudio) === 'undefined') { miniaudio = {}; miniaudio.devices = []; miniaudio.track_device = function(device) { for (var iDevice = 0; iDevice < miniaudio.devices.length; ++iDevice) { if (miniaudio.devices[iDevice] == null) { miniaudio.devices[iDevice] = device; return iDevice; } } miniaudio.devices.push(device); return miniaudio.devices.length - 1; }; miniaudio.untrack_device_by_index = function(deviceIndex) { miniaudio.devices[deviceIndex] = null; while (miniaudio.devices.length > 0) { if (miniaudio.devices[miniaudio.devices.length-1] == null) { miniaudio.devices.pop(); } else { break; } } }; miniaudio.untrack_device = function(device) { for (var iDevice = 0; iDevice < miniaudio.devices.length; ++iDevice) { if (miniaudio.devices[iDevice] == device) { return miniaudio.untrack_device_by_index(iDevice); } } }; miniaudio.get_device_by_index = function(deviceIndex) { return miniaudio.devices[deviceIndex]; }; } return 1;},  
 51843: function() {return (navigator.mediaDevices !== undefined && navigator.mediaDevices.getUserMedia !== undefined);},  
 51947: function() {try { var temp = new (window.AudioContext || window.webkitAudioContext)(); var sampleRate = temp.sampleRate; temp.close(); return sampleRate; } catch(e) { return 0; }},  
 52118: function($0, $1, $2, $3, $4) {var channels = $0; var sampleRate = $1; var bufferSize = $2; var isCapture = $3; var pDevice = $4; if (typeof(miniaudio) === 'undefined') { return -1; } var device = {}; device.webaudio = new (window.AudioContext || window.webkitAudioContext)({sampleRate:sampleRate}); device.webaudio.suspend(); device.intermediaryBufferSizeInBytes = channels * bufferSize * 4; device.intermediaryBuffer = Module._malloc(device.intermediaryBufferSizeInBytes); device.intermediaryBufferView = new Float32Array(Module.HEAPF32.buffer, device.intermediaryBuffer, device.intermediaryBufferSizeInBytes); device.scriptNode = device.webaudio.createScriptProcessor(bufferSize, channels, channels); if (isCapture) { device.scriptNode.onaudioprocess = function(e) { if (device.intermediaryBuffer === undefined) { return; } for (var iChannel = 0; iChannel < e.outputBuffer.numberOfChannels; ++iChannel) { e.outputBuffer.getChannelData(iChannel).fill(0.0); } var sendSilence = false; if (device.streamNode === undefined) { sendSilence = true; } if (e.inputBuffer.numberOfChannels != channels) { console.log("Capture: Channel count mismatch. " + e.inputBufer.numberOfChannels + " != " + channels + ". Sending silence."); sendSilence = true; } var totalFramesProcessed = 0; while (totalFramesProcessed < e.inputBuffer.length) { var framesRemaining = e.inputBuffer.length - totalFramesProcessed; var framesToProcess = framesRemaining; if (framesToProcess > (device.intermediaryBufferSizeInBytes/channels/4)) { framesToProcess = (device.intermediaryBufferSizeInBytes/channels/4); } if (sendSilence) { device.intermediaryBufferView.fill(0.0); } else { for (var iFrame = 0; iFrame < framesToProcess; ++iFrame) { for (var iChannel = 0; iChannel < e.inputBuffer.numberOfChannels; ++iChannel) { device.intermediaryBufferView[iFrame*channels + iChannel] = e.inputBuffer.getChannelData(iChannel)[totalFramesProcessed + iFrame]; } } } ccall("ma_device_process_pcm_frames_capture__webaudio", "undefined", ["number", "number", "number"], [pDevice, framesToProcess, device.intermediaryBuffer]); totalFramesProcessed += framesToProcess; } }; navigator.mediaDevices.getUserMedia({audio:true, video:false}) .then(function(stream) { device.streamNode = device.webaudio.createMediaStreamSource(stream); device.streamNode.connect(device.scriptNode); device.scriptNode.connect(device.webaudio.destination); }) .catch(function(error) { device.scriptNode.connect(device.webaudio.destination); }); } else { device.scriptNode.onaudioprocess = function(e) { if (device.intermediaryBuffer === undefined) { return; } var outputSilence = false; if (e.outputBuffer.numberOfChannels != channels) { console.log("Playback: Channel count mismatch. " + e.outputBufer.numberOfChannels + " != " + channels + ". Outputting silence."); outputSilence = true; return; } var totalFramesProcessed = 0; while (totalFramesProcessed < e.outputBuffer.length) { var framesRemaining = e.outputBuffer.length - totalFramesProcessed; var framesToProcess = framesRemaining; if (framesToProcess > (device.intermediaryBufferSizeInBytes/channels/4)) { framesToProcess = (device.intermediaryBufferSizeInBytes/channels/4); } ccall("ma_device_process_pcm_frames_playback__webaudio", "undefined", ["number", "number", "number"], [pDevice, framesToProcess, device.intermediaryBuffer]); if (outputSilence) { for (var iChannel = 0; iChannel < e.outputBuffer.numberOfChannels; ++iChannel) { e.outputBuffer.getChannelData(iChannel).fill(0.0); } } else { for (var iChannel = 0; iChannel < e.outputBuffer.numberOfChannels; ++iChannel) { for (var iFrame = 0; iFrame < framesToProcess; ++iFrame) { e.outputBuffer.getChannelData(iChannel)[totalFramesProcessed + iFrame] = device.intermediaryBufferView[iFrame*channels + iChannel]; } } } totalFramesProcessed += framesToProcess; } }; device.scriptNode.connect(device.webaudio.destination); } return miniaudio.track_device(device);},  
 56002: function($0) {return miniaudio.get_device_by_index($0).webaudio.sampleRate;},  
 56068: function($0) {return miniaudio.get_device_by_index($0).webaudio.sampleRate;},  
 56134: function($0) {var device = miniaudio.get_device_by_index($0); if (device.scriptNode !== undefined) { device.scriptNode.onaudioprocess = function(e) {}; device.scriptNode.disconnect(); device.scriptNode = undefined; } if (device.streamNode !== undefined) { device.streamNode.disconnect(); device.streamNode = undefined; } device.webaudio.close(); device.webaudio = undefined; if (device.intermediaryBuffer !== undefined) { Module._free(device.intermediaryBuffer); device.intermediaryBuffer = undefined; device.intermediaryBufferView = undefined; device.intermediaryBufferSizeInBytes = undefined; } miniaudio.untrack_device_by_index($0);},  
 56760: function($0) {miniaudio.get_device_by_index($0).webaudio.resume();},  
 56817: function($0) {miniaudio.get_device_by_index($0).webaudio.resume();},  
 56874: function($0) {miniaudio.get_device_by_index($0).webaudio.suspend();},  
 56932: function($0) {miniaudio.get_device_by_index($0).webaudio.suspend();}
};






  function callRuntimeCallbacks(callbacks) {
      while (callbacks.length > 0) {
        var callback = callbacks.shift();
        if (typeof callback == 'function') {
          callback(Module); // Pass the module as the first argument.
          continue;
        }
        var func = callback.func;
        if (typeof func === 'number') {
          if (callback.arg === undefined) {
            (function() {  dynCall_v.call(null, func); })();
          } else {
            (function(a1) {  dynCall_vi.apply(null, [func, a1]); })(callback.arg);
          }
        } else {
          func(callback.arg === undefined ? null : callback.arg);
        }
      }
    }

  function demangle(func) {
      return func;
    }

  function demangleAll(text) {
      var regex =
        /\b_Z[\w\d_]+/g;
      return text.replace(regex,
        function(x) {
          var y = demangle(x);
          return x === y ? x : (y + ' [' + x + ']');
        });
    }

  function jsStackTrace() {
      var error = new Error();
      if (!error.stack) {
        // IE10+ special cases: It does have callstack info, but it is only populated if an Error object is thrown,
        // so try that as a special-case.
        try {
          throw new Error();
        } catch(e) {
          error = e;
        }
        if (!error.stack) {
          return '(no stack trace available)';
        }
      }
      return error.stack.toString();
    }

  function stackTrace() {
      var js = jsStackTrace();
      if (Module['extraStackTrace']) js += '\n' + Module['extraStackTrace']();
      return demangleAll(js);
    }

  function ___assert_fail(condition, filename, line, func) {
      abort('Assertion failed: ' + UTF8ToString(condition) + ', at: ' + [filename ? UTF8ToString(filename) : 'unknown filename', line, func ? UTF8ToString(func) : 'unknown function']);
    }

  function setErrNo(value) {
      HEAP32[((___errno_location())>>2)] = value;
      return value;
    }
  
  var PATH={splitPath:function(filename) {
        var splitPathRe = /^(\/?|)([\s\S]*?)((?:\.{1,2}|[^\/]+?|)(\.[^.\/]*|))(?:[\/]*)$/;
        return splitPathRe.exec(filename).slice(1);
      },normalizeArray:function(parts, allowAboveRoot) {
        // if the path tries to go above the root, `up` ends up > 0
        var up = 0;
        for (var i = parts.length - 1; i >= 0; i--) {
          var last = parts[i];
          if (last === '.') {
            parts.splice(i, 1);
          } else if (last === '..') {
            parts.splice(i, 1);
            up++;
          } else if (up) {
            parts.splice(i, 1);
            up--;
          }
        }
        // if the path is allowed to go above the root, restore leading ..s
        if (allowAboveRoot) {
          for (; up; up--) {
            parts.unshift('..');
          }
        }
        return parts;
      },normalize:function(path) {
        var isAbsolute = path.charAt(0) === '/',
            trailingSlash = path.substr(-1) === '/';
        // Normalize the path
        path = PATH.normalizeArray(path.split('/').filter(function(p) {
          return !!p;
        }), !isAbsolute).join('/');
        if (!path && !isAbsolute) {
          path = '.';
        }
        if (path && trailingSlash) {
          path += '/';
        }
        return (isAbsolute ? '/' : '') + path;
      },dirname:function(path) {
        var result = PATH.splitPath(path),
            root = result[0],
            dir = result[1];
        if (!root && !dir) {
          // No dirname whatsoever
          return '.';
        }
        if (dir) {
          // It has a dirname, strip trailing slash
          dir = dir.substr(0, dir.length - 1);
        }
        return root + dir;
      },basename:function(path) {
        // EMSCRIPTEN return '/'' for '/', not an empty string
        if (path === '/') return '/';
        path = PATH.normalize(path);
        path = path.replace(/\/$/, "");
        var lastSlash = path.lastIndexOf('/');
        if (lastSlash === -1) return path;
        return path.substr(lastSlash+1);
      },extname:function(path) {
        return PATH.splitPath(path)[3];
      },join:function() {
        var paths = Array.prototype.slice.call(arguments, 0);
        return PATH.normalize(paths.join('/'));
      },join2:function(l, r) {
        return PATH.normalize(l + '/' + r);
      }};
  
  function getRandomDevice() {
      if (typeof crypto === 'object' && typeof crypto['getRandomValues'] === 'function') {
        // for modern web browsers
        var randomBuffer = new Uint8Array(1);
        return function() { crypto.getRandomValues(randomBuffer); return randomBuffer[0]; };
      } else
      if (ENVIRONMENT_IS_NODE) {
        // for nodejs with or without crypto support included
        try {
          var crypto_module = require('crypto');
          // nodejs has crypto support
          return function() { return crypto_module['randomBytes'](1)[0]; };
        } catch (e) {
          // nodejs doesn't have crypto support
        }
      }
      // we couldn't find a proper implementation, as Math.random() is not suitable for /dev/random, see emscripten-core/emscripten/pull/7096
      return function() { abort("randomDevice"); };
    }
  
  var PATH_FS={resolve:function() {
        var resolvedPath = '',
          resolvedAbsolute = false;
        for (var i = arguments.length - 1; i >= -1 && !resolvedAbsolute; i--) {
          var path = (i >= 0) ? arguments[i] : FS.cwd();
          // Skip empty and invalid entries
          if (typeof path !== 'string') {
            throw new TypeError('Arguments to path.resolve must be strings');
          } else if (!path) {
            return ''; // an invalid portion invalidates the whole thing
          }
          resolvedPath = path + '/' + resolvedPath;
          resolvedAbsolute = path.charAt(0) === '/';
        }
        // At this point the path should be resolved to a full absolute path, but
        // handle relative paths to be safe (might happen when process.cwd() fails)
        resolvedPath = PATH.normalizeArray(resolvedPath.split('/').filter(function(p) {
          return !!p;
        }), !resolvedAbsolute).join('/');
        return ((resolvedAbsolute ? '/' : '') + resolvedPath) || '.';
      },relative:function(from, to) {
        from = PATH_FS.resolve(from).substr(1);
        to = PATH_FS.resolve(to).substr(1);
        function trim(arr) {
          var start = 0;
          for (; start < arr.length; start++) {
            if (arr[start] !== '') break;
          }
          var end = arr.length - 1;
          for (; end >= 0; end--) {
            if (arr[end] !== '') break;
          }
          if (start > end) return [];
          return arr.slice(start, end - start + 1);
        }
        var fromParts = trim(from.split('/'));
        var toParts = trim(to.split('/'));
        var length = Math.min(fromParts.length, toParts.length);
        var samePartsLength = length;
        for (var i = 0; i < length; i++) {
          if (fromParts[i] !== toParts[i]) {
            samePartsLength = i;
            break;
          }
        }
        var outputParts = [];
        for (var i = samePartsLength; i < fromParts.length; i++) {
          outputParts.push('..');
        }
        outputParts = outputParts.concat(toParts.slice(samePartsLength));
        return outputParts.join('/');
      }};
  
  var TTY={ttys:[],init:function () {
        // https://github.com/emscripten-core/emscripten/pull/1555
        // if (ENVIRONMENT_IS_NODE) {
        //   // currently, FS.init does not distinguish if process.stdin is a file or TTY
        //   // device, it always assumes it's a TTY device. because of this, we're forcing
        //   // process.stdin to UTF8 encoding to at least make stdin reading compatible
        //   // with text files until FS.init can be refactored.
        //   process['stdin']['setEncoding']('utf8');
        // }
      },shutdown:function() {
        // https://github.com/emscripten-core/emscripten/pull/1555
        // if (ENVIRONMENT_IS_NODE) {
        //   // inolen: any idea as to why node -e 'process.stdin.read()' wouldn't exit immediately (with process.stdin being a tty)?
        //   // isaacs: because now it's reading from the stream, you've expressed interest in it, so that read() kicks off a _read() which creates a ReadReq operation
        //   // inolen: I thought read() in that case was a synchronous operation that just grabbed some amount of buffered data if it exists?
        //   // isaacs: it is. but it also triggers a _read() call, which calls readStart() on the handle
        //   // isaacs: do process.stdin.pause() and i'd think it'd probably close the pending call
        //   process['stdin']['pause']();
        // }
      },register:function(dev, ops) {
        TTY.ttys[dev] = { input: [], output: [], ops: ops };
        FS.registerDevice(dev, TTY.stream_ops);
      },stream_ops:{open:function(stream) {
          var tty = TTY.ttys[stream.node.rdev];
          if (!tty) {
            throw new FS.ErrnoError(43);
          }
          stream.tty = tty;
          stream.seekable = false;
        },close:function(stream) {
          // flush any pending line data
          stream.tty.ops.flush(stream.tty);
        },flush:function(stream) {
          stream.tty.ops.flush(stream.tty);
        },read:function(stream, buffer, offset, length, pos /* ignored */) {
          if (!stream.tty || !stream.tty.ops.get_char) {
            throw new FS.ErrnoError(60);
          }
          var bytesRead = 0;
          for (var i = 0; i < length; i++) {
            var result;
            try {
              result = stream.tty.ops.get_char(stream.tty);
            } catch (e) {
              throw new FS.ErrnoError(29);
            }
            if (result === undefined && bytesRead === 0) {
              throw new FS.ErrnoError(6);
            }
            if (result === null || result === undefined) break;
            bytesRead++;
            buffer[offset+i] = result;
          }
          if (bytesRead) {
            stream.node.timestamp = Date.now();
          }
          return bytesRead;
        },write:function(stream, buffer, offset, length, pos) {
          if (!stream.tty || !stream.tty.ops.put_char) {
            throw new FS.ErrnoError(60);
          }
          try {
            for (var i = 0; i < length; i++) {
              stream.tty.ops.put_char(stream.tty, buffer[offset+i]);
            }
          } catch (e) {
            throw new FS.ErrnoError(29);
          }
          if (length) {
            stream.node.timestamp = Date.now();
          }
          return i;
        }},default_tty_ops:{get_char:function(tty) {
          if (!tty.input.length) {
            var result = null;
            if (ENVIRONMENT_IS_NODE) {
              // we will read data by chunks of BUFSIZE
              var BUFSIZE = 256;
              var buf = Buffer.alloc(BUFSIZE);
              var bytesRead = 0;
  
              try {
                bytesRead = nodeFS.readSync(process.stdin.fd, buf, 0, BUFSIZE, null);
              } catch(e) {
                // Cross-platform differences: on Windows, reading EOF throws an exception, but on other OSes,
                // reading EOF returns 0. Uniformize behavior by treating the EOF exception to return 0.
                if (e.toString().includes('EOF')) bytesRead = 0;
                else throw e;
              }
  
              if (bytesRead > 0) {
                result = buf.slice(0, bytesRead).toString('utf-8');
              } else {
                result = null;
              }
            } else
            if (typeof window != 'undefined' &&
              typeof window.prompt == 'function') {
              // Browser.
              result = window.prompt('Input: ');  // returns null on cancel
              if (result !== null) {
                result += '\n';
              }
            } else if (typeof readline == 'function') {
              // Command line.
              result = readline();
              if (result !== null) {
                result += '\n';
              }
            }
            if (!result) {
              return null;
            }
            tty.input = intArrayFromString(result, true);
          }
          return tty.input.shift();
        },put_char:function(tty, val) {
          if (val === null || val === 10) {
            out(UTF8ArrayToString(tty.output, 0));
            tty.output = [];
          } else {
            if (val != 0) tty.output.push(val); // val == 0 would cut text output off in the middle.
          }
        },flush:function(tty) {
          if (tty.output && tty.output.length > 0) {
            out(UTF8ArrayToString(tty.output, 0));
            tty.output = [];
          }
        }},default_tty1_ops:{put_char:function(tty, val) {
          if (val === null || val === 10) {
            err(UTF8ArrayToString(tty.output, 0));
            tty.output = [];
          } else {
            if (val != 0) tty.output.push(val);
          }
        },flush:function(tty) {
          if (tty.output && tty.output.length > 0) {
            err(UTF8ArrayToString(tty.output, 0));
            tty.output = [];
          }
        }}};
  
  function zeroMemory(address, size) {
      HEAPU8.fill(0, address, address + size);
    }
  function mmapAlloc(size) {
      abort();
    }
  var MEMFS={ops_table:null,mount:function(mount) {
        return MEMFS.createNode(null, '/', 16384 | 511 /* 0777 */, 0);
      },createNode:function(parent, name, mode, dev) {
        if (FS.isBlkdev(mode) || FS.isFIFO(mode)) {
          // no supported
          throw new FS.ErrnoError(63);
        }
        if (!MEMFS.ops_table) {
          MEMFS.ops_table = {
            dir: {
              node: {
                getattr: MEMFS.node_ops.getattr,
                setattr: MEMFS.node_ops.setattr,
                lookup: MEMFS.node_ops.lookup,
                mknod: MEMFS.node_ops.mknod,
                rename: MEMFS.node_ops.rename,
                unlink: MEMFS.node_ops.unlink,
                rmdir: MEMFS.node_ops.rmdir,
                readdir: MEMFS.node_ops.readdir,
                symlink: MEMFS.node_ops.symlink
              },
              stream: {
                llseek: MEMFS.stream_ops.llseek
              }
            },
            file: {
              node: {
                getattr: MEMFS.node_ops.getattr,
                setattr: MEMFS.node_ops.setattr
              },
              stream: {
                llseek: MEMFS.stream_ops.llseek,
                read: MEMFS.stream_ops.read,
                write: MEMFS.stream_ops.write,
                allocate: MEMFS.stream_ops.allocate,
                mmap: MEMFS.stream_ops.mmap,
                msync: MEMFS.stream_ops.msync
              }
            },
            link: {
              node: {
                getattr: MEMFS.node_ops.getattr,
                setattr: MEMFS.node_ops.setattr,
                readlink: MEMFS.node_ops.readlink
              },
              stream: {}
            },
            chrdev: {
              node: {
                getattr: MEMFS.node_ops.getattr,
                setattr: MEMFS.node_ops.setattr
              },
              stream: FS.chrdev_stream_ops
            }
          };
        }
        var node = FS.createNode(parent, name, mode, dev);
        if (FS.isDir(node.mode)) {
          node.node_ops = MEMFS.ops_table.dir.node;
          node.stream_ops = MEMFS.ops_table.dir.stream;
          node.contents = {};
        } else if (FS.isFile(node.mode)) {
          node.node_ops = MEMFS.ops_table.file.node;
          node.stream_ops = MEMFS.ops_table.file.stream;
          node.usedBytes = 0; // The actual number of bytes used in the typed array, as opposed to contents.length which gives the whole capacity.
          // When the byte data of the file is populated, this will point to either a typed array, or a normal JS array. Typed arrays are preferred
          // for performance, and used by default. However, typed arrays are not resizable like normal JS arrays are, so there is a small disk size
          // penalty involved for appending file writes that continuously grow a file similar to std::vector capacity vs used -scheme.
          node.contents = null; 
        } else if (FS.isLink(node.mode)) {
          node.node_ops = MEMFS.ops_table.link.node;
          node.stream_ops = MEMFS.ops_table.link.stream;
        } else if (FS.isChrdev(node.mode)) {
          node.node_ops = MEMFS.ops_table.chrdev.node;
          node.stream_ops = MEMFS.ops_table.chrdev.stream;
        }
        node.timestamp = Date.now();
        // add the new node to the parent
        if (parent) {
          parent.contents[name] = node;
          parent.timestamp = node.timestamp;
        }
        return node;
      },getFileDataAsTypedArray:function(node) {
        if (!node.contents) return new Uint8Array(0);
        if (node.contents.subarray) return node.contents.subarray(0, node.usedBytes); // Make sure to not return excess unused bytes.
        return new Uint8Array(node.contents);
      },expandFileStorage:function(node, newCapacity) {
        var prevCapacity = node.contents ? node.contents.length : 0;
        if (prevCapacity >= newCapacity) return; // No need to expand, the storage was already large enough.
        // Don't expand strictly to the given requested limit if it's only a very small increase, but instead geometrically grow capacity.
        // For small filesizes (<1MB), perform size*2 geometric increase, but for large sizes, do a much more conservative size*1.125 increase to
        // avoid overshooting the allocation cap by a very large margin.
        var CAPACITY_DOUBLING_MAX = 1024 * 1024;
        newCapacity = Math.max(newCapacity, (prevCapacity * (prevCapacity < CAPACITY_DOUBLING_MAX ? 2.0 : 1.125)) >>> 0);
        if (prevCapacity != 0) newCapacity = Math.max(newCapacity, 256); // At minimum allocate 256b for each file when expanding.
        var oldContents = node.contents;
        node.contents = new Uint8Array(newCapacity); // Allocate new storage.
        if (node.usedBytes > 0) node.contents.set(oldContents.subarray(0, node.usedBytes), 0); // Copy old data over to the new storage.
      },resizeFileStorage:function(node, newSize) {
        if (node.usedBytes == newSize) return;
        if (newSize == 0) {
          node.contents = null; // Fully decommit when requesting a resize to zero.
          node.usedBytes = 0;
        } else {
          var oldContents = node.contents;
          node.contents = new Uint8Array(newSize); // Allocate new storage.
          if (oldContents) {
            node.contents.set(oldContents.subarray(0, Math.min(newSize, node.usedBytes))); // Copy old data over to the new storage.
          }
          node.usedBytes = newSize;
        }
      },node_ops:{getattr:function(node) {
          var attr = {};
          // device numbers reuse inode numbers.
          attr.dev = FS.isChrdev(node.mode) ? node.id : 1;
          attr.ino = node.id;
          attr.mode = node.mode;
          attr.nlink = 1;
          attr.uid = 0;
          attr.gid = 0;
          attr.rdev = node.rdev;
          if (FS.isDir(node.mode)) {
            attr.size = 4096;
          } else if (FS.isFile(node.mode)) {
            attr.size = node.usedBytes;
          } else if (FS.isLink(node.mode)) {
            attr.size = node.link.length;
          } else {
            attr.size = 0;
          }
          attr.atime = new Date(node.timestamp);
          attr.mtime = new Date(node.timestamp);
          attr.ctime = new Date(node.timestamp);
          // NOTE: In our implementation, st_blocks = Math.ceil(st_size/st_blksize),
          //       but this is not required by the standard.
          attr.blksize = 4096;
          attr.blocks = Math.ceil(attr.size / attr.blksize);
          return attr;
        },setattr:function(node, attr) {
          if (attr.mode !== undefined) {
            node.mode = attr.mode;
          }
          if (attr.timestamp !== undefined) {
            node.timestamp = attr.timestamp;
          }
          if (attr.size !== undefined) {
            MEMFS.resizeFileStorage(node, attr.size);
          }
        },lookup:function(parent, name) {
          throw FS.genericErrors[44];
        },mknod:function(parent, name, mode, dev) {
          return MEMFS.createNode(parent, name, mode, dev);
        },rename:function(old_node, new_dir, new_name) {
          // if we're overwriting a directory at new_name, make sure it's empty.
          if (FS.isDir(old_node.mode)) {
            var new_node;
            try {
              new_node = FS.lookupNode(new_dir, new_name);
            } catch (e) {
            }
            if (new_node) {
              for (var i in new_node.contents) {
                throw new FS.ErrnoError(55);
              }
            }
          }
          // do the internal rewiring
          delete old_node.parent.contents[old_node.name];
          old_node.parent.timestamp = Date.now()
          old_node.name = new_name;
          new_dir.contents[new_name] = old_node;
          new_dir.timestamp = old_node.parent.timestamp;
          old_node.parent = new_dir;
        },unlink:function(parent, name) {
          delete parent.contents[name];
          parent.timestamp = Date.now();
        },rmdir:function(parent, name) {
          var node = FS.lookupNode(parent, name);
          for (var i in node.contents) {
            throw new FS.ErrnoError(55);
          }
          delete parent.contents[name];
          parent.timestamp = Date.now();
        },readdir:function(node) {
          var entries = ['.', '..'];
          for (var key in node.contents) {
            if (!node.contents.hasOwnProperty(key)) {
              continue;
            }
            entries.push(key);
          }
          return entries;
        },symlink:function(parent, newname, oldpath) {
          var node = MEMFS.createNode(parent, newname, 511 /* 0777 */ | 40960, 0);
          node.link = oldpath;
          return node;
        },readlink:function(node) {
          if (!FS.isLink(node.mode)) {
            throw new FS.ErrnoError(28);
          }
          return node.link;
        }},stream_ops:{read:function(stream, buffer, offset, length, position) {
          var contents = stream.node.contents;
          if (position >= stream.node.usedBytes) return 0;
          var size = Math.min(stream.node.usedBytes - position, length);
          if (size > 8 && contents.subarray) { // non-trivial, and typed array
            buffer.set(contents.subarray(position, position + size), offset);
          } else {
            for (var i = 0; i < size; i++) buffer[offset + i] = contents[position + i];
          }
          return size;
        },write:function(stream, buffer, offset, length, position, canOwn) {
  
          if (!length) return 0;
          var node = stream.node;
          node.timestamp = Date.now();
  
          if (buffer.subarray && (!node.contents || node.contents.subarray)) { // This write is from a typed array to a typed array?
            if (canOwn) {
              node.contents = buffer.subarray(offset, offset + length);
              node.usedBytes = length;
              return length;
            } else if (node.usedBytes === 0 && position === 0) { // If this is a simple first write to an empty file, do a fast set since we don't need to care about old data.
              node.contents = buffer.slice(offset, offset + length);
              node.usedBytes = length;
              return length;
            } else if (position + length <= node.usedBytes) { // Writing to an already allocated and used subrange of the file?
              node.contents.set(buffer.subarray(offset, offset + length), position);
              return length;
            }
          }
  
          // Appending to an existing file and we need to reallocate, or source data did not come as a typed array.
          MEMFS.expandFileStorage(node, position+length);
          if (node.contents.subarray && buffer.subarray) {
            // Use typed array write which is available.
            node.contents.set(buffer.subarray(offset, offset + length), position);
          } else {
            for (var i = 0; i < length; i++) {
             node.contents[position + i] = buffer[offset + i]; // Or fall back to manual write if not.
            }
          }
          node.usedBytes = Math.max(node.usedBytes, position + length);
          return length;
        },llseek:function(stream, offset, whence) {
          var position = offset;
          if (whence === 1) {
            position += stream.position;
          } else if (whence === 2) {
            if (FS.isFile(stream.node.mode)) {
              position += stream.node.usedBytes;
            }
          }
          if (position < 0) {
            throw new FS.ErrnoError(28);
          }
          return position;
        },allocate:function(stream, offset, length) {
          MEMFS.expandFileStorage(stream.node, offset + length);
          stream.node.usedBytes = Math.max(stream.node.usedBytes, offset + length);
        },mmap:function(stream, address, length, position, prot, flags) {
          if (address !== 0) {
            // We don't currently support location hints for the address of the mapping
            throw new FS.ErrnoError(28);
          }
          if (!FS.isFile(stream.node.mode)) {
            throw new FS.ErrnoError(43);
          }
          var ptr;
          var allocated;
          var contents = stream.node.contents;
          // Only make a new copy when MAP_PRIVATE is specified.
          if (!(flags & 2) && contents.buffer === buffer) {
            // We can't emulate MAP_SHARED when the file is not backed by the buffer
            // we're mapping to (e.g. the HEAP buffer).
            allocated = false;
            ptr = contents.byteOffset;
          } else {
            // Try to avoid unnecessary slices.
            if (position > 0 || position + length < contents.length) {
              if (contents.subarray) {
                contents = contents.subarray(position, position + length);
              } else {
                contents = Array.prototype.slice.call(contents, position, position + length);
              }
            }
            allocated = true;
            ptr = mmapAlloc(length);
            if (!ptr) {
              throw new FS.ErrnoError(48);
            }
            HEAP8.set(contents, ptr);
          }
          return { ptr: ptr, allocated: allocated };
        },msync:function(stream, buffer, offset, length, mmapFlags) {
          if (!FS.isFile(stream.node.mode)) {
            throw new FS.ErrnoError(43);
          }
          if (mmapFlags & 2) {
            // MAP_PRIVATE calls need not to be synced back to underlying fs
            return 0;
          }
  
          var bytesWritten = MEMFS.stream_ops.write(stream, buffer, 0, length, offset, false);
          // should we check if bytesWritten and length are the same?
          return 0;
        }}};
  
  function asyncLoad(url, onload, onerror, noRunDep) {
      var dep = !noRunDep ? getUniqueRunDependency('al ' + url) : '';
      readAsync(url, function(arrayBuffer) {
        assert(arrayBuffer, 'Loading data file "' + url + '" failed (no arrayBuffer).');
        onload(new Uint8Array(arrayBuffer));
        if (dep) removeRunDependency(dep);
      }, function(event) {
        if (onerror) {
          onerror();
        } else {
          throw 'Loading data file "' + url + '" failed.';
        }
      });
      if (dep) addRunDependency(dep);
    }
  var FS={root:null,mounts:[],devices:{},streams:[],nextInode:1,nameTable:null,currentPath:"/",initialized:false,ignorePermissions:true,trackingDelegate:{},tracking:{openFlags:{READ:1,WRITE:2}},ErrnoError:null,genericErrors:{},filesystems:null,syncFSRequests:0,lookupPath:function(path, opts) {
        path = PATH_FS.resolve(FS.cwd(), path);
        opts = opts || {};
  
        if (!path) return { path: '', node: null };
  
        var defaults = {
          follow_mount: true,
          recurse_count: 0
        };
        for (var key in defaults) {
          if (opts[key] === undefined) {
            opts[key] = defaults[key];
          }
        }
  
        if (opts.recurse_count > 8) {  // max recursive lookup of 8
          throw new FS.ErrnoError(32);
        }
  
        // split the path
        var parts = PATH.normalizeArray(path.split('/').filter(function(p) {
          return !!p;
        }), false);
  
        // start at the root
        var current = FS.root;
        var current_path = '/';
  
        for (var i = 0; i < parts.length; i++) {
          var islast = (i === parts.length-1);
          if (islast && opts.parent) {
            // stop resolving
            break;
          }
  
          current = FS.lookupNode(current, parts[i]);
          current_path = PATH.join2(current_path, parts[i]);
  
          // jump to the mount's root node if this is a mountpoint
          if (FS.isMountpoint(current)) {
            if (!islast || (islast && opts.follow_mount)) {
              current = current.mounted.root;
            }
          }
  
          // by default, lookupPath will not follow a symlink if it is the final path component.
          // setting opts.follow = true will override this behavior.
          if (!islast || opts.follow) {
            var count = 0;
            while (FS.isLink(current.mode)) {
              var link = FS.readlink(current_path);
              current_path = PATH_FS.resolve(PATH.dirname(current_path), link);
  
              var lookup = FS.lookupPath(current_path, { recurse_count: opts.recurse_count });
              current = lookup.node;
  
              if (count++ > 40) {  // limit max consecutive symlinks to 40 (SYMLOOP_MAX).
                throw new FS.ErrnoError(32);
              }
            }
          }
        }
  
        return { path: current_path, node: current };
      },getPath:function(node) {
        var path;
        while (true) {
          if (FS.isRoot(node)) {
            var mount = node.mount.mountpoint;
            if (!path) return mount;
            return mount[mount.length-1] !== '/' ? mount + '/' + path : mount + path;
          }
          path = path ? node.name + '/' + path : node.name;
          node = node.parent;
        }
      },hashName:function(parentid, name) {
        var hash = 0;
  
        for (var i = 0; i < name.length; i++) {
          hash = ((hash << 5) - hash + name.charCodeAt(i)) | 0;
        }
        return ((parentid + hash) >>> 0) % FS.nameTable.length;
      },hashAddNode:function(node) {
        var hash = FS.hashName(node.parent.id, node.name);
        node.name_next = FS.nameTable[hash];
        FS.nameTable[hash] = node;
      },hashRemoveNode:function(node) {
        var hash = FS.hashName(node.parent.id, node.name);
        if (FS.nameTable[hash] === node) {
          FS.nameTable[hash] = node.name_next;
        } else {
          var current = FS.nameTable[hash];
          while (current) {
            if (current.name_next === node) {
              current.name_next = node.name_next;
              break;
            }
            current = current.name_next;
          }
        }
      },lookupNode:function(parent, name) {
        var errCode = FS.mayLookup(parent);
        if (errCode) {
          throw new FS.ErrnoError(errCode, parent);
        }
        var hash = FS.hashName(parent.id, name);
        for (var node = FS.nameTable[hash]; node; node = node.name_next) {
          var nodeName = node.name;
          if (node.parent.id === parent.id && nodeName === name) {
            return node;
          }
        }
        // if we failed to find it in the cache, call into the VFS
        return FS.lookup(parent, name);
      },createNode:function(parent, name, mode, rdev) {
        var node = new FS.FSNode(parent, name, mode, rdev);
  
        FS.hashAddNode(node);
  
        return node;
      },destroyNode:function(node) {
        FS.hashRemoveNode(node);
      },isRoot:function(node) {
        return node === node.parent;
      },isMountpoint:function(node) {
        return !!node.mounted;
      },isFile:function(mode) {
        return (mode & 61440) === 32768;
      },isDir:function(mode) {
        return (mode & 61440) === 16384;
      },isLink:function(mode) {
        return (mode & 61440) === 40960;
      },isChrdev:function(mode) {
        return (mode & 61440) === 8192;
      },isBlkdev:function(mode) {
        return (mode & 61440) === 24576;
      },isFIFO:function(mode) {
        return (mode & 61440) === 4096;
      },isSocket:function(mode) {
        return (mode & 49152) === 49152;
      },flagModes:{"r":0,"r+":2,"w":577,"w+":578,"a":1089,"a+":1090},modeStringToFlags:function(str) {
        var flags = FS.flagModes[str];
        if (typeof flags === 'undefined') {
          throw new Error('Unknown file open mode: ' + str);
        }
        return flags;
      },flagsToPermissionString:function(flag) {
        var perms = ['r', 'w', 'rw'][flag & 3];
        if ((flag & 512)) {
          perms += 'w';
        }
        return perms;
      },nodePermissions:function(node, perms) {
        if (FS.ignorePermissions) {
          return 0;
        }
        // return 0 if any user, group or owner bits are set.
        if (perms.includes('r') && !(node.mode & 292)) {
          return 2;
        } else if (perms.includes('w') && !(node.mode & 146)) {
          return 2;
        } else if (perms.includes('x') && !(node.mode & 73)) {
          return 2;
        }
        return 0;
      },mayLookup:function(dir) {
        var errCode = FS.nodePermissions(dir, 'x');
        if (errCode) return errCode;
        if (!dir.node_ops.lookup) return 2;
        return 0;
      },mayCreate:function(dir, name) {
        try {
          var node = FS.lookupNode(dir, name);
          return 20;
        } catch (e) {
        }
        return FS.nodePermissions(dir, 'wx');
      },mayDelete:function(dir, name, isdir) {
        var node;
        try {
          node = FS.lookupNode(dir, name);
        } catch (e) {
          return e.errno;
        }
        var errCode = FS.nodePermissions(dir, 'wx');
        if (errCode) {
          return errCode;
        }
        if (isdir) {
          if (!FS.isDir(node.mode)) {
            return 54;
          }
          if (FS.isRoot(node) || FS.getPath(node) === FS.cwd()) {
            return 10;
          }
        } else {
          if (FS.isDir(node.mode)) {
            return 31;
          }
        }
        return 0;
      },mayOpen:function(node, flags) {
        if (!node) {
          return 44;
        }
        if (FS.isLink(node.mode)) {
          return 32;
        } else if (FS.isDir(node.mode)) {
          if (FS.flagsToPermissionString(flags) !== 'r' || // opening for write
              (flags & 512)) { // TODO: check for O_SEARCH? (== search for dir only)
            return 31;
          }
        }
        return FS.nodePermissions(node, FS.flagsToPermissionString(flags));
      },MAX_OPEN_FDS:4096,nextfd:function(fd_start, fd_end) {
        fd_start = fd_start || 0;
        fd_end = fd_end || FS.MAX_OPEN_FDS;
        for (var fd = fd_start; fd <= fd_end; fd++) {
          if (!FS.streams[fd]) {
            return fd;
          }
        }
        throw new FS.ErrnoError(33);
      },getStream:function(fd) {
        return FS.streams[fd];
      },createStream:function(stream, fd_start, fd_end) {
        if (!FS.FSStream) {
          FS.FSStream = /** @constructor */ function(){};
          FS.FSStream.prototype = {
            object: {
              get: function() { return this.node; },
              set: function(val) { this.node = val; }
            },
            isRead: {
              get: function() { return (this.flags & 2097155) !== 1; }
            },
            isWrite: {
              get: function() { return (this.flags & 2097155) !== 0; }
            },
            isAppend: {
              get: function() { return (this.flags & 1024); }
            }
          };
        }
        // clone it, so we can return an instance of FSStream
        var newStream = new FS.FSStream();
        for (var p in stream) {
          newStream[p] = stream[p];
        }
        stream = newStream;
        var fd = FS.nextfd(fd_start, fd_end);
        stream.fd = fd;
        FS.streams[fd] = stream;
        return stream;
      },closeStream:function(fd) {
        FS.streams[fd] = null;
      },chrdev_stream_ops:{open:function(stream) {
          var device = FS.getDevice(stream.node.rdev);
          // override node's stream ops with the device's
          stream.stream_ops = device.stream_ops;
          // forward the open call
          if (stream.stream_ops.open) {
            stream.stream_ops.open(stream);
          }
        },llseek:function() {
          throw new FS.ErrnoError(70);
        }},major:function(dev) {
        return ((dev) >> 8);
      },minor:function(dev) {
        return ((dev) & 0xff);
      },makedev:function(ma, mi) {
        return ((ma) << 8 | (mi));
      },registerDevice:function(dev, ops) {
        FS.devices[dev] = { stream_ops: ops };
      },getDevice:function(dev) {
        return FS.devices[dev];
      },getMounts:function(mount) {
        var mounts = [];
        var check = [mount];
  
        while (check.length) {
          var m = check.pop();
  
          mounts.push(m);
  
          check.push.apply(check, m.mounts);
        }
  
        return mounts;
      },syncfs:function(populate, callback) {
        if (typeof(populate) === 'function') {
          callback = populate;
          populate = false;
        }
  
        FS.syncFSRequests++;
  
        if (FS.syncFSRequests > 1) {
          err('warning: ' + FS.syncFSRequests + ' FS.syncfs operations in flight at once, probably just doing extra work');
        }
  
        var mounts = FS.getMounts(FS.root.mount);
        var completed = 0;
  
        function doCallback(errCode) {
          FS.syncFSRequests--;
          return callback(errCode);
        }
  
        function done(errCode) {
          if (errCode) {
            if (!done.errored) {
              done.errored = true;
              return doCallback(errCode);
            }
            return;
          }
          if (++completed >= mounts.length) {
            doCallback(null);
          }
        };
  
        // sync all mounts
        mounts.forEach(function (mount) {
          if (!mount.type.syncfs) {
            return done(null);
          }
          mount.type.syncfs(mount, populate, done);
        });
      },mount:function(type, opts, mountpoint) {
        var root = mountpoint === '/';
        var pseudo = !mountpoint;
        var node;
  
        if (root && FS.root) {
          throw new FS.ErrnoError(10);
        } else if (!root && !pseudo) {
          var lookup = FS.lookupPath(mountpoint, { follow_mount: false });
  
          mountpoint = lookup.path;  // use the absolute path
          node = lookup.node;
  
          if (FS.isMountpoint(node)) {
            throw new FS.ErrnoError(10);
          }
  
          if (!FS.isDir(node.mode)) {
            throw new FS.ErrnoError(54);
          }
        }
  
        var mount = {
          type: type,
          opts: opts,
          mountpoint: mountpoint,
          mounts: []
        };
  
        // create a root node for the fs
        var mountRoot = type.mount(mount);
        mountRoot.mount = mount;
        mount.root = mountRoot;
  
        if (root) {
          FS.root = mountRoot;
        } else if (node) {
          // set as a mountpoint
          node.mounted = mount;
  
          // add the new mount to the current mount's children
          if (node.mount) {
            node.mount.mounts.push(mount);
          }
        }
  
        return mountRoot;
      },unmount:function (mountpoint) {
        var lookup = FS.lookupPath(mountpoint, { follow_mount: false });
  
        if (!FS.isMountpoint(lookup.node)) {
          throw new FS.ErrnoError(28);
        }
  
        // destroy the nodes for this mount, and all its child mounts
        var node = lookup.node;
        var mount = node.mounted;
        var mounts = FS.getMounts(mount);
  
        Object.keys(FS.nameTable).forEach(function (hash) {
          var current = FS.nameTable[hash];
  
          while (current) {
            var next = current.name_next;
  
            if (mounts.includes(current.mount)) {
              FS.destroyNode(current);
            }
  
            current = next;
          }
        });
  
        // no longer a mountpoint
        node.mounted = null;
  
        // remove this mount from the child mounts
        var idx = node.mount.mounts.indexOf(mount);
        node.mount.mounts.splice(idx, 1);
      },lookup:function(parent, name) {
        return parent.node_ops.lookup(parent, name);
      },mknod:function(path, mode, dev) {
        var lookup = FS.lookupPath(path, { parent: true });
        var parent = lookup.node;
        var name = PATH.basename(path);
        if (!name || name === '.' || name === '..') {
          throw new FS.ErrnoError(28);
        }
        var errCode = FS.mayCreate(parent, name);
        if (errCode) {
          throw new FS.ErrnoError(errCode);
        }
        if (!parent.node_ops.mknod) {
          throw new FS.ErrnoError(63);
        }
        return parent.node_ops.mknod(parent, name, mode, dev);
      },create:function(path, mode) {
        mode = mode !== undefined ? mode : 438 /* 0666 */;
        mode &= 4095;
        mode |= 32768;
        return FS.mknod(path, mode, 0);
      },mkdir:function(path, mode) {
        mode = mode !== undefined ? mode : 511 /* 0777 */;
        mode &= 511 | 512;
        mode |= 16384;
        return FS.mknod(path, mode, 0);
      },mkdirTree:function(path, mode) {
        var dirs = path.split('/');
        var d = '';
        for (var i = 0; i < dirs.length; ++i) {
          if (!dirs[i]) continue;
          d += '/' + dirs[i];
          try {
            FS.mkdir(d, mode);
          } catch(e) {
            if (e.errno != 20) throw e;
          }
        }
      },mkdev:function(path, mode, dev) {
        if (typeof(dev) === 'undefined') {
          dev = mode;
          mode = 438 /* 0666 */;
        }
        mode |= 8192;
        return FS.mknod(path, mode, dev);
      },symlink:function(oldpath, newpath) {
        if (!PATH_FS.resolve(oldpath)) {
          throw new FS.ErrnoError(44);
        }
        var lookup = FS.lookupPath(newpath, { parent: true });
        var parent = lookup.node;
        if (!parent) {
          throw new FS.ErrnoError(44);
        }
        var newname = PATH.basename(newpath);
        var errCode = FS.mayCreate(parent, newname);
        if (errCode) {
          throw new FS.ErrnoError(errCode);
        }
        if (!parent.node_ops.symlink) {
          throw new FS.ErrnoError(63);
        }
        return parent.node_ops.symlink(parent, newname, oldpath);
      },rename:function(old_path, new_path) {
        var old_dirname = PATH.dirname(old_path);
        var new_dirname = PATH.dirname(new_path);
        var old_name = PATH.basename(old_path);
        var new_name = PATH.basename(new_path);
        // parents must exist
        var lookup, old_dir, new_dir;
  
        // let the errors from non existant directories percolate up
        lookup = FS.lookupPath(old_path, { parent: true });
        old_dir = lookup.node;
        lookup = FS.lookupPath(new_path, { parent: true });
        new_dir = lookup.node;
  
        if (!old_dir || !new_dir) throw new FS.ErrnoError(44);
        // need to be part of the same mount
        if (old_dir.mount !== new_dir.mount) {
          throw new FS.ErrnoError(75);
        }
        // source must exist
        var old_node = FS.lookupNode(old_dir, old_name);
        // old path should not be an ancestor of the new path
        var relative = PATH_FS.relative(old_path, new_dirname);
        if (relative.charAt(0) !== '.') {
          throw new FS.ErrnoError(28);
        }
        // new path should not be an ancestor of the old path
        relative = PATH_FS.relative(new_path, old_dirname);
        if (relative.charAt(0) !== '.') {
          throw new FS.ErrnoError(55);
        }
        // see if the new path already exists
        var new_node;
        try {
          new_node = FS.lookupNode(new_dir, new_name);
        } catch (e) {
          // not fatal
        }
        // early out if nothing needs to change
        if (old_node === new_node) {
          return;
        }
        // we'll need to delete the old entry
        var isdir = FS.isDir(old_node.mode);
        var errCode = FS.mayDelete(old_dir, old_name, isdir);
        if (errCode) {
          throw new FS.ErrnoError(errCode);
        }
        // need delete permissions if we'll be overwriting.
        // need create permissions if new doesn't already exist.
        errCode = new_node ?
          FS.mayDelete(new_dir, new_name, isdir) :
          FS.mayCreate(new_dir, new_name);
        if (errCode) {
          throw new FS.ErrnoError(errCode);
        }
        if (!old_dir.node_ops.rename) {
          throw new FS.ErrnoError(63);
        }
        if (FS.isMountpoint(old_node) || (new_node && FS.isMountpoint(new_node))) {
          throw new FS.ErrnoError(10);
        }
        // if we are going to change the parent, check write permissions
        if (new_dir !== old_dir) {
          errCode = FS.nodePermissions(old_dir, 'w');
          if (errCode) {
            throw new FS.ErrnoError(errCode);
          }
        }
        try {
          if (FS.trackingDelegate['willMovePath']) {
            FS.trackingDelegate['willMovePath'](old_path, new_path);
          }
        } catch(e) {
          err("FS.trackingDelegate['willMovePath']('"+old_path+"', '"+new_path+"') threw an exception: " + e.message);
        }
        // remove the node from the lookup hash
        FS.hashRemoveNode(old_node);
        // do the underlying fs rename
        try {
          old_dir.node_ops.rename(old_node, new_dir, new_name);
        } catch (e) {
          throw e;
        } finally {
          // add the node back to the hash (in case node_ops.rename
          // changed its name)
          FS.hashAddNode(old_node);
        }
        try {
          if (FS.trackingDelegate['onMovePath']) FS.trackingDelegate['onMovePath'](old_path, new_path);
        } catch(e) {
          err("FS.trackingDelegate['onMovePath']('"+old_path+"', '"+new_path+"') threw an exception: " + e.message);
        }
      },rmdir:function(path) {
        var lookup = FS.lookupPath(path, { parent: true });
        var parent = lookup.node;
        var name = PATH.basename(path);
        var node = FS.lookupNode(parent, name);
        var errCode = FS.mayDelete(parent, name, true);
        if (errCode) {
          throw new FS.ErrnoError(errCode);
        }
        if (!parent.node_ops.rmdir) {
          throw new FS.ErrnoError(63);
        }
        if (FS.isMountpoint(node)) {
          throw new FS.ErrnoError(10);
        }
        try {
          if (FS.trackingDelegate['willDeletePath']) {
            FS.trackingDelegate['willDeletePath'](path);
          }
        } catch(e) {
          err("FS.trackingDelegate['willDeletePath']('"+path+"') threw an exception: " + e.message);
        }
        parent.node_ops.rmdir(parent, name);
        FS.destroyNode(node);
        try {
          if (FS.trackingDelegate['onDeletePath']) FS.trackingDelegate['onDeletePath'](path);
        } catch(e) {
          err("FS.trackingDelegate['onDeletePath']('"+path+"') threw an exception: " + e.message);
        }
      },readdir:function(path) {
        var lookup = FS.lookupPath(path, { follow: true });
        var node = lookup.node;
        if (!node.node_ops.readdir) {
          throw new FS.ErrnoError(54);
        }
        return node.node_ops.readdir(node);
      },unlink:function(path) {
        var lookup = FS.lookupPath(path, { parent: true });
        var parent = lookup.node;
        var name = PATH.basename(path);
        var node = FS.lookupNode(parent, name);
        var errCode = FS.mayDelete(parent, name, false);
        if (errCode) {
          // According to POSIX, we should map EISDIR to EPERM, but
          // we instead do what Linux does (and we must, as we use
          // the musl linux libc).
          throw new FS.ErrnoError(errCode);
        }
        if (!parent.node_ops.unlink) {
          throw new FS.ErrnoError(63);
        }
        if (FS.isMountpoint(node)) {
          throw new FS.ErrnoError(10);
        }
        try {
          if (FS.trackingDelegate['willDeletePath']) {
            FS.trackingDelegate['willDeletePath'](path);
          }
        } catch(e) {
          err("FS.trackingDelegate['willDeletePath']('"+path+"') threw an exception: " + e.message);
        }
        parent.node_ops.unlink(parent, name);
        FS.destroyNode(node);
        try {
          if (FS.trackingDelegate['onDeletePath']) FS.trackingDelegate['onDeletePath'](path);
        } catch(e) {
          err("FS.trackingDelegate['onDeletePath']('"+path+"') threw an exception: " + e.message);
        }
      },readlink:function(path) {
        var lookup = FS.lookupPath(path);
        var link = lookup.node;
        if (!link) {
          throw new FS.ErrnoError(44);
        }
        if (!link.node_ops.readlink) {
          throw new FS.ErrnoError(28);
        }
        return PATH_FS.resolve(FS.getPath(link.parent), link.node_ops.readlink(link));
      },stat:function(path, dontFollow) {
        var lookup = FS.lookupPath(path, { follow: !dontFollow });
        var node = lookup.node;
        if (!node) {
          throw new FS.ErrnoError(44);
        }
        if (!node.node_ops.getattr) {
          throw new FS.ErrnoError(63);
        }
        return node.node_ops.getattr(node);
      },lstat:function(path) {
        return FS.stat(path, true);
      },chmod:function(path, mode, dontFollow) {
        var node;
        if (typeof path === 'string') {
          var lookup = FS.lookupPath(path, { follow: !dontFollow });
          node = lookup.node;
        } else {
          node = path;
        }
        if (!node.node_ops.setattr) {
          throw new FS.ErrnoError(63);
        }
        node.node_ops.setattr(node, {
          mode: (mode & 4095) | (node.mode & ~4095),
          timestamp: Date.now()
        });
      },lchmod:function(path, mode) {
        FS.chmod(path, mode, true);
      },fchmod:function(fd, mode) {
        var stream = FS.getStream(fd);
        if (!stream) {
          throw new FS.ErrnoError(8);
        }
        FS.chmod(stream.node, mode);
      },chown:function(path, uid, gid, dontFollow) {
        var node;
        if (typeof path === 'string') {
          var lookup = FS.lookupPath(path, { follow: !dontFollow });
          node = lookup.node;
        } else {
          node = path;
        }
        if (!node.node_ops.setattr) {
          throw new FS.ErrnoError(63);
        }
        node.node_ops.setattr(node, {
          timestamp: Date.now()
          // we ignore the uid / gid for now
        });
      },lchown:function(path, uid, gid) {
        FS.chown(path, uid, gid, true);
      },fchown:function(fd, uid, gid) {
        var stream = FS.getStream(fd);
        if (!stream) {
          throw new FS.ErrnoError(8);
        }
        FS.chown(stream.node, uid, gid);
      },truncate:function(path, len) {
        if (len < 0) {
          throw new FS.ErrnoError(28);
        }
        var node;
        if (typeof path === 'string') {
          var lookup = FS.lookupPath(path, { follow: true });
          node = lookup.node;
        } else {
          node = path;
        }
        if (!node.node_ops.setattr) {
          throw new FS.ErrnoError(63);
        }
        if (FS.isDir(node.mode)) {
          throw new FS.ErrnoError(31);
        }
        if (!FS.isFile(node.mode)) {
          throw new FS.ErrnoError(28);
        }
        var errCode = FS.nodePermissions(node, 'w');
        if (errCode) {
          throw new FS.ErrnoError(errCode);
        }
        node.node_ops.setattr(node, {
          size: len,
          timestamp: Date.now()
        });
      },ftruncate:function(fd, len) {
        var stream = FS.getStream(fd);
        if (!stream) {
          throw new FS.ErrnoError(8);
        }
        if ((stream.flags & 2097155) === 0) {
          throw new FS.ErrnoError(28);
        }
        FS.truncate(stream.node, len);
      },utime:function(path, atime, mtime) {
        var lookup = FS.lookupPath(path, { follow: true });
        var node = lookup.node;
        node.node_ops.setattr(node, {
          timestamp: Math.max(atime, mtime)
        });
      },open:function(path, flags, mode, fd_start, fd_end) {
        if (path === "") {
          throw new FS.ErrnoError(44);
        }
        flags = typeof flags === 'string' ? FS.modeStringToFlags(flags) : flags;
        mode = typeof mode === 'undefined' ? 438 /* 0666 */ : mode;
        if ((flags & 64)) {
          mode = (mode & 4095) | 32768;
        } else {
          mode = 0;
        }
        var node;
        if (typeof path === 'object') {
          node = path;
        } else {
          path = PATH.normalize(path);
          try {
            var lookup = FS.lookupPath(path, {
              follow: !(flags & 131072)
            });
            node = lookup.node;
          } catch (e) {
            // ignore
          }
        }
        // perhaps we need to create the node
        var created = false;
        if ((flags & 64)) {
          if (node) {
            // if O_CREAT and O_EXCL are set, error out if the node already exists
            if ((flags & 128)) {
              throw new FS.ErrnoError(20);
            }
          } else {
            // node doesn't exist, try to create it
            node = FS.mknod(path, mode, 0);
            created = true;
          }
        }
        if (!node) {
          throw new FS.ErrnoError(44);
        }
        // can't truncate a device
        if (FS.isChrdev(node.mode)) {
          flags &= ~512;
        }
        // if asked only for a directory, then this must be one
        if ((flags & 65536) && !FS.isDir(node.mode)) {
          throw new FS.ErrnoError(54);
        }
        // check permissions, if this is not a file we just created now (it is ok to
        // create and write to a file with read-only permissions; it is read-only
        // for later use)
        if (!created) {
          var errCode = FS.mayOpen(node, flags);
          if (errCode) {
            throw new FS.ErrnoError(errCode);
          }
        }
        // do truncation if necessary
        if ((flags & 512)) {
          FS.truncate(node, 0);
        }
        // we've already handled these, don't pass down to the underlying vfs
        flags &= ~(128 | 512 | 131072);
  
        // register the stream with the filesystem
        var stream = FS.createStream({
          node: node,
          path: FS.getPath(node),  // we want the absolute path to the node
          flags: flags,
          seekable: true,
          position: 0,
          stream_ops: node.stream_ops,
          // used by the file family libc calls (fopen, fwrite, ferror, etc.)
          ungotten: [],
          error: false
        }, fd_start, fd_end);
        // call the new stream's open function
        if (stream.stream_ops.open) {
          stream.stream_ops.open(stream);
        }
        if (Module['logReadFiles'] && !(flags & 1)) {
          if (!FS.readFiles) FS.readFiles = {};
          if (!(path in FS.readFiles)) {
            FS.readFiles[path] = 1;
            err("FS.trackingDelegate error on read file: " + path);
          }
        }
        try {
          if (FS.trackingDelegate['onOpenFile']) {
            var trackingFlags = 0;
            if ((flags & 2097155) !== 1) {
              trackingFlags |= FS.tracking.openFlags.READ;
            }
            if ((flags & 2097155) !== 0) {
              trackingFlags |= FS.tracking.openFlags.WRITE;
            }
            FS.trackingDelegate['onOpenFile'](path, trackingFlags);
          }
        } catch(e) {
          err("FS.trackingDelegate['onOpenFile']('"+path+"', flags) threw an exception: " + e.message);
        }
        return stream;
      },close:function(stream) {
        if (FS.isClosed(stream)) {
          throw new FS.ErrnoError(8);
        }
        if (stream.getdents) stream.getdents = null; // free readdir state
        try {
          if (stream.stream_ops.close) {
            stream.stream_ops.close(stream);
          }
        } catch (e) {
          throw e;
        } finally {
          FS.closeStream(stream.fd);
        }
        stream.fd = null;
      },isClosed:function(stream) {
        return stream.fd === null;
      },llseek:function(stream, offset, whence) {
        if (FS.isClosed(stream)) {
          throw new FS.ErrnoError(8);
        }
        if (!stream.seekable || !stream.stream_ops.llseek) {
          throw new FS.ErrnoError(70);
        }
        if (whence != 0 && whence != 1 && whence != 2) {
          throw new FS.ErrnoError(28);
        }
        stream.position = stream.stream_ops.llseek(stream, offset, whence);
        stream.ungotten = [];
        return stream.position;
      },read:function(stream, buffer, offset, length, position) {
        if (length < 0 || position < 0) {
          throw new FS.ErrnoError(28);
        }
        if (FS.isClosed(stream)) {
          throw new FS.ErrnoError(8);
        }
        if ((stream.flags & 2097155) === 1) {
          throw new FS.ErrnoError(8);
        }
        if (FS.isDir(stream.node.mode)) {
          throw new FS.ErrnoError(31);
        }
        if (!stream.stream_ops.read) {
          throw new FS.ErrnoError(28);
        }
        var seeking = typeof position !== 'undefined';
        if (!seeking) {
          position = stream.position;
        } else if (!stream.seekable) {
          throw new FS.ErrnoError(70);
        }
        var bytesRead = stream.stream_ops.read(stream, buffer, offset, length, position);
        if (!seeking) stream.position += bytesRead;
        return bytesRead;
      },write:function(stream, buffer, offset, length, position, canOwn) {
        if (length < 0 || position < 0) {
          throw new FS.ErrnoError(28);
        }
        if (FS.isClosed(stream)) {
          throw new FS.ErrnoError(8);
        }
        if ((stream.flags & 2097155) === 0) {
          throw new FS.ErrnoError(8);
        }
        if (FS.isDir(stream.node.mode)) {
          throw new FS.ErrnoError(31);
        }
        if (!stream.stream_ops.write) {
          throw new FS.ErrnoError(28);
        }
        if (stream.seekable && stream.flags & 1024) {
          // seek to the end before writing in append mode
          FS.llseek(stream, 0, 2);
        }
        var seeking = typeof position !== 'undefined';
        if (!seeking) {
          position = stream.position;
        } else if (!stream.seekable) {
          throw new FS.ErrnoError(70);
        }
        var bytesWritten = stream.stream_ops.write(stream, buffer, offset, length, position, canOwn);
        if (!seeking) stream.position += bytesWritten;
        try {
          if (stream.path && FS.trackingDelegate['onWriteToFile']) FS.trackingDelegate['onWriteToFile'](stream.path);
        } catch(e) {
          err("FS.trackingDelegate['onWriteToFile']('"+stream.path+"') threw an exception: " + e.message);
        }
        return bytesWritten;
      },allocate:function(stream, offset, length) {
        if (FS.isClosed(stream)) {
          throw new FS.ErrnoError(8);
        }
        if (offset < 0 || length <= 0) {
          throw new FS.ErrnoError(28);
        }
        if ((stream.flags & 2097155) === 0) {
          throw new FS.ErrnoError(8);
        }
        if (!FS.isFile(stream.node.mode) && !FS.isDir(stream.node.mode)) {
          throw new FS.ErrnoError(43);
        }
        if (!stream.stream_ops.allocate) {
          throw new FS.ErrnoError(138);
        }
        stream.stream_ops.allocate(stream, offset, length);
      },mmap:function(stream, address, length, position, prot, flags) {
        // User requests writing to file (prot & PROT_WRITE != 0).
        // Checking if we have permissions to write to the file unless
        // MAP_PRIVATE flag is set. According to POSIX spec it is possible
        // to write to file opened in read-only mode with MAP_PRIVATE flag,
        // as all modifications will be visible only in the memory of
        // the current process.
        if ((prot & 2) !== 0
            && (flags & 2) === 0
            && (stream.flags & 2097155) !== 2) {
          throw new FS.ErrnoError(2);
        }
        if ((stream.flags & 2097155) === 1) {
          throw new FS.ErrnoError(2);
        }
        if (!stream.stream_ops.mmap) {
          throw new FS.ErrnoError(43);
        }
        return stream.stream_ops.mmap(stream, address, length, position, prot, flags);
      },msync:function(stream, buffer, offset, length, mmapFlags) {
        if (!stream || !stream.stream_ops.msync) {
          return 0;
        }
        return stream.stream_ops.msync(stream, buffer, offset, length, mmapFlags);
      },munmap:function(stream) {
        return 0;
      },ioctl:function(stream, cmd, arg) {
        if (!stream.stream_ops.ioctl) {
          throw new FS.ErrnoError(59);
        }
        return stream.stream_ops.ioctl(stream, cmd, arg);
      },readFile:function(path, opts) {
        opts = opts || {};
        opts.flags = opts.flags || 0;
        opts.encoding = opts.encoding || 'binary';
        if (opts.encoding !== 'utf8' && opts.encoding !== 'binary') {
          throw new Error('Invalid encoding type "' + opts.encoding + '"');
        }
        var ret;
        var stream = FS.open(path, opts.flags);
        var stat = FS.stat(path);
        var length = stat.size;
        var buf = new Uint8Array(length);
        FS.read(stream, buf, 0, length, 0);
        if (opts.encoding === 'utf8') {
          ret = UTF8ArrayToString(buf, 0);
        } else if (opts.encoding === 'binary') {
          ret = buf;
        }
        FS.close(stream);
        return ret;
      },writeFile:function(path, data, opts) {
        opts = opts || {};
        opts.flags = opts.flags || 577;
        var stream = FS.open(path, opts.flags, opts.mode);
        if (typeof data === 'string') {
          var buf = new Uint8Array(lengthBytesUTF8(data)+1);
          var actualNumBytes = stringToUTF8Array(data, buf, 0, buf.length);
          FS.write(stream, buf, 0, actualNumBytes, undefined, opts.canOwn);
        } else if (ArrayBuffer.isView(data)) {
          FS.write(stream, data, 0, data.byteLength, undefined, opts.canOwn);
        } else {
          throw new Error('Unsupported data type');
        }
        FS.close(stream);
      },cwd:function() {
        return FS.currentPath;
      },chdir:function(path) {
        var lookup = FS.lookupPath(path, { follow: true });
        if (lookup.node === null) {
          throw new FS.ErrnoError(44);
        }
        if (!FS.isDir(lookup.node.mode)) {
          throw new FS.ErrnoError(54);
        }
        var errCode = FS.nodePermissions(lookup.node, 'x');
        if (errCode) {
          throw new FS.ErrnoError(errCode);
        }
        FS.currentPath = lookup.path;
      },createDefaultDirectories:function() {
        FS.mkdir('/tmp');
        FS.mkdir('/home');
        FS.mkdir('/home/web_user');
      },createDefaultDevices:function() {
        // create /dev
        FS.mkdir('/dev');
        // setup /dev/null
        FS.registerDevice(FS.makedev(1, 3), {
          read: function() { return 0; },
          write: function(stream, buffer, offset, length, pos) { return length; }
        });
        FS.mkdev('/dev/null', FS.makedev(1, 3));
        // setup /dev/tty and /dev/tty1
        // stderr needs to print output using err() rather than out()
        // so we register a second tty just for it.
        TTY.register(FS.makedev(5, 0), TTY.default_tty_ops);
        TTY.register(FS.makedev(6, 0), TTY.default_tty1_ops);
        FS.mkdev('/dev/tty', FS.makedev(5, 0));
        FS.mkdev('/dev/tty1', FS.makedev(6, 0));
        // setup /dev/[u]random
        var random_device = getRandomDevice();
        FS.createDevice('/dev', 'random', random_device);
        FS.createDevice('/dev', 'urandom', random_device);
        // we're not going to emulate the actual shm device,
        // just create the tmp dirs that reside in it commonly
        FS.mkdir('/dev/shm');
        FS.mkdir('/dev/shm/tmp');
      },createSpecialDirectories:function() {
        // create /proc/self/fd which allows /proc/self/fd/6 => readlink gives the
        // name of the stream for fd 6 (see test_unistd_ttyname)
        FS.mkdir('/proc');
        var proc_self = FS.mkdir('/proc/self');
        FS.mkdir('/proc/self/fd');
        FS.mount({
          mount: function() {
            var node = FS.createNode(proc_self, 'fd', 16384 | 511 /* 0777 */, 73);
            node.node_ops = {
              lookup: function(parent, name) {
                var fd = +name;
                var stream = FS.getStream(fd);
                if (!stream) throw new FS.ErrnoError(8);
                var ret = {
                  parent: null,
                  mount: { mountpoint: 'fake' },
                  node_ops: { readlink: function() { return stream.path } }
                };
                ret.parent = ret; // make it look like a simple root node
                return ret;
              }
            };
            return node;
          }
        }, {}, '/proc/self/fd');
      },createStandardStreams:function() {
        // TODO deprecate the old functionality of a single
        // input / output callback and that utilizes FS.createDevice
        // and instead require a unique set of stream ops
  
        // by default, we symlink the standard streams to the
        // default tty devices. however, if the standard streams
        // have been overwritten we create a unique device for
        // them instead.
        if (Module['stdin']) {
          FS.createDevice('/dev', 'stdin', Module['stdin']);
        } else {
          FS.symlink('/dev/tty', '/dev/stdin');
        }
        if (Module['stdout']) {
          FS.createDevice('/dev', 'stdout', null, Module['stdout']);
        } else {
          FS.symlink('/dev/tty', '/dev/stdout');
        }
        if (Module['stderr']) {
          FS.createDevice('/dev', 'stderr', null, Module['stderr']);
        } else {
          FS.symlink('/dev/tty1', '/dev/stderr');
        }
  
        // open default streams for the stdin, stdout and stderr devices
        var stdin = FS.open('/dev/stdin', 0);
        var stdout = FS.open('/dev/stdout', 1);
        var stderr = FS.open('/dev/stderr', 1);
      },ensureErrnoError:function() {
        if (FS.ErrnoError) return;
        FS.ErrnoError = /** @this{Object} */ function ErrnoError(errno, node) {
          this.node = node;
          this.setErrno = /** @this{Object} */ function(errno) {
            this.errno = errno;
          };
          this.setErrno(errno);
          this.message = 'FS error';
  
        };
        FS.ErrnoError.prototype = new Error();
        FS.ErrnoError.prototype.constructor = FS.ErrnoError;
        // Some errors may happen quite a bit, to avoid overhead we reuse them (and suffer a lack of stack info)
        [44].forEach(function(code) {
          FS.genericErrors[code] = new FS.ErrnoError(code);
          FS.genericErrors[code].stack = '<generic error, no stack>';
        });
      },staticInit:function() {
        FS.ensureErrnoError();
  
        FS.nameTable = new Array(4096);
  
        FS.mount(MEMFS, {}, '/');
  
        FS.createDefaultDirectories();
        FS.createDefaultDevices();
        FS.createSpecialDirectories();
  
        FS.filesystems = {
          'MEMFS': MEMFS,
        };
      },init:function(input, output, error) {
        FS.init.initialized = true;
  
        FS.ensureErrnoError();
  
        // Allow Module.stdin etc. to provide defaults, if none explicitly passed to us here
        Module['stdin'] = input || Module['stdin'];
        Module['stdout'] = output || Module['stdout'];
        Module['stderr'] = error || Module['stderr'];
  
        FS.createStandardStreams();
      },quit:function() {
        FS.init.initialized = false;
        // force-flush all streams, so we get musl std streams printed out
        var fflush = Module['_fflush'];
        if (fflush) fflush(0);
        // close all of our streams
        for (var i = 0; i < FS.streams.length; i++) {
          var stream = FS.streams[i];
          if (!stream) {
            continue;
          }
          FS.close(stream);
        }
      },getMode:function(canRead, canWrite) {
        var mode = 0;
        if (canRead) mode |= 292 | 73;
        if (canWrite) mode |= 146;
        return mode;
      },findObject:function(path, dontResolveLastLink) {
        var ret = FS.analyzePath(path, dontResolveLastLink);
        if (ret.exists) {
          return ret.object;
        } else {
          return null;
        }
      },analyzePath:function(path, dontResolveLastLink) {
        // operate from within the context of the symlink's target
        try {
          var lookup = FS.lookupPath(path, { follow: !dontResolveLastLink });
          path = lookup.path;
        } catch (e) {
        }
        var ret = {
          isRoot: false, exists: false, error: 0, name: null, path: null, object: null,
          parentExists: false, parentPath: null, parentObject: null
        };
        try {
          var lookup = FS.lookupPath(path, { parent: true });
          ret.parentExists = true;
          ret.parentPath = lookup.path;
          ret.parentObject = lookup.node;
          ret.name = PATH.basename(path);
          lookup = FS.lookupPath(path, { follow: !dontResolveLastLink });
          ret.exists = true;
          ret.path = lookup.path;
          ret.object = lookup.node;
          ret.name = lookup.node.name;
          ret.isRoot = lookup.path === '/';
        } catch (e) {
          ret.error = e.errno;
        };
        return ret;
      },createPath:function(parent, path, canRead, canWrite) {
        parent = typeof parent === 'string' ? parent : FS.getPath(parent);
        var parts = path.split('/').reverse();
        while (parts.length) {
          var part = parts.pop();
          if (!part) continue;
          var current = PATH.join2(parent, part);
          try {
            FS.mkdir(current);
          } catch (e) {
            // ignore EEXIST
          }
          parent = current;
        }
        return current;
      },createFile:function(parent, name, properties, canRead, canWrite) {
        var path = PATH.join2(typeof parent === 'string' ? parent : FS.getPath(parent), name);
        var mode = FS.getMode(canRead, canWrite);
        return FS.create(path, mode);
      },createDataFile:function(parent, name, data, canRead, canWrite, canOwn) {
        var path = name ? PATH.join2(typeof parent === 'string' ? parent : FS.getPath(parent), name) : parent;
        var mode = FS.getMode(canRead, canWrite);
        var node = FS.create(path, mode);
        if (data) {
          if (typeof data === 'string') {
            var arr = new Array(data.length);
            for (var i = 0, len = data.length; i < len; ++i) arr[i] = data.charCodeAt(i);
            data = arr;
          }
          // make sure we can write to the file
          FS.chmod(node, mode | 146);
          var stream = FS.open(node, 577);
          FS.write(stream, data, 0, data.length, 0, canOwn);
          FS.close(stream);
          FS.chmod(node, mode);
        }
        return node;
      },createDevice:function(parent, name, input, output) {
        var path = PATH.join2(typeof parent === 'string' ? parent : FS.getPath(parent), name);
        var mode = FS.getMode(!!input, !!output);
        if (!FS.createDevice.major) FS.createDevice.major = 64;
        var dev = FS.makedev(FS.createDevice.major++, 0);
        // Create a fake device that a set of stream ops to emulate
        // the old behavior.
        FS.registerDevice(dev, {
          open: function(stream) {
            stream.seekable = false;
          },
          close: function(stream) {
            // flush any pending line data
            if (output && output.buffer && output.buffer.length) {
              output(10);
            }
          },
          read: function(stream, buffer, offset, length, pos /* ignored */) {
            var bytesRead = 0;
            for (var i = 0; i < length; i++) {
              var result;
              try {
                result = input();
              } catch (e) {
                throw new FS.ErrnoError(29);
              }
              if (result === undefined && bytesRead === 0) {
                throw new FS.ErrnoError(6);
              }
              if (result === null || result === undefined) break;
              bytesRead++;
              buffer[offset+i] = result;
            }
            if (bytesRead) {
              stream.node.timestamp = Date.now();
            }
            return bytesRead;
          },
          write: function(stream, buffer, offset, length, pos) {
            for (var i = 0; i < length; i++) {
              try {
                output(buffer[offset+i]);
              } catch (e) {
                throw new FS.ErrnoError(29);
              }
            }
            if (length) {
              stream.node.timestamp = Date.now();
            }
            return i;
          }
        });
        return FS.mkdev(path, mode, dev);
      },forceLoadFile:function(obj) {
        if (obj.isDevice || obj.isFolder || obj.link || obj.contents) return true;
        if (typeof XMLHttpRequest !== 'undefined') {
          throw new Error("Lazy loading should have been performed (contents set) in createLazyFile, but it was not. Lazy loading only works in web workers. Use --embed-file or --preload-file in emcc on the main thread.");
        } else if (read_) {
          // Command-line.
          try {
            // WARNING: Can't read binary files in V8's d8 or tracemonkey's js, as
            //          read() will try to parse UTF8.
            obj.contents = intArrayFromString(read_(obj.url), true);
            obj.usedBytes = obj.contents.length;
          } catch (e) {
            throw new FS.ErrnoError(29);
          }
        } else {
          throw new Error('Cannot load without read() or XMLHttpRequest.');
        }
      },createLazyFile:function(parent, name, url, canRead, canWrite) {
        // Lazy chunked Uint8Array (implements get and length from Uint8Array). Actual getting is abstracted away for eventual reuse.
        /** @constructor */
        function LazyUint8Array() {
          this.lengthKnown = false;
          this.chunks = []; // Loaded chunks. Index is the chunk number
        }
        LazyUint8Array.prototype.get = /** @this{Object} */ function LazyUint8Array_get(idx) {
          if (idx > this.length-1 || idx < 0) {
            return undefined;
          }
          var chunkOffset = idx % this.chunkSize;
          var chunkNum = (idx / this.chunkSize)|0;
          return this.getter(chunkNum)[chunkOffset];
        };
        LazyUint8Array.prototype.setDataGetter = function LazyUint8Array_setDataGetter(getter) {
          this.getter = getter;
        };
        LazyUint8Array.prototype.cacheLength = function LazyUint8Array_cacheLength() {
          // Find length
          var xhr = new XMLHttpRequest();
          xhr.open('HEAD', url, false);
          xhr.send(null);
          if (!(xhr.status >= 200 && xhr.status < 300 || xhr.status === 304)) throw new Error("Couldn't load " + url + ". Status: " + xhr.status);
          var datalength = Number(xhr.getResponseHeader("Content-length"));
          var header;
          var hasByteServing = (header = xhr.getResponseHeader("Accept-Ranges")) && header === "bytes";
          var usesGzip = (header = xhr.getResponseHeader("Content-Encoding")) && header === "gzip";
  
          var chunkSize = 1024*1024; // Chunk size in bytes
  
          if (!hasByteServing) chunkSize = datalength;
  
          // Function to get a range from the remote URL.
          var doXHR = (function(from, to) {
            if (from > to) throw new Error("invalid range (" + from + ", " + to + ") or no bytes requested!");
            if (to > datalength-1) throw new Error("only " + datalength + " bytes available! programmer error!");
  
            // TODO: Use mozResponseArrayBuffer, responseStream, etc. if available.
            var xhr = new XMLHttpRequest();
            xhr.open('GET', url, false);
            if (datalength !== chunkSize) xhr.setRequestHeader("Range", "bytes=" + from + "-" + to);
  
            // Some hints to the browser that we want binary data.
            if (typeof Uint8Array != 'undefined') xhr.responseType = 'arraybuffer';
            if (xhr.overrideMimeType) {
              xhr.overrideMimeType('text/plain; charset=x-user-defined');
            }
  
            xhr.send(null);
            if (!(xhr.status >= 200 && xhr.status < 300 || xhr.status === 304)) throw new Error("Couldn't load " + url + ". Status: " + xhr.status);
            if (xhr.response !== undefined) {
              return new Uint8Array(/** @type{Array<number>} */(xhr.response || []));
            } else {
              return intArrayFromString(xhr.responseText || '', true);
            }
          });
          var lazyArray = this;
          lazyArray.setDataGetter(function(chunkNum) {
            var start = chunkNum * chunkSize;
            var end = (chunkNum+1) * chunkSize - 1; // including this byte
            end = Math.min(end, datalength-1); // if datalength-1 is selected, this is the last block
            if (typeof(lazyArray.chunks[chunkNum]) === "undefined") {
              lazyArray.chunks[chunkNum] = doXHR(start, end);
            }
            if (typeof(lazyArray.chunks[chunkNum]) === "undefined") throw new Error("doXHR failed!");
            return lazyArray.chunks[chunkNum];
          });
  
          if (usesGzip || !datalength) {
            // if the server uses gzip or doesn't supply the length, we have to download the whole file to get the (uncompressed) length
            chunkSize = datalength = 1; // this will force getter(0)/doXHR do download the whole file
            datalength = this.getter(0).length;
            chunkSize = datalength;
            out("LazyFiles on gzip forces download of the whole file when length is accessed");
          }
  
          this._length = datalength;
          this._chunkSize = chunkSize;
          this.lengthKnown = true;
        };
        if (typeof XMLHttpRequest !== 'undefined') {
          if (!ENVIRONMENT_IS_WORKER) throw 'Cannot do synchronous binary XHRs outside webworkers in modern browsers. Use --embed-file or --preload-file in emcc';
          var lazyArray = new LazyUint8Array();
          Object.defineProperties(lazyArray, {
            length: {
              get: /** @this{Object} */ function() {
                if (!this.lengthKnown) {
                  this.cacheLength();
                }
                return this._length;
              }
            },
            chunkSize: {
              get: /** @this{Object} */ function() {
                if (!this.lengthKnown) {
                  this.cacheLength();
                }
                return this._chunkSize;
              }
            }
          });
  
          var properties = { isDevice: false, contents: lazyArray };
        } else {
          var properties = { isDevice: false, url: url };
        }
  
        var node = FS.createFile(parent, name, properties, canRead, canWrite);
        // This is a total hack, but I want to get this lazy file code out of the
        // core of MEMFS. If we want to keep this lazy file concept I feel it should
        // be its own thin LAZYFS proxying calls to MEMFS.
        if (properties.contents) {
          node.contents = properties.contents;
        } else if (properties.url) {
          node.contents = null;
          node.url = properties.url;
        }
        // Add a function that defers querying the file size until it is asked the first time.
        Object.defineProperties(node, {
          usedBytes: {
            get: /** @this {FSNode} */ function() { return this.contents.length; }
          }
        });
        // override each stream op with one that tries to force load the lazy file first
        var stream_ops = {};
        var keys = Object.keys(node.stream_ops);
        keys.forEach(function(key) {
          var fn = node.stream_ops[key];
          stream_ops[key] = function forceLoadLazyFile() {
            FS.forceLoadFile(node);
            return fn.apply(null, arguments);
          };
        });
        // use a custom read function
        stream_ops.read = function stream_ops_read(stream, buffer, offset, length, position) {
          FS.forceLoadFile(node);
          var contents = stream.node.contents;
          if (position >= contents.length)
            return 0;
          var size = Math.min(contents.length - position, length);
          if (contents.slice) { // normal array
            for (var i = 0; i < size; i++) {
              buffer[offset + i] = contents[position + i];
            }
          } else {
            for (var i = 0; i < size; i++) { // LazyUint8Array from sync binary XHR
              buffer[offset + i] = contents.get(position + i);
            }
          }
          return size;
        };
        node.stream_ops = stream_ops;
        return node;
      },createPreloadedFile:function(parent, name, url, canRead, canWrite, onload, onerror, dontCreateFile, canOwn, preFinish) {
        Browser.init(); // XXX perhaps this method should move onto Browser?
        // TODO we should allow people to just pass in a complete filename instead
        // of parent and name being that we just join them anyways
        var fullname = name ? PATH_FS.resolve(PATH.join2(parent, name)) : parent;
        var dep = getUniqueRunDependency('cp ' + fullname); // might have several active requests for the same fullname
        function processData(byteArray) {
          function finish(byteArray) {
            if (preFinish) preFinish();
            if (!dontCreateFile) {
              FS.createDataFile(parent, name, byteArray, canRead, canWrite, canOwn);
            }
            if (onload) onload();
            removeRunDependency(dep);
          }
          var handled = false;
          Module['preloadPlugins'].forEach(function(plugin) {
            if (handled) return;
            if (plugin['canHandle'](fullname)) {
              plugin['handle'](byteArray, fullname, finish, function() {
                if (onerror) onerror();
                removeRunDependency(dep);
              });
              handled = true;
            }
          });
          if (!handled) finish(byteArray);
        }
        addRunDependency(dep);
        if (typeof url == 'string') {
          asyncLoad(url, function(byteArray) {
            processData(byteArray);
          }, onerror);
        } else {
          processData(url);
        }
      },indexedDB:function() {
        return window.indexedDB || window.mozIndexedDB || window.webkitIndexedDB || window.msIndexedDB;
      },DB_NAME:function() {
        return 'EM_FS_' + window.location.pathname;
      },DB_VERSION:20,DB_STORE_NAME:"FILE_DATA",saveFilesToDB:function(paths, onload, onerror) {
        onload = onload || function(){};
        onerror = onerror || function(){};
        var indexedDB = FS.indexedDB();
        try {
          var openRequest = indexedDB.open(FS.DB_NAME(), FS.DB_VERSION);
        } catch (e) {
          return onerror(e);
        }
        openRequest.onupgradeneeded = function openRequest_onupgradeneeded() {
          out('creating db');
          var db = openRequest.result;
          db.createObjectStore(FS.DB_STORE_NAME);
        };
        openRequest.onsuccess = function openRequest_onsuccess() {
          var db = openRequest.result;
          var transaction = db.transaction([FS.DB_STORE_NAME], 'readwrite');
          var files = transaction.objectStore(FS.DB_STORE_NAME);
          var ok = 0, fail = 0, total = paths.length;
          function finish() {
            if (fail == 0) onload(); else onerror();
          }
          paths.forEach(function(path) {
            var putRequest = files.put(FS.analyzePath(path).object.contents, path);
            putRequest.onsuccess = function putRequest_onsuccess() { ok++; if (ok + fail == total) finish() };
            putRequest.onerror = function putRequest_onerror() { fail++; if (ok + fail == total) finish() };
          });
          transaction.onerror = onerror;
        };
        openRequest.onerror = onerror;
      },loadFilesFromDB:function(paths, onload, onerror) {
        onload = onload || function(){};
        onerror = onerror || function(){};
        var indexedDB = FS.indexedDB();
        try {
          var openRequest = indexedDB.open(FS.DB_NAME(), FS.DB_VERSION);
        } catch (e) {
          return onerror(e);
        }
        openRequest.onupgradeneeded = onerror; // no database to load from
        openRequest.onsuccess = function openRequest_onsuccess() {
          var db = openRequest.result;
          try {
            var transaction = db.transaction([FS.DB_STORE_NAME], 'readonly');
          } catch(e) {
            onerror(e);
            return;
          }
          var files = transaction.objectStore(FS.DB_STORE_NAME);
          var ok = 0, fail = 0, total = paths.length;
          function finish() {
            if (fail == 0) onload(); else onerror();
          }
          paths.forEach(function(path) {
            var getRequest = files.get(path);
            getRequest.onsuccess = function getRequest_onsuccess() {
              if (FS.analyzePath(path).exists) {
                FS.unlink(path);
              }
              FS.createDataFile(PATH.dirname(path), PATH.basename(path), getRequest.result, true, true, true);
              ok++;
              if (ok + fail == total) finish();
            };
            getRequest.onerror = function getRequest_onerror() { fail++; if (ok + fail == total) finish() };
          });
          transaction.onerror = onerror;
        };
        openRequest.onerror = onerror;
      }};
  var SYSCALLS={mappings:{},DEFAULT_POLLMASK:5,umask:511,calculateAt:function(dirfd, path, allowEmpty) {
        if (path[0] === '/') {
          return path;
        }
        // relative path
        var dir;
        if (dirfd === -100) {
          dir = FS.cwd();
        } else {
          var dirstream = FS.getStream(dirfd);
          if (!dirstream) throw new FS.ErrnoError(8);
          dir = dirstream.path;
        }
        if (path.length == 0) {
          if (!allowEmpty) {
            throw new FS.ErrnoError(44);;
          }
          return dir;
        }
        return PATH.join2(dir, path);
      },doStat:function(func, path, buf) {
        try {
          var stat = func(path);
        } catch (e) {
          if (e && e.node && PATH.normalize(path) !== PATH.normalize(FS.getPath(e.node))) {
            // an error occurred while trying to look up the path; we should just report ENOTDIR
            return -54;
          }
          throw e;
        }
        HEAP32[((buf)>>2)] = stat.dev;
        HEAP32[(((buf)+(4))>>2)] = 0;
        HEAP32[(((buf)+(8))>>2)] = stat.ino;
        HEAP32[(((buf)+(12))>>2)] = stat.mode;
        HEAP32[(((buf)+(16))>>2)] = stat.nlink;
        HEAP32[(((buf)+(20))>>2)] = stat.uid;
        HEAP32[(((buf)+(24))>>2)] = stat.gid;
        HEAP32[(((buf)+(28))>>2)] = stat.rdev;
        HEAP32[(((buf)+(32))>>2)] = 0;
        (tempI64 = [stat.size>>>0,(tempDouble=stat.size,(+(Math.abs(tempDouble))) >= 1.0 ? (tempDouble > 0.0 ? ((Math.min((+(Math.floor((tempDouble)/4294967296.0))), 4294967295.0))|0)>>>0 : (~~((+(Math.ceil((tempDouble - +(((~~(tempDouble)))>>>0))/4294967296.0)))))>>>0) : 0)],HEAP32[(((buf)+(40))>>2)] = tempI64[0],HEAP32[(((buf)+(44))>>2)] = tempI64[1]);
        HEAP32[(((buf)+(48))>>2)] = 4096;
        HEAP32[(((buf)+(52))>>2)] = stat.blocks;
        HEAP32[(((buf)+(56))>>2)] = (stat.atime.getTime() / 1000)|0;
        HEAP32[(((buf)+(60))>>2)] = 0;
        HEAP32[(((buf)+(64))>>2)] = (stat.mtime.getTime() / 1000)|0;
        HEAP32[(((buf)+(68))>>2)] = 0;
        HEAP32[(((buf)+(72))>>2)] = (stat.ctime.getTime() / 1000)|0;
        HEAP32[(((buf)+(76))>>2)] = 0;
        (tempI64 = [stat.ino>>>0,(tempDouble=stat.ino,(+(Math.abs(tempDouble))) >= 1.0 ? (tempDouble > 0.0 ? ((Math.min((+(Math.floor((tempDouble)/4294967296.0))), 4294967295.0))|0)>>>0 : (~~((+(Math.ceil((tempDouble - +(((~~(tempDouble)))>>>0))/4294967296.0)))))>>>0) : 0)],HEAP32[(((buf)+(80))>>2)] = tempI64[0],HEAP32[(((buf)+(84))>>2)] = tempI64[1]);
        return 0;
      },doMsync:function(addr, stream, len, flags, offset) {
        var buffer = HEAPU8.slice(addr, addr + len);
        FS.msync(stream, buffer, offset, len, flags);
      },doMkdir:function(path, mode) {
        // remove a trailing slash, if one - /a/b/ has basename of '', but
        // we want to create b in the context of this function
        path = PATH.normalize(path);
        if (path[path.length-1] === '/') path = path.substr(0, path.length-1);
        FS.mkdir(path, mode, 0);
        return 0;
      },doMknod:function(path, mode, dev) {
        // we don't want this in the JS API as it uses mknod to create all nodes.
        switch (mode & 61440) {
          case 32768:
          case 8192:
          case 24576:
          case 4096:
          case 49152:
            break;
          default: return -28;
        }
        FS.mknod(path, mode, dev);
        return 0;
      },doReadlink:function(path, buf, bufsize) {
        if (bufsize <= 0) return -28;
        var ret = FS.readlink(path);
  
        var len = Math.min(bufsize, lengthBytesUTF8(ret));
        var endChar = HEAP8[buf+len];
        stringToUTF8(ret, buf, bufsize+1);
        // readlink is one of the rare functions that write out a C string, but does never append a null to the output buffer(!)
        // stringToUTF8() always appends a null byte, so restore the character under the null byte after the write.
        HEAP8[buf+len] = endChar;
  
        return len;
      },doAccess:function(path, amode) {
        if (amode & ~7) {
          // need a valid mode
          return -28;
        }
        var node;
        var lookup = FS.lookupPath(path, { follow: true });
        node = lookup.node;
        if (!node) {
          return -44;
        }
        var perms = '';
        if (amode & 4) perms += 'r';
        if (amode & 2) perms += 'w';
        if (amode & 1) perms += 'x';
        if (perms /* otherwise, they've just passed F_OK */ && FS.nodePermissions(node, perms)) {
          return -2;
        }
        return 0;
      },doDup:function(path, flags, suggestFD) {
        var suggest = FS.getStream(suggestFD);
        if (suggest) FS.close(suggest);
        return FS.open(path, flags, 0, suggestFD, suggestFD).fd;
      },doReadv:function(stream, iov, iovcnt, offset) {
        var ret = 0;
        for (var i = 0; i < iovcnt; i++) {
          var ptr = HEAP32[(((iov)+(i*8))>>2)];
          var len = HEAP32[(((iov)+(i*8 + 4))>>2)];
          var curr = FS.read(stream, HEAP8,ptr, len, offset);
          if (curr < 0) return -1;
          ret += curr;
          if (curr < len) break; // nothing more to read
        }
        return ret;
      },doWritev:function(stream, iov, iovcnt, offset) {
        var ret = 0;
        for (var i = 0; i < iovcnt; i++) {
          var ptr = HEAP32[(((iov)+(i*8))>>2)];
          var len = HEAP32[(((iov)+(i*8 + 4))>>2)];
          var curr = FS.write(stream, HEAP8,ptr, len, offset);
          if (curr < 0) return -1;
          ret += curr;
        }
        return ret;
      },varargs:undefined,get:function() {
        SYSCALLS.varargs += 4;
        var ret = HEAP32[(((SYSCALLS.varargs)-(4))>>2)];
        return ret;
      },getStr:function(ptr) {
        var ret = UTF8ToString(ptr);
        return ret;
      },getStreamFromFD:function(fd) {
        var stream = FS.getStream(fd);
        if (!stream) throw new FS.ErrnoError(8);
        return stream;
      },get64:function(low, high) {
        return low;
      }};
  function ___sys_fcntl64(fd, cmd, varargs) {SYSCALLS.varargs = varargs;
  try {
  
      var stream = SYSCALLS.getStreamFromFD(fd);
      switch (cmd) {
        case 0: {
          var arg = SYSCALLS.get();
          if (arg < 0) {
            return -28;
          }
          var newStream;
          newStream = FS.open(stream.path, stream.flags, 0, arg);
          return newStream.fd;
        }
        case 1:
        case 2:
          return 0;  // FD_CLOEXEC makes no sense for a single process.
        case 3:
          return stream.flags;
        case 4: {
          var arg = SYSCALLS.get();
          stream.flags |= arg;
          return 0;
        }
        case 12:
        /* case 12: Currently in musl F_GETLK64 has same value as F_GETLK, so omitted to avoid duplicate case blocks. If that changes, uncomment this */ {
          
          var arg = SYSCALLS.get();
          var offset = 0;
          // We're always unlocked.
          HEAP16[(((arg)+(offset))>>1)] = 2;
          return 0;
        }
        case 13:
        case 14:
        /* case 13: Currently in musl F_SETLK64 has same value as F_SETLK, so omitted to avoid duplicate case blocks. If that changes, uncomment this */
        /* case 14: Currently in musl F_SETLKW64 has same value as F_SETLKW, so omitted to avoid duplicate case blocks. If that changes, uncomment this */
          
          
          return 0; // Pretend that the locking is successful.
        case 16:
        case 8:
          return -28; // These are for sockets. We don't have them fully implemented yet.
        case 9:
          // musl trusts getown return values, due to a bug where they must be, as they overlap with errors. just return -1 here, so fnctl() returns that, and we set errno ourselves.
          setErrNo(28);
          return -1;
        default: {
          return -28;
        }
      }
    } catch (e) {
    if (typeof FS === 'undefined' || !(e instanceof FS.ErrnoError)) abort(e);
    return -e.errno;
  }
  }

  function ___sys_ioctl(fd, op, varargs) {SYSCALLS.varargs = varargs;
  try {
  
      var stream = SYSCALLS.getStreamFromFD(fd);
      switch (op) {
        case 21509:
        case 21505: {
          if (!stream.tty) return -59;
          return 0;
        }
        case 21510:
        case 21511:
        case 21512:
        case 21506:
        case 21507:
        case 21508: {
          if (!stream.tty) return -59;
          return 0; // no-op, not actually adjusting terminal settings
        }
        case 21519: {
          if (!stream.tty) return -59;
          var argp = SYSCALLS.get();
          HEAP32[((argp)>>2)] = 0;
          return 0;
        }
        case 21520: {
          if (!stream.tty) return -59;
          return -28; // not supported
        }
        case 21531: {
          var argp = SYSCALLS.get();
          return FS.ioctl(stream, op, argp);
        }
        case 21523: {
          // TODO: in theory we should write to the winsize struct that gets
          // passed in, but for now musl doesn't read anything on it
          if (!stream.tty) return -59;
          return 0;
        }
        case 21524: {
          // TODO: technically, this ioctl call should change the window size.
          // but, since emscripten doesn't have any concept of a terminal window
          // yet, we'll just silently throw it away as we do TIOCGWINSZ
          if (!stream.tty) return -59;
          return 0;
        }
        default: abort('bad ioctl syscall ' + op);
      }
    } catch (e) {
    if (typeof FS === 'undefined' || !(e instanceof FS.ErrnoError)) abort(e);
    return -e.errno;
  }
  }

  function ___sys_open(path, flags, varargs) {SYSCALLS.varargs = varargs;
  try {
  
      var pathname = SYSCALLS.getStr(path);
      var mode = varargs ? SYSCALLS.get() : 0;
      var stream = FS.open(pathname, flags, mode);
      return stream.fd;
    } catch (e) {
    if (typeof FS === 'undefined' || !(e instanceof FS.ErrnoError)) abort(e);
    return -e.errno;
  }
  }

  function ___sys_stat64(path, buf) {try {
  
      path = SYSCALLS.getStr(path);
      return SYSCALLS.doStat(FS.stat, path, buf);
    } catch (e) {
    if (typeof FS === 'undefined' || !(e instanceof FS.ErrnoError)) abort(e);
    return -e.errno;
  }
  }

  var readAsmConstArgsArray=[];
  function readAsmConstArgs(sigPtr, buf) {
      readAsmConstArgsArray.length = 0;
      var ch;
      // Most arguments are i32s, so shift the buffer pointer so it is a plain
      // index into HEAP32.
      buf >>= 2;
      while (ch = HEAPU8[sigPtr++]) {
        // A double takes two 32-bit slots, and must also be aligned - the backend
        // will emit padding to avoid that.
        var double = ch < 105;
        if (double && (buf & 1)) buf++;
        readAsmConstArgsArray.push(double ? HEAPF64[buf++ >> 1] : HEAP32[buf]);
        ++buf;
      }
      return readAsmConstArgsArray;
    }
  function _emscripten_asm_const_int(code, sigPtr, argbuf) {
      var args = readAsmConstArgs(sigPtr, argbuf);
      return ASM_CONSTS[code].apply(null, args);
    }

  var JSEvents={inEventHandler:0,removeAllEventListeners:function() {
        for (var i = JSEvents.eventHandlers.length-1; i >= 0; --i) {
          JSEvents._removeHandler(i);
        }
        JSEvents.eventHandlers = [];
        JSEvents.deferredCalls = [];
      },registerRemoveEventListeners:function() {
        if (!JSEvents.removeEventListenersRegistered) {
          __ATEXIT__.push(JSEvents.removeAllEventListeners);
          JSEvents.removeEventListenersRegistered = true;
        }
      },deferredCalls:[],deferCall:function(targetFunction, precedence, argsList) {
        function arraysHaveEqualContent(arrA, arrB) {
          if (arrA.length != arrB.length) return false;
  
          for (var i in arrA) {
            if (arrA[i] != arrB[i]) return false;
          }
          return true;
        }
        // Test if the given call was already queued, and if so, don't add it again.
        for (var i in JSEvents.deferredCalls) {
          var call = JSEvents.deferredCalls[i];
          if (call.targetFunction == targetFunction && arraysHaveEqualContent(call.argsList, argsList)) {
            return;
          }
        }
        JSEvents.deferredCalls.push({
          targetFunction: targetFunction,
          precedence: precedence,
          argsList: argsList
        });
  
        JSEvents.deferredCalls.sort(function(x,y) { return x.precedence < y.precedence; });
      },removeDeferredCalls:function(targetFunction) {
        for (var i = 0; i < JSEvents.deferredCalls.length; ++i) {
          if (JSEvents.deferredCalls[i].targetFunction == targetFunction) {
            JSEvents.deferredCalls.splice(i, 1);
            --i;
          }
        }
      },canPerformEventHandlerRequests:function() {
        return JSEvents.inEventHandler && JSEvents.currentEventHandler.allowsDeferredCalls;
      },runDeferredCalls:function() {
        if (!JSEvents.canPerformEventHandlerRequests()) {
          return;
        }
        for (var i = 0; i < JSEvents.deferredCalls.length; ++i) {
          var call = JSEvents.deferredCalls[i];
          JSEvents.deferredCalls.splice(i, 1);
          --i;
          call.targetFunction.apply(null, call.argsList);
        }
      },eventHandlers:[],removeAllHandlersOnTarget:function(target, eventTypeString) {
        for (var i = 0; i < JSEvents.eventHandlers.length; ++i) {
          if (JSEvents.eventHandlers[i].target == target && 
            (!eventTypeString || eventTypeString == JSEvents.eventHandlers[i].eventTypeString)) {
             JSEvents._removeHandler(i--);
           }
        }
      },_removeHandler:function(i) {
        var h = JSEvents.eventHandlers[i];
        h.target.removeEventListener(h.eventTypeString, h.eventListenerFunc, h.useCapture);
        JSEvents.eventHandlers.splice(i, 1);
      },registerOrRemoveHandler:function(eventHandler) {
        var jsEventHandler = function jsEventHandler(event) {
          // Increment nesting count for the event handler.
          ++JSEvents.inEventHandler;
          JSEvents.currentEventHandler = eventHandler;
          // Process any old deferred calls the user has placed.
          JSEvents.runDeferredCalls();
          // Process the actual event, calls back to user C code handler.
          eventHandler.handlerFunc(event);
          // Process any new deferred calls that were placed right now from this event handler.
          JSEvents.runDeferredCalls();
          // Out of event handler - restore nesting count.
          --JSEvents.inEventHandler;
        };
        
        if (eventHandler.callbackfunc) {
          eventHandler.eventListenerFunc = jsEventHandler;
          eventHandler.target.addEventListener(eventHandler.eventTypeString, jsEventHandler, eventHandler.useCapture);
          JSEvents.eventHandlers.push(eventHandler);
          JSEvents.registerRemoveEventListeners();
        } else {
          for (var i = 0; i < JSEvents.eventHandlers.length; ++i) {
            if (JSEvents.eventHandlers[i].target == eventHandler.target
             && JSEvents.eventHandlers[i].eventTypeString == eventHandler.eventTypeString) {
               JSEvents._removeHandler(i--);
             }
          }
        }
      },getNodeNameForTarget:function(target) {
        if (!target) return '';
        if (target == window) return '#window';
        if (target == screen) return '#screen';
        return (target && target.nodeName) ? target.nodeName : '';
      },fullscreenEnabled:function() {
        return document.fullscreenEnabled
        // Safari 13.0.3 on macOS Catalina 10.15.1 still ships with prefixed webkitFullscreenEnabled.
        // TODO: If Safari at some point ships with unprefixed version, update the version check above.
        || document.webkitFullscreenEnabled
         ;
      }};
  
  function setLetterbox(element, topBottom, leftRight) {
        // Cannot use margin to specify letterboxes in FF or Chrome, since those ignore margins in fullscreen mode.
        element.style.paddingLeft = element.style.paddingRight = leftRight + 'px';
        element.style.paddingTop = element.style.paddingBottom = topBottom + 'px';
    }
  
  function hideEverythingExceptGivenElement(onlyVisibleElement) {
      var child = onlyVisibleElement;
      var parent = child.parentNode;
      var hiddenElements = [];
      while (child != document.body) {
        var children = parent.children;
        for (var i = 0; i < children.length; ++i) {
          if (children[i] != child) {
            hiddenElements.push({ node: children[i], displayState: children[i].style.display });
            children[i].style.display = 'none';
          }
        }
        child = parent;
        parent = parent.parentNode;
      }
      return hiddenElements;
    }
  
  var restoreOldWindowedStyle=null;
  
  function maybeCStringToJsString(cString) {
      // "cString > 2" checks if the input is a number, and isn't of the special
      // values we accept here, EMSCRIPTEN_EVENT_TARGET_* (which map to 0, 1, 2).
      // In other words, if cString > 2 then it's a pointer to a valid place in
      // memory, and points to a C string.
      return cString > 2 ? UTF8ToString(cString) : cString;
    }
  
  var specialHTMLTargets=[0, typeof document !== 'undefined' ? document : 0, typeof window !== 'undefined' ? window : 0];
  function findEventTarget(target) {
      target = maybeCStringToJsString(target);
      var domElement = specialHTMLTargets[target] || (typeof document !== 'undefined' ? document.querySelector(target) : undefined);
      return domElement;
    }
  function findCanvasEventTarget(target) { return findEventTarget(target); }
  function _emscripten_get_canvas_element_size(target, width, height) {
      var canvas = findCanvasEventTarget(target);
      if (!canvas) return -4;
      HEAP32[((width)>>2)] = canvas.width;
      HEAP32[((height)>>2)] = canvas.height;
    }
  function getCanvasElementSize(target) {
      var stackTop = stackSave();
      var w = stackAlloc(8);
      var h = w + 4;
  
      var targetInt = stackAlloc(target.id.length+1);
      stringToUTF8(target.id, targetInt, target.id.length+1);
      var ret = _emscripten_get_canvas_element_size(targetInt, w, h);
      var size = [HEAP32[((w)>>2)], HEAP32[((h)>>2)]];
      stackRestore(stackTop);
      return size;
    }
  
  function _emscripten_set_canvas_element_size(target, width, height) {
      var canvas = findCanvasEventTarget(target);
      if (!canvas) return -4;
      canvas.width = width;
      canvas.height = height;
      return 0;
    }
  function setCanvasElementSize(target, width, height) {
      if (!target.controlTransferredOffscreen) {
        target.width = width;
        target.height = height;
      } else {
        // This function is being called from high-level JavaScript code instead of asm.js/Wasm,
        // and it needs to synchronously proxy over to another thread, so marshal the string onto the heap to do the call.
        var stackTop = stackSave();
        var targetInt = stackAlloc(target.id.length+1);
        stringToUTF8(target.id, targetInt, target.id.length+1);
        _emscripten_set_canvas_element_size(targetInt, width, height);
        stackRestore(stackTop);
      }
    }
  function registerRestoreOldStyle(canvas) {
      var canvasSize = getCanvasElementSize(canvas);
      var oldWidth = canvasSize[0];
      var oldHeight = canvasSize[1];
      var oldCssWidth = canvas.style.width;
      var oldCssHeight = canvas.style.height;
      var oldBackgroundColor = canvas.style.backgroundColor; // Chrome reads color from here.
      var oldDocumentBackgroundColor = document.body.style.backgroundColor; // IE11 reads color from here.
      // Firefox always has black background color.
      var oldPaddingLeft = canvas.style.paddingLeft; // Chrome, FF, Safari
      var oldPaddingRight = canvas.style.paddingRight;
      var oldPaddingTop = canvas.style.paddingTop;
      var oldPaddingBottom = canvas.style.paddingBottom;
      var oldMarginLeft = canvas.style.marginLeft; // IE11
      var oldMarginRight = canvas.style.marginRight;
      var oldMarginTop = canvas.style.marginTop;
      var oldMarginBottom = canvas.style.marginBottom;
      var oldDocumentBodyMargin = document.body.style.margin;
      var oldDocumentOverflow = document.documentElement.style.overflow; // Chrome, Firefox
      var oldDocumentScroll = document.body.scroll; // IE
      var oldImageRendering = canvas.style.imageRendering;
  
      function restoreOldStyle() {
        var fullscreenElement = document.fullscreenElement
          || document.webkitFullscreenElement
          || document.msFullscreenElement
          ;
        if (!fullscreenElement) {
          document.removeEventListener('fullscreenchange', restoreOldStyle);
  
          // Unprefixed Fullscreen API shipped in Chromium 71 (https://bugs.chromium.org/p/chromium/issues/detail?id=383813)
          // As of Safari 13.0.3 on macOS Catalina 10.15.1 still ships with prefixed webkitfullscreenchange. TODO: revisit this check once Safari ships unprefixed version.
          document.removeEventListener('webkitfullscreenchange', restoreOldStyle);
  
          setCanvasElementSize(canvas, oldWidth, oldHeight);
  
          canvas.style.width = oldCssWidth;
          canvas.style.height = oldCssHeight;
          canvas.style.backgroundColor = oldBackgroundColor; // Chrome
          // IE11 hack: assigning 'undefined' or an empty string to document.body.style.backgroundColor has no effect, so first assign back the default color
          // before setting the undefined value. Setting undefined value is also important, or otherwise we would later treat that as something that the user
          // had explicitly set so subsequent fullscreen transitions would not set background color properly.
          if (!oldDocumentBackgroundColor) document.body.style.backgroundColor = 'white';
          document.body.style.backgroundColor = oldDocumentBackgroundColor; // IE11
          canvas.style.paddingLeft = oldPaddingLeft; // Chrome, FF, Safari
          canvas.style.paddingRight = oldPaddingRight;
          canvas.style.paddingTop = oldPaddingTop;
          canvas.style.paddingBottom = oldPaddingBottom;
          canvas.style.marginLeft = oldMarginLeft; // IE11
          canvas.style.marginRight = oldMarginRight;
          canvas.style.marginTop = oldMarginTop;
          canvas.style.marginBottom = oldMarginBottom;
          document.body.style.margin = oldDocumentBodyMargin;
          document.documentElement.style.overflow = oldDocumentOverflow; // Chrome, Firefox
          document.body.scroll = oldDocumentScroll; // IE
          canvas.style.imageRendering = oldImageRendering;
          if (canvas.GLctxObject) canvas.GLctxObject.GLctx.viewport(0, 0, oldWidth, oldHeight);
  
          if (currentFullscreenStrategy.canvasResizedCallback) {
            (function(a1, a2, a3) { return dynCall_iiii.apply(null, [currentFullscreenStrategy.canvasResizedCallback, a1, a2, a3]); })(37, 0, currentFullscreenStrategy.canvasResizedCallbackUserData);
          }
        }
      }
      document.addEventListener('fullscreenchange', restoreOldStyle);
      // Unprefixed Fullscreen API shipped in Chromium 71 (https://bugs.chromium.org/p/chromium/issues/detail?id=383813)
      // As of Safari 13.0.3 on macOS Catalina 10.15.1 still ships with prefixed webkitfullscreenchange. TODO: revisit this check once Safari ships unprefixed version.
      document.addEventListener('webkitfullscreenchange', restoreOldStyle);
      return restoreOldStyle;
    }
  
  function restoreHiddenElements(hiddenElements) {
      for (var i = 0; i < hiddenElements.length; ++i) {
        hiddenElements[i].node.style.display = hiddenElements[i].displayState;
      }
    }
  
  var currentFullscreenStrategy={};
  
  /** @suppress {checkTypes} */
  function jstoi_q(str) {
      return parseInt(str);
    }
  function softFullscreenResizeWebGLRenderTarget() {
      var dpr = devicePixelRatio;
      var inHiDPIFullscreenMode = currentFullscreenStrategy.canvasResolutionScaleMode == 2;
      var inAspectRatioFixedFullscreenMode = currentFullscreenStrategy.scaleMode == 2;
      var inPixelPerfectFullscreenMode = currentFullscreenStrategy.canvasResolutionScaleMode != 0;
      var inCenteredWithoutScalingFullscreenMode = currentFullscreenStrategy.scaleMode == 3;
      var screenWidth = inHiDPIFullscreenMode ? Math.round(innerWidth*dpr) : innerWidth;
      var screenHeight = inHiDPIFullscreenMode ? Math.round(innerHeight*dpr) : innerHeight;
      var w = screenWidth;
      var h = screenHeight;
      var canvas = currentFullscreenStrategy.target;
      var canvasSize = getCanvasElementSize(canvas);
      var x = canvasSize[0];
      var y = canvasSize[1];
      var topMargin;
  
      if (inAspectRatioFixedFullscreenMode) {
        if (w*y < x*h) h = (w * y / x) | 0;
        else if (w*y > x*h) w = (h * x / y) | 0;
        topMargin = ((screenHeight - h) / 2) | 0;
      }
  
      if (inPixelPerfectFullscreenMode) {
        setCanvasElementSize(canvas, w, h);
        if (canvas.GLctxObject) canvas.GLctxObject.GLctx.viewport(0, 0, w, h);
      }
  
      // Back to CSS pixels.
      if (inHiDPIFullscreenMode) {
        topMargin /= dpr;
        w /= dpr;
        h /= dpr;
        // Round to nearest 4 digits of precision.
        w = Math.round(w*1e4)/1e4;
        h = Math.round(h*1e4)/1e4;
        topMargin = Math.round(topMargin*1e4)/1e4;
      }
  
      if (inCenteredWithoutScalingFullscreenMode) {
        var t = (innerHeight - jstoi_q(canvas.style.height)) / 2;
        var b = (innerWidth - jstoi_q(canvas.style.width)) / 2;
        setLetterbox(canvas, t, b);
      } else {
        canvas.style.width = w + 'px';
        canvas.style.height = h + 'px';
        var b = (innerWidth - w) / 2;
        setLetterbox(canvas, topMargin, b);
      }
  
      if (!inCenteredWithoutScalingFullscreenMode && currentFullscreenStrategy.canvasResizedCallback) {
        (function(a1, a2, a3) { return dynCall_iiii.apply(null, [currentFullscreenStrategy.canvasResizedCallback, a1, a2, a3]); })(37, 0, currentFullscreenStrategy.canvasResizedCallbackUserData);
      }
    }
  
  function getBoundingClientRect(e) {
      return specialHTMLTargets.indexOf(e) < 0 ? e.getBoundingClientRect() : {'left':0,'top':0};
    }
  function _JSEvents_resizeCanvasForFullscreen(target, strategy) {
      var restoreOldStyle = registerRestoreOldStyle(target);
      var cssWidth = strategy.softFullscreen ? innerWidth : screen.width;
      var cssHeight = strategy.softFullscreen ? innerHeight : screen.height;
      var rect = getBoundingClientRect(target);
      var windowedCssWidth = rect.width;
      var windowedCssHeight = rect.height;
      var canvasSize = getCanvasElementSize(target);
      var windowedRttWidth = canvasSize[0];
      var windowedRttHeight = canvasSize[1];
  
      if (strategy.scaleMode == 3) {
        setLetterbox(target, (cssHeight - windowedCssHeight) / 2, (cssWidth - windowedCssWidth) / 2);
        cssWidth = windowedCssWidth;
        cssHeight = windowedCssHeight;
      } else if (strategy.scaleMode == 2) {
        if (cssWidth*windowedRttHeight < windowedRttWidth*cssHeight) {
          var desiredCssHeight = windowedRttHeight * cssWidth / windowedRttWidth;
          setLetterbox(target, (cssHeight - desiredCssHeight) / 2, 0);
          cssHeight = desiredCssHeight;
        } else {
          var desiredCssWidth = windowedRttWidth * cssHeight / windowedRttHeight;
          setLetterbox(target, 0, (cssWidth - desiredCssWidth) / 2);
          cssWidth = desiredCssWidth;
        }
      }
  
      // If we are adding padding, must choose a background color or otherwise Chrome will give the
      // padding a default white color. Do it only if user has not customized their own background color.
      if (!target.style.backgroundColor) target.style.backgroundColor = 'black';
      // IE11 does the same, but requires the color to be set in the document body.
      if (!document.body.style.backgroundColor) document.body.style.backgroundColor = 'black'; // IE11
      // Firefox always shows black letterboxes independent of style color.
  
      target.style.width = cssWidth + 'px';
      target.style.height = cssHeight + 'px';
  
      if (strategy.filteringMode == 1) {
        target.style.imageRendering = 'optimizeSpeed';
        target.style.imageRendering = '-moz-crisp-edges';
        target.style.imageRendering = '-o-crisp-edges';
        target.style.imageRendering = '-webkit-optimize-contrast';
        target.style.imageRendering = 'optimize-contrast';
        target.style.imageRendering = 'crisp-edges';
        target.style.imageRendering = 'pixelated';
      }
  
      var dpiScale = (strategy.canvasResolutionScaleMode == 2) ? devicePixelRatio : 1;
      if (strategy.canvasResolutionScaleMode != 0) {
        var newWidth = (cssWidth * dpiScale)|0;
        var newHeight = (cssHeight * dpiScale)|0;
        setCanvasElementSize(target, newWidth, newHeight);
        if (target.GLctxObject) target.GLctxObject.GLctx.viewport(0, 0, newWidth, newHeight);
      }
      return restoreOldStyle;
    }
  function _emscripten_enter_soft_fullscreen(target, fullscreenStrategy) {
      target = findEventTarget(target);
      if (!target) return -4;
  
      var strategy = {
          scaleMode: HEAP32[((fullscreenStrategy)>>2)],
          canvasResolutionScaleMode: HEAP32[(((fullscreenStrategy)+(4))>>2)],
          filteringMode: HEAP32[(((fullscreenStrategy)+(8))>>2)],
          canvasResizedCallback: HEAP32[(((fullscreenStrategy)+(12))>>2)],
          canvasResizedCallbackUserData: HEAP32[(((fullscreenStrategy)+(16))>>2)],
          target: target,
          softFullscreen: true
      };
  
      var restoreOldStyle = _JSEvents_resizeCanvasForFullscreen(target, strategy);
  
      document.documentElement.style.overflow = 'hidden';  // Firefox, Chrome
      document.body.scroll = "no"; // IE11
      document.body.style.margin = '0px'; // Override default document margin area on all browsers.
  
      var hiddenElements = hideEverythingExceptGivenElement(target);
  
      function restoreWindowedState() {
        restoreOldStyle();
        restoreHiddenElements(hiddenElements);
        removeEventListener('resize', softFullscreenResizeWebGLRenderTarget);
        if (strategy.canvasResizedCallback) {
          (function(a1, a2, a3) { return dynCall_iiii.apply(null, [strategy.canvasResizedCallback, a1, a2, a3]); })(37, 0, strategy.canvasResizedCallbackUserData);
        }
        currentFullscreenStrategy = 0;
      }
      restoreOldWindowedStyle = restoreWindowedState;
      currentFullscreenStrategy = strategy;
      addEventListener('resize', softFullscreenResizeWebGLRenderTarget);
  
      // Inform the caller that the canvas size has changed.
      if (strategy.canvasResizedCallback) {
        (function(a1, a2, a3) { return dynCall_iiii.apply(null, [strategy.canvasResizedCallback, a1, a2, a3]); })(37, 0, strategy.canvasResizedCallbackUserData);
      }
  
      return 0;
    }

  function _JSEvents_requestFullscreen(target, strategy) {
      // EMSCRIPTEN_FULLSCREEN_SCALE_DEFAULT + EMSCRIPTEN_FULLSCREEN_CANVAS_SCALE_NONE is a mode where no extra logic is performed to the DOM elements.
      if (strategy.scaleMode != 0 || strategy.canvasResolutionScaleMode != 0) {
        _JSEvents_resizeCanvasForFullscreen(target, strategy);
      }
  
      if (target.requestFullscreen) {
        target.requestFullscreen();
      } else if (target.webkitRequestFullscreen) {
        target.webkitRequestFullscreen(Element.ALLOW_KEYBOARD_INPUT);
      } else {
        return JSEvents.fullscreenEnabled() ? -3 : -1;
      }
  
      currentFullscreenStrategy = strategy;
  
      if (strategy.canvasResizedCallback) {
        (function(a1, a2, a3) { return dynCall_iiii.apply(null, [strategy.canvasResizedCallback, a1, a2, a3]); })(37, 0, strategy.canvasResizedCallbackUserData);
      }
  
      return 0;
    }
  function _emscripten_exit_fullscreen() {
      if (!JSEvents.fullscreenEnabled()) return -1;
      // Make sure no queued up calls will fire after this.
      JSEvents.removeDeferredCalls(_JSEvents_requestFullscreen);
  
      var d = specialHTMLTargets[1];
      if (d.exitFullscreen) {
        d.fullscreenElement && d.exitFullscreen();
      } else if (d.webkitExitFullscreen) {
        d.webkitFullscreenElement && d.webkitExitFullscreen();
      } else {
        return -1;
      }
  
      return 0;
    }

  function _emscripten_get_element_css_size(target, width, height) {
      target = findEventTarget(target);
      if (!target) return -4;
  
      var rect = getBoundingClientRect(target);
      HEAPF64[((width)>>3)] = rect.width;
      HEAPF64[((height)>>3)] = rect.height;
  
      return 0;
    }

  function fillPointerlockChangeEventData(eventStruct) {
      var pointerLockElement = document.pointerLockElement || document.mozPointerLockElement || document.webkitPointerLockElement || document.msPointerLockElement;
      var isPointerlocked = !!pointerLockElement;
      /** @suppress {checkTypes} */
      HEAP32[((eventStruct)>>2)] = isPointerlocked;
      var nodeName = JSEvents.getNodeNameForTarget(pointerLockElement);
      var id = (pointerLockElement && pointerLockElement.id) ? pointerLockElement.id : '';
      stringToUTF8(nodeName, eventStruct + 4, 128);
      stringToUTF8(id, eventStruct + 132, 128);
    }
  /** @suppress {missingProperties} */
  function _emscripten_get_pointerlock_status(pointerlockStatus) {
      if (pointerlockStatus) fillPointerlockChangeEventData(pointerlockStatus);
      if (!document.body || (!document.body.requestPointerLock && !document.body.mozRequestPointerLock && !document.body.webkitRequestPointerLock && !document.body.msRequestPointerLock)) {
        return -1;
      }
      return 0;
    }

  function _emscripten_memcpy_big(dest, src, num) {
      HEAPU8.copyWithin(dest, src, src + num);
    }

  function _emscripten_performance_now() {
      return performance.now();
    }

  function abortOnCannotGrowMemory(requestedSize) {
      abort('OOM');
    }
  function _emscripten_resize_heap(requestedSize) {
      var oldSize = HEAPU8.length;
      requestedSize = requestedSize >>> 0;
      abortOnCannotGrowMemory(requestedSize);
    }


  function fillMouseEventData(eventStruct, e, target) {
      var idx = eventStruct >> 2;
      HEAP32[idx + 0] = e.screenX;
      HEAP32[idx + 1] = e.screenY;
      HEAP32[idx + 2] = e.clientX;
      HEAP32[idx + 3] = e.clientY;
      HEAP32[idx + 4] = e.ctrlKey;
      HEAP32[idx + 5] = e.shiftKey;
      HEAP32[idx + 6] = e.altKey;
      HEAP32[idx + 7] = e.metaKey;
      HEAP16[idx*2 + 16] = e.button;
      HEAP16[idx*2 + 17] = e.buttons;
  
      HEAP32[idx + 9] = e["movementX"]
        ;
  
      HEAP32[idx + 10] = e["movementY"]
        ;
  
      var rect = getBoundingClientRect(target);
      HEAP32[idx + 11] = e.clientX - rect.left;
      HEAP32[idx + 12] = e.clientY - rect.top;
  
    }
  function registerMouseEventCallback(target, userData, useCapture, callbackfunc, eventTypeId, eventTypeString, targetThread) {
      if (!JSEvents.mouseEvent) JSEvents.mouseEvent = _malloc( 64 );
      target = findEventTarget(target);
  
      var mouseEventHandlerFunc = function(ev) {
        var e = ev || event;
  
        // TODO: Make this access thread safe, or this could update live while app is reading it.
        fillMouseEventData(JSEvents.mouseEvent, e, target);
  
        if ((function(a1, a2, a3) { return dynCall_iiii.apply(null, [callbackfunc, a1, a2, a3]); })(eventTypeId, JSEvents.mouseEvent, userData)) e.preventDefault();
      };
  
      var eventHandler = {
        target: target,
        allowsDeferredCalls: eventTypeString != 'mousemove' && eventTypeString != 'mouseenter' && eventTypeString != 'mouseleave', // Mouse move events do not allow fullscreen/pointer lock requests to be handled in them!
        eventTypeString: eventTypeString,
        callbackfunc: callbackfunc,
        handlerFunc: mouseEventHandlerFunc,
        useCapture: useCapture
      };
      JSEvents.registerOrRemoveHandler(eventHandler);
    }
  function _emscripten_set_click_callback_on_thread(target, userData, useCapture, callbackfunc, targetThread) {
      registerMouseEventCallback(target, userData, useCapture, callbackfunc, 4, "click", targetThread);
      return 0;
    }

  function fillFullscreenChangeEventData(eventStruct) {
      var fullscreenElement = document.fullscreenElement || document.mozFullScreenElement || document.webkitFullscreenElement || document.msFullscreenElement;
      var isFullscreen = !!fullscreenElement;
      /** @suppress{checkTypes} */
      HEAP32[((eventStruct)>>2)] = isFullscreen;
      HEAP32[(((eventStruct)+(4))>>2)] = JSEvents.fullscreenEnabled();
      // If transitioning to fullscreen, report info about the element that is now fullscreen.
      // If transitioning to windowed mode, report info about the element that just was fullscreen.
      var reportedElement = isFullscreen ? fullscreenElement : JSEvents.previousFullscreenElement;
      var nodeName = JSEvents.getNodeNameForTarget(reportedElement);
      var id = (reportedElement && reportedElement.id) ? reportedElement.id : '';
      stringToUTF8(nodeName, eventStruct + 8, 128);
      stringToUTF8(id, eventStruct + 136, 128);
      HEAP32[(((eventStruct)+(264))>>2)] = reportedElement ? reportedElement.clientWidth : 0;
      HEAP32[(((eventStruct)+(268))>>2)] = reportedElement ? reportedElement.clientHeight : 0;
      HEAP32[(((eventStruct)+(272))>>2)] = screen.width;
      HEAP32[(((eventStruct)+(276))>>2)] = screen.height;
      if (isFullscreen) {
        JSEvents.previousFullscreenElement = fullscreenElement;
      }
    }
  function registerFullscreenChangeEventCallback(target, userData, useCapture, callbackfunc, eventTypeId, eventTypeString, targetThread) {
      if (!JSEvents.fullscreenChangeEvent) JSEvents.fullscreenChangeEvent = _malloc( 280 );
  
      var fullscreenChangeEventhandlerFunc = function(ev) {
        var e = ev || event;
  
        var fullscreenChangeEvent = JSEvents.fullscreenChangeEvent;
  
        fillFullscreenChangeEventData(fullscreenChangeEvent);
  
        if ((function(a1, a2, a3) { return dynCall_iiii.apply(null, [callbackfunc, a1, a2, a3]); })(eventTypeId, fullscreenChangeEvent, userData)) e.preventDefault();
      };
  
      var eventHandler = {
        target: target,
        eventTypeString: eventTypeString,
        callbackfunc: callbackfunc,
        handlerFunc: fullscreenChangeEventhandlerFunc,
        useCapture: useCapture
      };
      JSEvents.registerOrRemoveHandler(eventHandler);
    }
  function _emscripten_set_fullscreenchange_callback_on_thread(target, userData, useCapture, callbackfunc, targetThread) {
      if (!JSEvents.fullscreenEnabled()) return -1;
      target = findEventTarget(target);
      if (!target) return -4;
      registerFullscreenChangeEventCallback(target, userData, useCapture, callbackfunc, 19, "fullscreenchange", targetThread);
  
      // Unprefixed Fullscreen API shipped in Chromium 71 (https://bugs.chromium.org/p/chromium/issues/detail?id=383813)
      // As of Safari 13.0.3 on macOS Catalina 10.15.1 still ships with prefixed webkitfullscreenchange. TODO: revisit this check once Safari ships unprefixed version.
      registerFullscreenChangeEventCallback(target, userData, useCapture, callbackfunc, 19, "webkitfullscreenchange", targetThread);
  
      return 0;
    }

  function registerKeyEventCallback(target, userData, useCapture, callbackfunc, eventTypeId, eventTypeString, targetThread) {
      if (!JSEvents.keyEvent) JSEvents.keyEvent = _malloc( 164 );
  
      var keyEventHandlerFunc = function(e) {
  
        var keyEventData = JSEvents.keyEvent;
        var idx = keyEventData >> 2;
  
        HEAP32[idx + 0] = e.location;
        HEAP32[idx + 1] = e.ctrlKey;
        HEAP32[idx + 2] = e.shiftKey;
        HEAP32[idx + 3] = e.altKey;
        HEAP32[idx + 4] = e.metaKey;
        HEAP32[idx + 5] = e.repeat;
        HEAP32[idx + 6] = e.charCode;
        HEAP32[idx + 7] = e.keyCode;
        HEAP32[idx + 8] = e.which;
        stringToUTF8(e.key || '', keyEventData + 36, 32);
        stringToUTF8(e.code || '', keyEventData + 68, 32);
        stringToUTF8(e.char || '', keyEventData + 100, 32);
        stringToUTF8(e.locale || '', keyEventData + 132, 32);
  
        if ((function(a1, a2, a3) { return dynCall_iiii.apply(null, [callbackfunc, a1, a2, a3]); })(eventTypeId, keyEventData, userData)) e.preventDefault();
      };
  
      var eventHandler = {
        target: findEventTarget(target),
        allowsDeferredCalls: true,
        eventTypeString: eventTypeString,
        callbackfunc: callbackfunc,
        handlerFunc: keyEventHandlerFunc,
        useCapture: useCapture
      };
      JSEvents.registerOrRemoveHandler(eventHandler);
    }
  function _emscripten_set_keydown_callback_on_thread(target, userData, useCapture, callbackfunc, targetThread) {
      registerKeyEventCallback(target, userData, useCapture, callbackfunc, 2, "keydown", targetThread);
      return 0;
    }

  function _emscripten_set_keypress_callback_on_thread(target, userData, useCapture, callbackfunc, targetThread) {
      registerKeyEventCallback(target, userData, useCapture, callbackfunc, 1, "keypress", targetThread);
      return 0;
    }

  function _emscripten_set_keyup_callback_on_thread(target, userData, useCapture, callbackfunc, targetThread) {
      registerKeyEventCallback(target, userData, useCapture, callbackfunc, 3, "keyup", targetThread);
      return 0;
    }

  function callUserCallback(func, synchronous) {
      if (ABORT) {
        return;
      }
      // For synchronous calls, let any exceptions propagate, and don't let the runtime exit.
      if (synchronous) {
        func();
        return;
      }
      try {
        func();
      } catch (e) {
        if (e instanceof ExitStatus) {
          return;
        } else if (e !== 'unwind') {
          // And actual unexpected user-exectpion occured
          if (e && typeof e === 'object' && e.stack) err('exception thrown: ' + [e, e.stack]);
          throw e;
        }
      }
    }
  
  function safeSetTimeout(func, timeout) {
      
      return setTimeout(function() {
        
        callUserCallback(func);
      }, timeout);
    }
  
  function runtimeKeepalivePush() {
      runtimeKeepaliveCounter += 1;
    }
  
  function runtimeKeepalivePop() {
      runtimeKeepaliveCounter -= 1;
    }
  var Browser={mainLoop:{running:false,scheduler:null,method:"",currentlyRunningMainloop:0,func:null,arg:0,timingMode:0,timingValue:0,currentFrameNumber:0,queue:[],pause:function() {
          Browser.mainLoop.scheduler = null;
          // Incrementing this signals the previous main loop that it's now become old, and it must return.
          Browser.mainLoop.currentlyRunningMainloop++;
        },resume:function() {
          Browser.mainLoop.currentlyRunningMainloop++;
          var timingMode = Browser.mainLoop.timingMode;
          var timingValue = Browser.mainLoop.timingValue;
          var func = Browser.mainLoop.func;
          Browser.mainLoop.func = null;
          // do not set timing and call scheduler, we will do it on the next lines
          setMainLoop(func, 0, false, Browser.mainLoop.arg, true);
          _emscripten_set_main_loop_timing(timingMode, timingValue);
          Browser.mainLoop.scheduler();
        },updateStatus:function() {
          if (Module['setStatus']) {
            var message = Module['statusMessage'] || 'Please wait...';
            var remaining = Browser.mainLoop.remainingBlockers;
            var expected = Browser.mainLoop.expectedBlockers;
            if (remaining) {
              if (remaining < expected) {
                Module['setStatus'](message + ' (' + (expected - remaining) + '/' + expected + ')');
              } else {
                Module['setStatus'](message);
              }
            } else {
              Module['setStatus']('');
            }
          }
        },runIter:function(func) {
          if (ABORT) return;
          if (Module['preMainLoop']) {
            var preRet = Module['preMainLoop']();
            if (preRet === false) {
              return; // |return false| skips a frame
            }
          }
          callUserCallback(func);
          if (Module['postMainLoop']) Module['postMainLoop']();
        }},isFullscreen:false,pointerLock:false,moduleContextCreatedCallbacks:[],workers:[],init:function() {
        if (!Module["preloadPlugins"]) Module["preloadPlugins"] = []; // needs to exist even in workers
  
        if (Browser.initted) return;
        Browser.initted = true;
  
        try {
          new Blob();
          Browser.hasBlobConstructor = true;
        } catch(e) {
          Browser.hasBlobConstructor = false;
          console.log("warning: no blob constructor, cannot create blobs with mimetypes");
        }
        Browser.BlobBuilder = typeof MozBlobBuilder != "undefined" ? MozBlobBuilder : (typeof WebKitBlobBuilder != "undefined" ? WebKitBlobBuilder : (!Browser.hasBlobConstructor ? console.log("warning: no BlobBuilder") : null));
        Browser.URLObject = typeof window != "undefined" ? (window.URL ? window.URL : window.webkitURL) : undefined;
        if (!Module.noImageDecoding && typeof Browser.URLObject === 'undefined') {
          console.log("warning: Browser does not support creating object URLs. Built-in browser image decoding will not be available.");
          Module.noImageDecoding = true;
        }
  
        // Support for plugins that can process preloaded files. You can add more of these to
        // your app by creating and appending to Module.preloadPlugins.
        //
        // Each plugin is asked if it can handle a file based on the file's name. If it can,
        // it is given the file's raw data. When it is done, it calls a callback with the file's
        // (possibly modified) data. For example, a plugin might decompress a file, or it
        // might create some side data structure for use later (like an Image element, etc.).
  
        var imagePlugin = {};
        imagePlugin['canHandle'] = function imagePlugin_canHandle(name) {
          return !Module.noImageDecoding && /\.(jpg|jpeg|png|bmp)$/i.test(name);
        };
        imagePlugin['handle'] = function imagePlugin_handle(byteArray, name, onload, onerror) {
          var b = null;
          if (Browser.hasBlobConstructor) {
            try {
              b = new Blob([byteArray], { type: Browser.getMimetype(name) });
              if (b.size !== byteArray.length) { // Safari bug #118630
                // Safari's Blob can only take an ArrayBuffer
                b = new Blob([(new Uint8Array(byteArray)).buffer], { type: Browser.getMimetype(name) });
              }
            } catch(e) {
              warnOnce('Blob constructor present but fails: ' + e + '; falling back to blob builder');
            }
          }
          if (!b) {
            var bb = new Browser.BlobBuilder();
            bb.append((new Uint8Array(byteArray)).buffer); // we need to pass a buffer, and must copy the array to get the right data range
            b = bb.getBlob();
          }
          var url = Browser.URLObject.createObjectURL(b);
          var img = new Image();
          img.onload = function img_onload() {
            assert(img.complete, 'Image ' + name + ' could not be decoded');
            var canvas = document.createElement('canvas');
            canvas.width = img.width;
            canvas.height = img.height;
            var ctx = canvas.getContext('2d');
            ctx.drawImage(img, 0, 0);
            Module["preloadedImages"][name] = canvas;
            Browser.URLObject.revokeObjectURL(url);
            if (onload) onload(byteArray);
          };
          img.onerror = function img_onerror(event) {
            console.log('Image ' + url + ' could not be decoded');
            if (onerror) onerror();
          };
          img.src = url;
        };
        Module['preloadPlugins'].push(imagePlugin);
  
        var audioPlugin = {};
        audioPlugin['canHandle'] = function audioPlugin_canHandle(name) {
          return !Module.noAudioDecoding && name.substr(-4) in { '.ogg': 1, '.wav': 1, '.mp3': 1 };
        };
        audioPlugin['handle'] = function audioPlugin_handle(byteArray, name, onload, onerror) {
          var done = false;
          function finish(audio) {
            if (done) return;
            done = true;
            Module["preloadedAudios"][name] = audio;
            if (onload) onload(byteArray);
          }
          function fail() {
            if (done) return;
            done = true;
            Module["preloadedAudios"][name] = new Audio(); // empty shim
            if (onerror) onerror();
          }
          if (Browser.hasBlobConstructor) {
            try {
              var b = new Blob([byteArray], { type: Browser.getMimetype(name) });
            } catch(e) {
              return fail();
            }
            var url = Browser.URLObject.createObjectURL(b); // XXX we never revoke this!
            var audio = new Audio();
            audio.addEventListener('canplaythrough', function() { finish(audio) }, false); // use addEventListener due to chromium bug 124926
            audio.onerror = function audio_onerror(event) {
              if (done) return;
              console.log('warning: browser could not fully decode audio ' + name + ', trying slower base64 approach');
              function encode64(data) {
                var BASE = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';
                var PAD = '=';
                var ret = '';
                var leftchar = 0;
                var leftbits = 0;
                for (var i = 0; i < data.length; i++) {
                  leftchar = (leftchar << 8) | data[i];
                  leftbits += 8;
                  while (leftbits >= 6) {
                    var curr = (leftchar >> (leftbits-6)) & 0x3f;
                    leftbits -= 6;
                    ret += BASE[curr];
                  }
                }
                if (leftbits == 2) {
                  ret += BASE[(leftchar&3) << 4];
                  ret += PAD + PAD;
                } else if (leftbits == 4) {
                  ret += BASE[(leftchar&0xf) << 2];
                  ret += PAD;
                }
                return ret;
              }
              audio.src = 'data:audio/x-' + name.substr(-3) + ';base64,' + encode64(byteArray);
              finish(audio); // we don't wait for confirmation this worked - but it's worth trying
            };
            audio.src = url;
            // workaround for chrome bug 124926 - we do not always get oncanplaythrough or onerror
            safeSetTimeout(function() {
              finish(audio); // try to use it even though it is not necessarily ready to play
            }, 10000);
          } else {
            return fail();
          }
        };
        Module['preloadPlugins'].push(audioPlugin);
  
        // Canvas event setup
  
        function pointerLockChange() {
          Browser.pointerLock = document['pointerLockElement'] === Module['canvas'] ||
                                document['mozPointerLockElement'] === Module['canvas'] ||
                                document['webkitPointerLockElement'] === Module['canvas'] ||
                                document['msPointerLockElement'] === Module['canvas'];
        }
        var canvas = Module['canvas'];
        if (canvas) {
          // forced aspect ratio can be enabled by defining 'forcedAspectRatio' on Module
          // Module['forcedAspectRatio'] = 4 / 3;
  
          canvas.requestPointerLock = canvas['requestPointerLock'] ||
                                      canvas['mozRequestPointerLock'] ||
                                      canvas['webkitRequestPointerLock'] ||
                                      canvas['msRequestPointerLock'] ||
                                      function(){};
          canvas.exitPointerLock = document['exitPointerLock'] ||
                                   document['mozExitPointerLock'] ||
                                   document['webkitExitPointerLock'] ||
                                   document['msExitPointerLock'] ||
                                   function(){}; // no-op if function does not exist
          canvas.exitPointerLock = canvas.exitPointerLock.bind(document);
  
          document.addEventListener('pointerlockchange', pointerLockChange, false);
          document.addEventListener('mozpointerlockchange', pointerLockChange, false);
          document.addEventListener('webkitpointerlockchange', pointerLockChange, false);
          document.addEventListener('mspointerlockchange', pointerLockChange, false);
  
          if (Module['elementPointerLock']) {
            canvas.addEventListener("click", function(ev) {
              if (!Browser.pointerLock && Module['canvas'].requestPointerLock) {
                Module['canvas'].requestPointerLock();
                ev.preventDefault();
              }
            }, false);
          }
        }
      },createContext:function(canvas, useWebGL, setInModule, webGLContextAttributes) {
        if (useWebGL && Module.ctx && canvas == Module.canvas) return Module.ctx; // no need to recreate GL context if it's already been created for this canvas.
  
        var ctx;
        var contextHandle;
        if (useWebGL) {
          // For GLES2/desktop GL compatibility, adjust a few defaults to be different to WebGL defaults, so that they align better with the desktop defaults.
          var contextAttributes = {
            antialias: false,
            alpha: false,
            majorVersion: (typeof WebGL2RenderingContext !== 'undefined') ? 2 : 1,
          };
  
          if (webGLContextAttributes) {
            for (var attribute in webGLContextAttributes) {
              contextAttributes[attribute] = webGLContextAttributes[attribute];
            }
          }
  
          // This check of existence of GL is here to satisfy Closure compiler, which yells if variable GL is referenced below but GL object is not
          // actually compiled in because application is not doing any GL operations. TODO: Ideally if GL is not being used, this function
          // Browser.createContext() should not even be emitted.
          if (typeof GL !== 'undefined') {
            contextHandle = GL.createContext(canvas, contextAttributes);
            if (contextHandle) {
              ctx = GL.getContext(contextHandle).GLctx;
            }
          }
        } else {
          ctx = canvas.getContext('2d');
        }
  
        if (!ctx) return null;
  
        if (setInModule) {
          if (!useWebGL) assert(typeof GLctx === 'undefined', 'cannot set in module if GLctx is used, but we are a non-GL context that would replace it');
  
          Module.ctx = ctx;
          if (useWebGL) GL.makeContextCurrent(contextHandle);
          Module.useWebGL = useWebGL;
          Browser.moduleContextCreatedCallbacks.forEach(function(callback) { callback() });
          Browser.init();
        }
        return ctx;
      },destroyContext:function(canvas, useWebGL, setInModule) {},fullscreenHandlersInstalled:false,lockPointer:undefined,resizeCanvas:undefined,requestFullscreen:function(lockPointer, resizeCanvas) {
        Browser.lockPointer = lockPointer;
        Browser.resizeCanvas = resizeCanvas;
        if (typeof Browser.lockPointer === 'undefined') Browser.lockPointer = true;
        if (typeof Browser.resizeCanvas === 'undefined') Browser.resizeCanvas = false;
  
        var canvas = Module['canvas'];
        function fullscreenChange() {
          Browser.isFullscreen = false;
          var canvasContainer = canvas.parentNode;
          if ((document['fullscreenElement'] || document['mozFullScreenElement'] ||
               document['msFullscreenElement'] || document['webkitFullscreenElement'] ||
               document['webkitCurrentFullScreenElement']) === canvasContainer) {
            canvas.exitFullscreen = Browser.exitFullscreen;
            if (Browser.lockPointer) canvas.requestPointerLock();
            Browser.isFullscreen = true;
            if (Browser.resizeCanvas) {
              Browser.setFullscreenCanvasSize();
            } else {
              Browser.updateCanvasDimensions(canvas);
            }
          } else {
            // remove the full screen specific parent of the canvas again to restore the HTML structure from before going full screen
            canvasContainer.parentNode.insertBefore(canvas, canvasContainer);
            canvasContainer.parentNode.removeChild(canvasContainer);
  
            if (Browser.resizeCanvas) {
              Browser.setWindowedCanvasSize();
            } else {
              Browser.updateCanvasDimensions(canvas);
            }
          }
          if (Module['onFullScreen']) Module['onFullScreen'](Browser.isFullscreen);
          if (Module['onFullscreen']) Module['onFullscreen'](Browser.isFullscreen);
        }
  
        if (!Browser.fullscreenHandlersInstalled) {
          Browser.fullscreenHandlersInstalled = true;
          document.addEventListener('fullscreenchange', fullscreenChange, false);
          document.addEventListener('mozfullscreenchange', fullscreenChange, false);
          document.addEventListener('webkitfullscreenchange', fullscreenChange, false);
          document.addEventListener('MSFullscreenChange', fullscreenChange, false);
        }
  
        // create a new parent to ensure the canvas has no siblings. this allows browsers to optimize full screen performance when its parent is the full screen root
        var canvasContainer = document.createElement("div");
        canvas.parentNode.insertBefore(canvasContainer, canvas);
        canvasContainer.appendChild(canvas);
  
        // use parent of canvas as full screen root to allow aspect ratio correction (Firefox stretches the root to screen size)
        canvasContainer.requestFullscreen = canvasContainer['requestFullscreen'] ||
                                            canvasContainer['mozRequestFullScreen'] ||
                                            canvasContainer['msRequestFullscreen'] ||
                                           (canvasContainer['webkitRequestFullscreen'] ? function() { canvasContainer['webkitRequestFullscreen'](Element['ALLOW_KEYBOARD_INPUT']) } : null) ||
                                           (canvasContainer['webkitRequestFullScreen'] ? function() { canvasContainer['webkitRequestFullScreen'](Element['ALLOW_KEYBOARD_INPUT']) } : null);
  
        canvasContainer.requestFullscreen();
      },exitFullscreen:function() {
        // This is workaround for chrome. Trying to exit from fullscreen
        // not in fullscreen state will cause "TypeError: Document not active"
        // in chrome. See https://github.com/emscripten-core/emscripten/pull/8236
        if (!Browser.isFullscreen) {
          return false;
        }
  
        var CFS = document['exitFullscreen'] ||
                  document['cancelFullScreen'] ||
                  document['mozCancelFullScreen'] ||
                  document['msExitFullscreen'] ||
                  document['webkitCancelFullScreen'] ||
            (function() {});
        CFS.apply(document, []);
        return true;
      },nextRAF:0,fakeRequestAnimationFrame:function(func) {
        // try to keep 60fps between calls to here
        var now = Date.now();
        if (Browser.nextRAF === 0) {
          Browser.nextRAF = now + 1000/60;
        } else {
          while (now + 2 >= Browser.nextRAF) { // fudge a little, to avoid timer jitter causing us to do lots of delay:0
            Browser.nextRAF += 1000/60;
          }
        }
        var delay = Math.max(Browser.nextRAF - now, 0);
        setTimeout(func, delay);
      },requestAnimationFrame:function(func) {
        if (typeof requestAnimationFrame === 'function') {
          requestAnimationFrame(func);
          return;
        }
        var RAF = Browser.fakeRequestAnimationFrame;
        RAF(func);
      },safeSetTimeout:function(func) {
        // Legacy function, this is used by the SDL2 port so we need to keep it
        // around at least until that is updated.
        return safeSetTimeout(func);
      },safeRequestAnimationFrame:function(func) {
        
        return Browser.requestAnimationFrame(function() {
          
          callUserCallback(func);
        });
      },getMimetype:function(name) {
        return {
          'jpg': 'image/jpeg',
          'jpeg': 'image/jpeg',
          'png': 'image/png',
          'bmp': 'image/bmp',
          'ogg': 'audio/ogg',
          'wav': 'audio/wav',
          'mp3': 'audio/mpeg'
        }[name.substr(name.lastIndexOf('.')+1)];
      },getUserMedia:function(func) {
        if (!window.getUserMedia) {
          window.getUserMedia = navigator['getUserMedia'] ||
                                navigator['mozGetUserMedia'];
        }
        window.getUserMedia(func);
      },getMovementX:function(event) {
        return event['movementX'] ||
               event['mozMovementX'] ||
               event['webkitMovementX'] ||
               0;
      },getMovementY:function(event) {
        return event['movementY'] ||
               event['mozMovementY'] ||
               event['webkitMovementY'] ||
               0;
      },getMouseWheelDelta:function(event) {
        var delta = 0;
        switch (event.type) {
          case 'DOMMouseScroll':
            // 3 lines make up a step
            delta = event.detail / 3;
            break;
          case 'mousewheel':
            // 120 units make up a step
            delta = event.wheelDelta / 120;
            break;
          case 'wheel':
            delta = event.deltaY
            switch (event.deltaMode) {
              case 0:
                // DOM_DELTA_PIXEL: 100 pixels make up a step
                delta /= 100;
                break;
              case 1:
                // DOM_DELTA_LINE: 3 lines make up a step
                delta /= 3;
                break;
              case 2:
                // DOM_DELTA_PAGE: A page makes up 80 steps
                delta *= 80;
                break;
              default:
                throw 'unrecognized mouse wheel delta mode: ' + event.deltaMode;
            }
            break;
          default:
            throw 'unrecognized mouse wheel event: ' + event.type;
        }
        return delta;
      },mouseX:0,mouseY:0,mouseMovementX:0,mouseMovementY:0,touches:{},lastTouches:{},calculateMouseEvent:function(event) { // event should be mousemove, mousedown or mouseup
        if (Browser.pointerLock) {
          // When the pointer is locked, calculate the coordinates
          // based on the movement of the mouse.
          // Workaround for Firefox bug 764498
          if (event.type != 'mousemove' &&
              ('mozMovementX' in event)) {
            Browser.mouseMovementX = Browser.mouseMovementY = 0;
          } else {
            Browser.mouseMovementX = Browser.getMovementX(event);
            Browser.mouseMovementY = Browser.getMovementY(event);
          }
  
          // check if SDL is available
          if (typeof SDL != "undefined") {
            Browser.mouseX = SDL.mouseX + Browser.mouseMovementX;
            Browser.mouseY = SDL.mouseY + Browser.mouseMovementY;
          } else {
            // just add the mouse delta to the current absolut mouse position
            // FIXME: ideally this should be clamped against the canvas size and zero
            Browser.mouseX += Browser.mouseMovementX;
            Browser.mouseY += Browser.mouseMovementY;
          }
        } else {
          // Otherwise, calculate the movement based on the changes
          // in the coordinates.
          var rect = Module["canvas"].getBoundingClientRect();
          var cw = Module["canvas"].width;
          var ch = Module["canvas"].height;
  
          // Neither .scrollX or .pageXOffset are defined in a spec, but
          // we prefer .scrollX because it is currently in a spec draft.
          // (see: http://www.w3.org/TR/2013/WD-cssom-view-20131217/)
          var scrollX = ((typeof window.scrollX !== 'undefined') ? window.scrollX : window.pageXOffset);
          var scrollY = ((typeof window.scrollY !== 'undefined') ? window.scrollY : window.pageYOffset);
  
          if (event.type === 'touchstart' || event.type === 'touchend' || event.type === 'touchmove') {
            var touch = event.touch;
            if (touch === undefined) {
              return; // the "touch" property is only defined in SDL
  
            }
            var adjustedX = touch.pageX - (scrollX + rect.left);
            var adjustedY = touch.pageY - (scrollY + rect.top);
  
            adjustedX = adjustedX * (cw / rect.width);
            adjustedY = adjustedY * (ch / rect.height);
  
            var coords = { x: adjustedX, y: adjustedY };
  
            if (event.type === 'touchstart') {
              Browser.lastTouches[touch.identifier] = coords;
              Browser.touches[touch.identifier] = coords;
            } else if (event.type === 'touchend' || event.type === 'touchmove') {
              var last = Browser.touches[touch.identifier];
              if (!last) last = coords;
              Browser.lastTouches[touch.identifier] = last;
              Browser.touches[touch.identifier] = coords;
            }
            return;
          }
  
          var x = event.pageX - (scrollX + rect.left);
          var y = event.pageY - (scrollY + rect.top);
  
          // the canvas might be CSS-scaled compared to its backbuffer;
          // SDL-using content will want mouse coordinates in terms
          // of backbuffer units.
          x = x * (cw / rect.width);
          y = y * (ch / rect.height);
  
          Browser.mouseMovementX = x - Browser.mouseX;
          Browser.mouseMovementY = y - Browser.mouseY;
          Browser.mouseX = x;
          Browser.mouseY = y;
        }
      },resizeListeners:[],updateResizeListeners:function() {
        var canvas = Module['canvas'];
        Browser.resizeListeners.forEach(function(listener) {
          listener(canvas.width, canvas.height);
        });
      },setCanvasSize:function(width, height, noUpdates) {
        var canvas = Module['canvas'];
        Browser.updateCanvasDimensions(canvas, width, height);
        if (!noUpdates) Browser.updateResizeListeners();
      },windowedWidth:0,windowedHeight:0,setFullscreenCanvasSize:function() {
        // check if SDL is available
        if (typeof SDL != "undefined") {
          var flags = HEAPU32[((SDL.screen)>>2)];
          flags = flags | 0x00800000; // set SDL_FULLSCREEN flag
          HEAP32[((SDL.screen)>>2)] = flags
        }
        Browser.updateCanvasDimensions(Module['canvas']);
        Browser.updateResizeListeners();
      },setWindowedCanvasSize:function() {
        // check if SDL is available
        if (typeof SDL != "undefined") {
          var flags = HEAPU32[((SDL.screen)>>2)];
          flags = flags & ~0x00800000; // clear SDL_FULLSCREEN flag
          HEAP32[((SDL.screen)>>2)] = flags
        }
        Browser.updateCanvasDimensions(Module['canvas']);
        Browser.updateResizeListeners();
      },updateCanvasDimensions:function(canvas, wNative, hNative) {
        if (wNative && hNative) {
          canvas.widthNative = wNative;
          canvas.heightNative = hNative;
        } else {
          wNative = canvas.widthNative;
          hNative = canvas.heightNative;
        }
        var w = wNative;
        var h = hNative;
        if (Module['forcedAspectRatio'] && Module['forcedAspectRatio'] > 0) {
          if (w/h < Module['forcedAspectRatio']) {
            w = Math.round(h * Module['forcedAspectRatio']);
          } else {
            h = Math.round(w / Module['forcedAspectRatio']);
          }
        }
        if (((document['fullscreenElement'] || document['mozFullScreenElement'] ||
             document['msFullscreenElement'] || document['webkitFullscreenElement'] ||
             document['webkitCurrentFullScreenElement']) === canvas.parentNode) && (typeof screen != 'undefined')) {
           var factor = Math.min(screen.width / w, screen.height / h);
           w = Math.round(w * factor);
           h = Math.round(h * factor);
        }
        if (Browser.resizeCanvas) {
          if (canvas.width  != w) canvas.width  = w;
          if (canvas.height != h) canvas.height = h;
          if (typeof canvas.style != 'undefined') {
            canvas.style.removeProperty( "width");
            canvas.style.removeProperty("height");
          }
        } else {
          if (canvas.width  != wNative) canvas.width  = wNative;
          if (canvas.height != hNative) canvas.height = hNative;
          if (typeof canvas.style != 'undefined') {
            if (w != wNative || h != hNative) {
              canvas.style.setProperty( "width", w + "px", "important");
              canvas.style.setProperty("height", h + "px", "important");
            } else {
              canvas.style.removeProperty( "width");
              canvas.style.removeProperty("height");
            }
          }
        }
      }};
  function _emscripten_set_main_loop_timing(mode, value) {
      Browser.mainLoop.timingMode = mode;
      Browser.mainLoop.timingValue = value;
  
      if (!Browser.mainLoop.func) {
        return 1; // Return non-zero on failure, can't set timing mode when there is no main loop.
      }
  
      if (!Browser.mainLoop.running) {
        
        Browser.mainLoop.running = true;
      }
      if (mode == 0 /*EM_TIMING_SETTIMEOUT*/) {
        Browser.mainLoop.scheduler = function Browser_mainLoop_scheduler_setTimeout() {
          var timeUntilNextTick = Math.max(0, Browser.mainLoop.tickStartTime + value - _emscripten_get_now())|0;
          setTimeout(Browser.mainLoop.runner, timeUntilNextTick); // doing this each time means that on exception, we stop
        };
        Browser.mainLoop.method = 'timeout';
      } else if (mode == 1 /*EM_TIMING_RAF*/) {
        Browser.mainLoop.scheduler = function Browser_mainLoop_scheduler_rAF() {
          Browser.requestAnimationFrame(Browser.mainLoop.runner);
        };
        Browser.mainLoop.method = 'rAF';
      } else if (mode == 2 /*EM_TIMING_SETIMMEDIATE*/) {
        if (typeof setImmediate === 'undefined') {
          // Emulate setImmediate. (note: not a complete polyfill, we don't emulate clearImmediate() to keep code size to minimum, since not needed)
          var setImmediates = [];
          var emscriptenMainLoopMessageId = 'setimmediate';
          var Browser_setImmediate_messageHandler = function(event) {
            // When called in current thread or Worker, the main loop ID is structured slightly different to accommodate for --proxy-to-worker runtime listening to Worker events,
            // so check for both cases.
            if (event.data === emscriptenMainLoopMessageId || event.data.target === emscriptenMainLoopMessageId) {
              event.stopPropagation();
              setImmediates.shift()();
            }
          }
          addEventListener("message", Browser_setImmediate_messageHandler, true);
          setImmediate = /** @type{function(function(): ?, ...?): number} */(function Browser_emulated_setImmediate(func) {
            setImmediates.push(func);
            if (ENVIRONMENT_IS_WORKER) {
              if (Module['setImmediates'] === undefined) Module['setImmediates'] = [];
              Module['setImmediates'].push(func);
              postMessage({target: emscriptenMainLoopMessageId}); // In --proxy-to-worker, route the message via proxyClient.js
            } else postMessage(emscriptenMainLoopMessageId, "*"); // On the main thread, can just send the message to itself.
          })
        }
        Browser.mainLoop.scheduler = function Browser_mainLoop_scheduler_setImmediate() {
          setImmediate(Browser.mainLoop.runner);
        };
        Browser.mainLoop.method = 'immediate';
      }
      return 0;
    }
  
  var _emscripten_get_now;if (ENVIRONMENT_IS_NODE) {
    _emscripten_get_now = function() {
      var t = process['hrtime']();
      return t[0] * 1e3 + t[1] / 1e6;
    };
  } else _emscripten_get_now = function() { return performance.now(); }
  ;
  
  function _exit(status) {
      // void _exit(int status);
      // http://pubs.opengroup.org/onlinepubs/000095399/functions/exit.html
      exit(status);
    }
  function maybeExit() {
      if (!keepRuntimeAlive()) {
        try {
          _exit(EXITSTATUS);
        } catch (e) {
          if (e instanceof ExitStatus) {
            return;
          }
          throw e;
        }
      }
    }
  function setMainLoop(browserIterationFunc, fps, simulateInfiniteLoop, arg, noSetTiming) {
      assert(!Browser.mainLoop.func, 'emscripten_set_main_loop: there can only be one main loop function at once: call emscripten_cancel_main_loop to cancel the previous one before setting a new one with different parameters.');
  
      Browser.mainLoop.func = browserIterationFunc;
      Browser.mainLoop.arg = arg;
  
      var thisMainLoopId = Browser.mainLoop.currentlyRunningMainloop;
      function checkIsRunning() {
        if (thisMainLoopId < Browser.mainLoop.currentlyRunningMainloop) {
          
          maybeExit();
          return false;
        }
        return true;
      }
  
      // We create the loop runner here but it is not actually running until
      // _emscripten_set_main_loop_timing is called (which might happen a
      // later time).  This member signifies that the current runner has not
      // yet been started so that we can call runtimeKeepalivePush when it
      // gets it timing set for the first time.
      Browser.mainLoop.running = false;
      Browser.mainLoop.runner = function Browser_mainLoop_runner() {
        if (ABORT) return;
        if (Browser.mainLoop.queue.length > 0) {
          var start = Date.now();
          var blocker = Browser.mainLoop.queue.shift();
          blocker.func(blocker.arg);
          if (Browser.mainLoop.remainingBlockers) {
            var remaining = Browser.mainLoop.remainingBlockers;
            var next = remaining%1 == 0 ? remaining-1 : Math.floor(remaining);
            if (blocker.counted) {
              Browser.mainLoop.remainingBlockers = next;
            } else {
              // not counted, but move the progress along a tiny bit
              next = next + 0.5; // do not steal all the next one's progress
              Browser.mainLoop.remainingBlockers = (8*remaining + next)/9;
            }
          }
          console.log('main loop blocker "' + blocker.name + '" took ' + (Date.now() - start) + ' ms'); //, left: ' + Browser.mainLoop.remainingBlockers);
          Browser.mainLoop.updateStatus();
  
          // catches pause/resume main loop from blocker execution
          if (!checkIsRunning()) return;
  
          setTimeout(Browser.mainLoop.runner, 0);
          return;
        }
  
        // catch pauses from non-main loop sources
        if (!checkIsRunning()) return;
  
        // Implement very basic swap interval control
        Browser.mainLoop.currentFrameNumber = Browser.mainLoop.currentFrameNumber + 1 | 0;
        if (Browser.mainLoop.timingMode == 1/*EM_TIMING_RAF*/ && Browser.mainLoop.timingValue > 1 && Browser.mainLoop.currentFrameNumber % Browser.mainLoop.timingValue != 0) {
          // Not the scheduled time to render this frame - skip.
          Browser.mainLoop.scheduler();
          return;
        } else if (Browser.mainLoop.timingMode == 0/*EM_TIMING_SETTIMEOUT*/) {
          Browser.mainLoop.tickStartTime = _emscripten_get_now();
        }
  
        // Signal GL rendering layer that processing of a new frame is about to start. This helps it optimize
        // VBO double-buffering and reduce GPU stalls.
  
        Browser.mainLoop.runIter(browserIterationFunc);
  
        // catch pauses from the main loop itself
        if (!checkIsRunning()) return;
  
        // Queue new audio data. This is important to be right after the main loop invocation, so that we will immediately be able
        // to queue the newest produced audio samples.
        // TODO: Consider adding pre- and post- rAF callbacks so that GL.newRenderingFrameStarted() and SDL.audio.queueNewAudioData()
        //       do not need to be hardcoded into this function, but can be more generic.
        if (typeof SDL === 'object' && SDL.audio && SDL.audio.queueNewAudioData) SDL.audio.queueNewAudioData();
  
        Browser.mainLoop.scheduler();
      }
  
      if (!noSetTiming) {
        if (fps && fps > 0) _emscripten_set_main_loop_timing(0/*EM_TIMING_SETTIMEOUT*/, 1000.0 / fps);
        else _emscripten_set_main_loop_timing(1/*EM_TIMING_RAF*/, 1); // Do rAF by rendering each frame (no decimating)
  
        Browser.mainLoop.scheduler();
      }
  
      if (simulateInfiniteLoop) {
        throw 'unwind';
      }
    }
  function _emscripten_set_main_loop(func, fps, simulateInfiniteLoop) {
      var browserIterationFunc = (function() {  dynCall_v.call(null, func); });
      setMainLoop(browserIterationFunc, fps, simulateInfiniteLoop);
    }

  function _emscripten_set_mousedown_callback_on_thread(target, userData, useCapture, callbackfunc, targetThread) {
      registerMouseEventCallback(target, userData, useCapture, callbackfunc, 5, "mousedown", targetThread);
      return 0;
    }

  function _emscripten_set_mouseenter_callback_on_thread(target, userData, useCapture, callbackfunc, targetThread) {
      registerMouseEventCallback(target, userData, useCapture, callbackfunc, 33, "mouseenter", targetThread);
      return 0;
    }

  function _emscripten_set_mouseleave_callback_on_thread(target, userData, useCapture, callbackfunc, targetThread) {
      registerMouseEventCallback(target, userData, useCapture, callbackfunc, 34, "mouseleave", targetThread);
      return 0;
    }

  function _emscripten_set_mousemove_callback_on_thread(target, userData, useCapture, callbackfunc, targetThread) {
      registerMouseEventCallback(target, userData, useCapture, callbackfunc, 8, "mousemove", targetThread);
      return 0;
    }

  function _emscripten_set_mouseup_callback_on_thread(target, userData, useCapture, callbackfunc, targetThread) {
      registerMouseEventCallback(target, userData, useCapture, callbackfunc, 6, "mouseup", targetThread);
      return 0;
    }

  function registerPointerlockChangeEventCallback(target, userData, useCapture, callbackfunc, eventTypeId, eventTypeString, targetThread) {
      if (!JSEvents.pointerlockChangeEvent) JSEvents.pointerlockChangeEvent = _malloc( 260 );
  
      var pointerlockChangeEventHandlerFunc = function(ev) {
        var e = ev || event;
  
        var pointerlockChangeEvent = JSEvents.pointerlockChangeEvent;
        fillPointerlockChangeEventData(pointerlockChangeEvent);
  
        if ((function(a1, a2, a3) { return dynCall_iiii.apply(null, [callbackfunc, a1, a2, a3]); })(eventTypeId, pointerlockChangeEvent, userData)) e.preventDefault();
      };
  
      var eventHandler = {
        target: target,
        eventTypeString: eventTypeString,
        callbackfunc: callbackfunc,
        handlerFunc: pointerlockChangeEventHandlerFunc,
        useCapture: useCapture
      };
      JSEvents.registerOrRemoveHandler(eventHandler);
    }
  /** @suppress {missingProperties} */
  function _emscripten_set_pointerlockchange_callback_on_thread(target, userData, useCapture, callbackfunc, targetThread) {
      // TODO: Currently not supported in pthreads or in --proxy-to-worker mode. (In pthreads mode, document object is not defined)
      if (!document || !document.body || (!document.body.requestPointerLock && !document.body.mozRequestPointerLock && !document.body.webkitRequestPointerLock && !document.body.msRequestPointerLock)) {
        return -1;
      }
  
      target = findEventTarget(target);
      if (!target) return -4;
      registerPointerlockChangeEventCallback(target, userData, useCapture, callbackfunc, 20, "pointerlockchange", targetThread);
      registerPointerlockChangeEventCallback(target, userData, useCapture, callbackfunc, 20, "mozpointerlockchange", targetThread);
      registerPointerlockChangeEventCallback(target, userData, useCapture, callbackfunc, 20, "webkitpointerlockchange", targetThread);
      registerPointerlockChangeEventCallback(target, userData, useCapture, callbackfunc, 20, "mspointerlockchange", targetThread);
      return 0;
    }

  function registerUiEventCallback(target, userData, useCapture, callbackfunc, eventTypeId, eventTypeString, targetThread) {
      if (!JSEvents.uiEvent) JSEvents.uiEvent = _malloc( 36 );
  
      target = findEventTarget(target);
  
      var uiEventHandlerFunc = function(ev) {
        var e = ev || event;
        if (e.target != target) {
          // Never take ui events such as scroll via a 'bubbled' route, but always from the direct element that
          // was targeted. Otherwise e.g. if app logs a message in response to a page scroll, the Emscripten log
          // message box could cause to scroll, generating a new (bubbled) scroll message, causing a new log print,
          // causing a new scroll, etc..
          return;
        }
        var b = document.body; // Take document.body to a variable, Closure compiler does not outline access to it on its own.
        if (!b) {
          // During a page unload 'body' can be null, with "Cannot read property 'clientWidth' of null" being thrown
          return;
        }
        var uiEvent = JSEvents.uiEvent;
        HEAP32[((uiEvent)>>2)] = e.detail;
        HEAP32[(((uiEvent)+(4))>>2)] = b.clientWidth;
        HEAP32[(((uiEvent)+(8))>>2)] = b.clientHeight;
        HEAP32[(((uiEvent)+(12))>>2)] = innerWidth;
        HEAP32[(((uiEvent)+(16))>>2)] = innerHeight;
        HEAP32[(((uiEvent)+(20))>>2)] = outerWidth;
        HEAP32[(((uiEvent)+(24))>>2)] = outerHeight;
        HEAP32[(((uiEvent)+(28))>>2)] = pageXOffset;
        HEAP32[(((uiEvent)+(32))>>2)] = pageYOffset;
        if ((function(a1, a2, a3) { return dynCall_iiii.apply(null, [callbackfunc, a1, a2, a3]); })(eventTypeId, uiEvent, userData)) e.preventDefault();
      };
  
      var eventHandler = {
        target: target,
        eventTypeString: eventTypeString,
        callbackfunc: callbackfunc,
        handlerFunc: uiEventHandlerFunc,
        useCapture: useCapture
      };
      JSEvents.registerOrRemoveHandler(eventHandler);
    }
  function _emscripten_set_resize_callback_on_thread(target, userData, useCapture, callbackfunc, targetThread) {
      registerUiEventCallback(target, userData, useCapture, callbackfunc, 10, "resize", targetThread);
      return 0;
    }

  function registerWheelEventCallback(target, userData, useCapture, callbackfunc, eventTypeId, eventTypeString, targetThread) {
      if (!JSEvents.wheelEvent) JSEvents.wheelEvent = _malloc( 96 );
  
      // The DOM Level 3 events spec event 'wheel'
      var wheelHandlerFunc = function(ev) {
        var e = ev || event;
        var wheelEvent = JSEvents.wheelEvent;
        fillMouseEventData(wheelEvent, e, target);
        HEAPF64[(((wheelEvent)+(64))>>3)] = e["deltaX"];
        HEAPF64[(((wheelEvent)+(72))>>3)] = e["deltaY"];
        HEAPF64[(((wheelEvent)+(80))>>3)] = e["deltaZ"];
        HEAP32[(((wheelEvent)+(88))>>2)] = e["deltaMode"];
        if ((function(a1, a2, a3) { return dynCall_iiii.apply(null, [callbackfunc, a1, a2, a3]); })(eventTypeId, wheelEvent, userData)) e.preventDefault();
      };
  
      var eventHandler = {
        target: target,
        allowsDeferredCalls: true,
        eventTypeString: eventTypeString,
        callbackfunc: callbackfunc,
        handlerFunc: wheelHandlerFunc,
        useCapture: useCapture
      };
      JSEvents.registerOrRemoveHandler(eventHandler);
    }
  function _emscripten_set_wheel_callback_on_thread(target, userData, useCapture, callbackfunc, targetThread) {
      target = findEventTarget(target);
      if (typeof target.onwheel !== 'undefined') {
        registerWheelEventCallback(target, userData, useCapture, callbackfunc, 9, "wheel", targetThread);
        return 0;
      } else {
        return -1;
      }
    }

  function _emscripten_sleep(ms) {
      Asyncify.handleSleep(function(wakeUp) {
        safeSetTimeout(wakeUp, ms);
      });
    }

  function __webgl_enable_ANGLE_instanced_arrays(ctx) {
      // Extension available in WebGL 1 from Firefox 26 and Google Chrome 30 onwards. Core feature in WebGL 2.
      var ext = ctx.getExtension('ANGLE_instanced_arrays');
      if (ext) {
        ctx['vertexAttribDivisor'] = function(index, divisor) { ext['vertexAttribDivisorANGLE'](index, divisor); };
        ctx['drawArraysInstanced'] = function(mode, first, count, primcount) { ext['drawArraysInstancedANGLE'](mode, first, count, primcount); };
        ctx['drawElementsInstanced'] = function(mode, count, type, indices, primcount) { ext['drawElementsInstancedANGLE'](mode, count, type, indices, primcount); };
        return 1;
      }
    }
  
  function __webgl_enable_OES_vertex_array_object(ctx) {
      // Extension available in WebGL 1 from Firefox 25 and WebKit 536.28/desktop Safari 6.0.3 onwards. Core feature in WebGL 2.
      var ext = ctx.getExtension('OES_vertex_array_object');
      if (ext) {
        ctx['createVertexArray'] = function() { return ext['createVertexArrayOES'](); };
        ctx['deleteVertexArray'] = function(vao) { ext['deleteVertexArrayOES'](vao); };
        ctx['bindVertexArray'] = function(vao) { ext['bindVertexArrayOES'](vao); };
        ctx['isVertexArray'] = function(vao) { return ext['isVertexArrayOES'](vao); };
        return 1;
      }
    }
  
  function __webgl_enable_WEBGL_draw_buffers(ctx) {
      // Extension available in WebGL 1 from Firefox 28 onwards. Core feature in WebGL 2.
      var ext = ctx.getExtension('WEBGL_draw_buffers');
      if (ext) {
        ctx['drawBuffers'] = function(n, bufs) { ext['drawBuffersWEBGL'](n, bufs); };
        return 1;
      }
    }
  
  function __webgl_enable_WEBGL_draw_instanced_base_vertex_base_instance(ctx) {
      // Closure is expected to be allowed to minify the '.dibvbi' property, so not accessing it quoted.
      return !!(ctx.dibvbi = ctx.getExtension('WEBGL_draw_instanced_base_vertex_base_instance'));
    }
  
  function __webgl_enable_WEBGL_multi_draw_instanced_base_vertex_base_instance(ctx) {
      // Closure is expected to be allowed to minify the '.mdibvbi' property, so not accessing it quoted.
      return !!(ctx.mdibvbi = ctx.getExtension('WEBGL_multi_draw_instanced_base_vertex_base_instance'));
    }
  
  function __webgl_enable_WEBGL_multi_draw(ctx) {
      // Closure is expected to be allowed to minify the '.multiDrawWebgl' property, so not accessing it quoted.
      return !!(ctx.multiDrawWebgl = ctx.getExtension('WEBGL_multi_draw'));
    }
  var GL={counter:1,buffers:[],programs:[],framebuffers:[],renderbuffers:[],textures:[],shaders:[],vaos:[],contexts:[],offscreenCanvases:{},queries:[],samplers:[],transformFeedbacks:[],syncs:[],stringCache:{},stringiCache:{},unpackAlignment:4,recordError:function recordError(errorCode) {
        if (!GL.lastError) {
          GL.lastError = errorCode;
        }
      },getNewId:function(table) {
        var ret = GL.counter++;
        for (var i = table.length; i < ret; i++) {
          table[i] = null;
        }
        return ret;
      },getSource:function(shader, count, string, length) {
        var source = '';
        for (var i = 0; i < count; ++i) {
          var len = length ? HEAP32[(((length)+(i*4))>>2)] : -1;
          source += UTF8ToString(HEAP32[(((string)+(i*4))>>2)], len < 0 ? undefined : len);
        }
        return source;
      },createContext:function(canvas, webGLContextAttributes) {
  
        // BUG: Workaround Safari WebGL issue: After successfully acquiring WebGL context on a canvas,
        // calling .getContext() will always return that context independent of which 'webgl' or 'webgl2'
        // context version was passed. See https://bugs.webkit.org/show_bug.cgi?id=222758 and
        // https://github.com/emscripten-core/emscripten/issues/13295.
        // TODO: Once the bug is fixed and shipped in Safari, adjust the Safari version field in above check.
        if (!canvas.getContextSafariWebGL2Fixed) {
          canvas.getContextSafariWebGL2Fixed = canvas.getContext;
          canvas.getContext = function(ver, attrs) {
            var gl = canvas.getContextSafariWebGL2Fixed(ver, attrs);
            return ((ver == 'webgl') == (gl instanceof WebGLRenderingContext)) ? gl : null;
          }
        }
  
        var ctx = 
          (webGLContextAttributes.majorVersion > 1)
          ?
            canvas.getContext("webgl2", webGLContextAttributes)
          :
          (canvas.getContext("webgl", webGLContextAttributes)
            // https://caniuse.com/#feat=webgl
            );
  
        if (!ctx) return 0;
  
        var handle = GL.registerContext(ctx, webGLContextAttributes);
  
        return handle;
      },registerContext:function(ctx, webGLContextAttributes) {
        // without pthreads a context is just an integer ID
        var handle = GL.getNewId(GL.contexts);
  
        var context = {
          handle: handle,
          attributes: webGLContextAttributes,
          version: webGLContextAttributes.majorVersion,
          GLctx: ctx
        };
  
        // Store the created context object so that we can access the context given a canvas without having to pass the parameters again.
        if (ctx.canvas) ctx.canvas.GLctxObject = context;
        GL.contexts[handle] = context;
        if (typeof webGLContextAttributes.enableExtensionsByDefault === 'undefined' || webGLContextAttributes.enableExtensionsByDefault) {
          GL.initExtensions(context);
        }
  
        return handle;
      },makeContextCurrent:function(contextHandle) {
  
        GL.currentContext = GL.contexts[contextHandle]; // Active Emscripten GL layer context object.
        Module.ctx = GLctx = GL.currentContext && GL.currentContext.GLctx; // Active WebGL context object.
        return !(contextHandle && !GLctx);
      },getContext:function(contextHandle) {
        return GL.contexts[contextHandle];
      },deleteContext:function(contextHandle) {
        if (GL.currentContext === GL.contexts[contextHandle]) GL.currentContext = null;
        if (typeof JSEvents === 'object') JSEvents.removeAllHandlersOnTarget(GL.contexts[contextHandle].GLctx.canvas); // Release all JS event handlers on the DOM element that the GL context is associated with since the context is now deleted.
        if (GL.contexts[contextHandle] && GL.contexts[contextHandle].GLctx.canvas) GL.contexts[contextHandle].GLctx.canvas.GLctxObject = undefined; // Make sure the canvas object no longer refers to the context object so there are no GC surprises.
        GL.contexts[contextHandle] = null;
      },initExtensions:function(context) {
        // If this function is called without a specific context object, init the extensions of the currently active context.
        if (!context) context = GL.currentContext;
  
        if (context.initExtensionsDone) return;
        context.initExtensionsDone = true;
  
        var GLctx = context.GLctx;
  
        // Detect the presence of a few extensions manually, this GL interop layer itself will need to know if they exist.
  
        // Extensions that are only available in WebGL 1 (the calls will be no-ops if called on a WebGL 2 context active)
        __webgl_enable_ANGLE_instanced_arrays(GLctx);
        __webgl_enable_OES_vertex_array_object(GLctx);
        __webgl_enable_WEBGL_draw_buffers(GLctx);
        // Extensions that are available from WebGL >= 2 (no-op if called on a WebGL 1 context active)
        __webgl_enable_WEBGL_draw_instanced_base_vertex_base_instance(GLctx);
        __webgl_enable_WEBGL_multi_draw_instanced_base_vertex_base_instance(GLctx);
  
        // On WebGL 2, EXT_disjoint_timer_query is replaced with an alternative
        // that's based on core APIs, and exposes only the queryCounterEXT()
        // entrypoint.
        if (context.version >= 2) {
          GLctx.disjointTimerQueryExt = GLctx.getExtension("EXT_disjoint_timer_query_webgl2");
        }
  
        // However, Firefox exposes the WebGL 1 version on WebGL 2 as well and
        // thus we look for the WebGL 1 version again if the WebGL 2 version
        // isn't present. https://bugzilla.mozilla.org/show_bug.cgi?id=1328882
        if (context.version < 2 || !GLctx.disjointTimerQueryExt)
        {
          GLctx.disjointTimerQueryExt = GLctx.getExtension("EXT_disjoint_timer_query");
        }
  
        __webgl_enable_WEBGL_multi_draw(GLctx);
  
        // .getSupportedExtensions() can return null if context is lost, so coerce to empty array.
        var exts = GLctx.getSupportedExtensions() || [];
        exts.forEach(function(ext) {
          // WEBGL_lose_context, WEBGL_debug_renderer_info and WEBGL_debug_shaders are not enabled by default.
          if (!ext.includes('lose_context') && !ext.includes('debug')) {
            // Call .getExtension() to enable that extension permanently.
            GLctx.getExtension(ext);
          }
        });
      }};
  
  var __emscripten_webgl_power_preferences=['default', 'low-power', 'high-performance'];
  function _emscripten_webgl_do_create_context(target, attributes) {
      var a = attributes >> 2;
      var powerPreference = HEAP32[a + (24>>2)];
      var contextAttributes = {
        'alpha': !!HEAP32[a + (0>>2)],
        'depth': !!HEAP32[a + (4>>2)],
        'stencil': !!HEAP32[a + (8>>2)],
        'antialias': !!HEAP32[a + (12>>2)],
        'premultipliedAlpha': !!HEAP32[a + (16>>2)],
        'preserveDrawingBuffer': !!HEAP32[a + (20>>2)],
        'powerPreference': __emscripten_webgl_power_preferences[powerPreference],
        'failIfMajorPerformanceCaveat': !!HEAP32[a + (28>>2)],
        // The following are not predefined WebGL context attributes in the WebGL specification, so the property names can be minified by Closure.
        majorVersion: HEAP32[a + (32>>2)],
        minorVersion: HEAP32[a + (36>>2)],
        enableExtensionsByDefault: HEAP32[a + (40>>2)],
        explicitSwapControl: HEAP32[a + (44>>2)],
        proxyContextToMainThread: HEAP32[a + (48>>2)],
        renderViaOffscreenBackBuffer: HEAP32[a + (52>>2)]
      };
  
      var canvas = findCanvasEventTarget(target);
  
      if (!canvas) {
        return 0;
      }
  
      if (contextAttributes.explicitSwapControl) {
        return 0;
      }
  
      var contextHandle = GL.createContext(canvas, contextAttributes);
      return contextHandle;
    }
  function _emscripten_webgl_create_context(a0,a1
  ) {
  return _emscripten_webgl_do_create_context(a0,a1);
  }

  function _emscripten_webgl_init_context_attributes(attributes) {
      var a = attributes >> 2;
      for (var i = 0; i < (56>>2); ++i) {
        HEAP32[a+i] = 0;
      }
  
      HEAP32[a + (0>>2)] =
      HEAP32[a + (4>>2)] = 
      HEAP32[a + (12>>2)] = 
      HEAP32[a + (16>>2)] = 
      HEAP32[a + (32>>2)] = 
      HEAP32[a + (40>>2)] = 1;
  
    }

  function _emscripten_webgl_make_context_current(contextHandle) {
      var success = GL.makeContextCurrent(contextHandle);
      return success ? 0 : -5;
    }

  function _fd_close(fd) {try {
  
      var stream = SYSCALLS.getStreamFromFD(fd);
      FS.close(stream);
      return 0;
    } catch (e) {
    if (typeof FS === 'undefined' || !(e instanceof FS.ErrnoError)) abort(e);
    return e.errno;
  }
  }

  function _fd_read(fd, iov, iovcnt, pnum) {try {
  
      var stream = SYSCALLS.getStreamFromFD(fd);
      var num = SYSCALLS.doReadv(stream, iov, iovcnt);
      HEAP32[((pnum)>>2)] = num
      return 0;
    } catch (e) {
    if (typeof FS === 'undefined' || !(e instanceof FS.ErrnoError)) abort(e);
    return e.errno;
  }
  }

  function _fd_seek(fd, offset_low, offset_high, whence, newOffset) {try {
  
      
      var stream = SYSCALLS.getStreamFromFD(fd);
      var HIGH_OFFSET = 0x100000000; // 2^32
      // use an unsigned operator on low and shift high by 32-bits
      var offset = offset_high * HIGH_OFFSET + (offset_low >>> 0);
  
      var DOUBLE_LIMIT = 0x20000000000000; // 2^53
      // we also check for equality since DOUBLE_LIMIT + 1 == DOUBLE_LIMIT
      if (offset <= -DOUBLE_LIMIT || offset >= DOUBLE_LIMIT) {
        return -61;
      }
  
      FS.llseek(stream, offset, whence);
      (tempI64 = [stream.position>>>0,(tempDouble=stream.position,(+(Math.abs(tempDouble))) >= 1.0 ? (tempDouble > 0.0 ? ((Math.min((+(Math.floor((tempDouble)/4294967296.0))), 4294967295.0))|0)>>>0 : (~~((+(Math.ceil((tempDouble - +(((~~(tempDouble)))>>>0))/4294967296.0)))))>>>0) : 0)],HEAP32[((newOffset)>>2)] = tempI64[0],HEAP32[(((newOffset)+(4))>>2)] = tempI64[1]);
      if (stream.getdents && offset === 0 && whence === 0) stream.getdents = null; // reset readdir state
      return 0;
    } catch (e) {
    if (typeof FS === 'undefined' || !(e instanceof FS.ErrnoError)) abort(e);
    return e.errno;
  }
  }

  function _fd_write(fd, iov, iovcnt, pnum) {try {
  
      var stream = SYSCALLS.getStreamFromFD(fd);
      var num = SYSCALLS.doWritev(stream, iov, iovcnt);
      HEAP32[((pnum)>>2)] = num
      return 0;
    } catch (e) {
    if (typeof FS === 'undefined' || !(e instanceof FS.ErrnoError)) abort(e);
    return e.errno;
  }
  }

  function _glActiveTexture(x0) { GLctx['activeTexture'](x0) }

  function _glAttachShader(program, shader) {
      GLctx.attachShader(GL.programs[program], GL.shaders[shader]);
    }

  function _glBindBuffer(target, buffer) {
  
      if (target == 0x88EB /*GL_PIXEL_PACK_BUFFER*/) {
        // In WebGL 2 glReadPixels entry point, we need to use a different WebGL 2 API function call when a buffer is bound to
        // GL_PIXEL_PACK_BUFFER_BINDING point, so must keep track whether that binding point is non-null to know what is
        // the proper API function to call.
        GLctx.currentPixelPackBufferBinding = buffer;
      } else if (target == 0x88EC /*GL_PIXEL_UNPACK_BUFFER*/) {
        // In WebGL 2 gl(Compressed)Tex(Sub)Image[23]D entry points, we need to
        // use a different WebGL 2 API function call when a buffer is bound to
        // GL_PIXEL_UNPACK_BUFFER_BINDING point, so must keep track whether that
        // binding point is non-null to know what is the proper API function to
        // call.
        GLctx.currentPixelUnpackBufferBinding = buffer;
      }
      GLctx.bindBuffer(target, GL.buffers[buffer]);
    }

  function _glBindBufferRange(target, index, buffer, offset, ptrsize) {
      GLctx['bindBufferRange'](target, index, GL.buffers[buffer], offset, ptrsize);
    }

  function _glBindFramebuffer(target, framebuffer) {
  
      GLctx.bindFramebuffer(target, GL.framebuffers[framebuffer]);
  
    }

  function _glBindRenderbuffer(target, renderbuffer) {
      GLctx.bindRenderbuffer(target, GL.renderbuffers[renderbuffer]);
    }

  function _glBindTexture(target, texture) {
      GLctx.bindTexture(target, GL.textures[texture]);
    }

  function _glBindVertexArray(vao) {
      GLctx['bindVertexArray'](GL.vaos[vao]);
    }

  function _glBlendEquation(x0) { GLctx['blendEquation'](x0) }

  function _glBlendFunc(x0, x1) { GLctx['blendFunc'](x0, x1) }

  function _glBufferData(target, size, data, usage) {
  
      if (GL.currentContext.version >= 2) { // WebGL 2 provides new garbage-free entry points to call to WebGL. Use those always when possible.
        if (data) {
          GLctx.bufferData(target, HEAPU8, usage, data, size);
        } else {
          GLctx.bufferData(target, size, usage);
        }
      } else {
        // N.b. here first form specifies a heap subarray, second form an integer size, so the ?: code here is polymorphic. It is advised to avoid
        // randomly mixing both uses in calling code, to avoid any potential JS engine JIT issues.
        GLctx.bufferData(target, data ? HEAPU8.subarray(data, data+size) : size, usage);
      }
    }

  function _glBufferSubData(target, offset, size, data) {
      if (GL.currentContext.version >= 2) { // WebGL 2 provides new garbage-free entry points to call to WebGL. Use those always when possible.
        GLctx.bufferSubData(target, offset, HEAPU8, data, size);
        return;
      }
      GLctx.bufferSubData(target, offset, HEAPU8.subarray(data, data+size));
    }

  function _glClear(x0) { GLctx['clear'](x0) }

  function _glClearColor(x0, x1, x2, x3) { GLctx['clearColor'](x0, x1, x2, x3) }

  function _glCompileShader(shader) {
      GLctx.compileShader(GL.shaders[shader]);
    }

  function _glCreateProgram() {
      var id = GL.getNewId(GL.programs);
      var program = GLctx.createProgram();
      // Store additional information needed for each shader program:
      program.name = id;
      // Lazy cache results of glGetProgramiv(GL_ACTIVE_UNIFORM_MAX_LENGTH/GL_ACTIVE_ATTRIBUTE_MAX_LENGTH/GL_ACTIVE_UNIFORM_BLOCK_MAX_NAME_LENGTH)
      program.maxUniformLength = program.maxAttributeLength = program.maxUniformBlockNameLength = 0;
      program.uniformIdCounter = 1;
      GL.programs[id] = program;
      return id;
    }

  function _glCreateShader(shaderType) {
      var id = GL.getNewId(GL.shaders);
      GL.shaders[id] = GLctx.createShader(shaderType);
  
      return id;
    }

  function _glCullFace(x0) { GLctx['cullFace'](x0) }

  function _glDeleteProgram(id) {
      if (!id) return;
      var program = GL.programs[id];
      if (!program) { // glDeleteProgram actually signals an error when deleting a nonexisting object, unlike some other GL delete functions.
        GL.recordError(0x501 /* GL_INVALID_VALUE */);
        return;
      }
      GLctx.deleteProgram(program);
      program.name = 0;
      GL.programs[id] = null;
    }

  function _glDeleteShader(id) {
      if (!id) return;
      var shader = GL.shaders[id];
      if (!shader) { // glDeleteShader actually signals an error when deleting a nonexisting object, unlike some other GL delete functions.
        GL.recordError(0x501 /* GL_INVALID_VALUE */);
        return;
      }
      GLctx.deleteShader(shader);
      GL.shaders[id] = null;
    }

  function _glDepthFunc(x0) { GLctx['depthFunc'](x0) }

  function _glDisable(x0) { GLctx['disable'](x0) }

  function _glDrawArrays(mode, first, count) {
  
      GLctx.drawArrays(mode, first, count);
  
    }

  function _glDrawArraysInstanced(mode, first, count, primcount) {
      GLctx['drawArraysInstanced'](mode, first, count, primcount);
    }

  function _glDrawElements(mode, count, type, indices) {
  
      GLctx.drawElements(mode, count, type, indices);
  
    }

  function _glDrawElementsInstanced(mode, count, type, indices, primcount) {
      GLctx['drawElementsInstanced'](mode, count, type, indices, primcount);
    }

  function _glEnable(x0) { GLctx['enable'](x0) }

  function _glEnableVertexAttribArray(index) {
      GLctx.enableVertexAttribArray(index);
    }

  function _glFramebufferTexture2D(target, attachment, textarget, texture, level) {
      GLctx.framebufferTexture2D(target, attachment, textarget,
                                      GL.textures[texture], level);
    }

  function _glFrontFace(x0) { GLctx['frontFace'](x0) }

  function __glGenObject(n, buffers, createFunction, objectTable
      ) {
      for (var i = 0; i < n; i++) {
        var buffer = GLctx[createFunction]();
        var id = buffer && GL.getNewId(objectTable);
        if (buffer) {
          buffer.name = id;
          objectTable[id] = buffer;
        } else {
          GL.recordError(0x502 /* GL_INVALID_OPERATION */);
        }
        HEAP32[(((buffers)+(i*4))>>2)] = id;
      }
    }
  function _glGenBuffers(n, buffers) {
      __glGenObject(n, buffers, 'createBuffer', GL.buffers
        );
    }

  function _glGenFramebuffers(n, ids) {
      __glGenObject(n, ids, 'createFramebuffer', GL.framebuffers
        );
    }

  function _glGenTextures(n, textures) {
      __glGenObject(n, textures, 'createTexture', GL.textures
        );
    }

  function _glGenVertexArrays(n, arrays) {
      __glGenObject(n, arrays, 'createVertexArray', GL.vaos
        );
    }

  function _glGenerateMipmap(x0) { GLctx['generateMipmap'](x0) }

  function writeI53ToI64(ptr, num) {
      HEAPU32[ptr>>2] = num;
      HEAPU32[ptr+4>>2] = (num - HEAPU32[ptr>>2])/4294967296;
    }
  function emscriptenWebGLGet(name_, p, type) {
      // Guard against user passing a null pointer.
      // Note that GLES2 spec does not say anything about how passing a null pointer should be treated.
      // Testing on desktop core GL 3, the application crashes on glGetIntegerv to a null pointer, but
      // better to report an error instead of doing anything random.
      if (!p) {
        GL.recordError(0x501 /* GL_INVALID_VALUE */);
        return;
      }
      var ret = undefined;
      switch (name_) { // Handle a few trivial GLES values
        case 0x8DFA: // GL_SHADER_COMPILER
          ret = 1;
          break;
        case 0x8DF8: // GL_SHADER_BINARY_FORMATS
          if (type != 0 && type != 1) {
            GL.recordError(0x500); // GL_INVALID_ENUM
          }
          return; // Do not write anything to the out pointer, since no binary formats are supported.
        case 0x87FE: // GL_NUM_PROGRAM_BINARY_FORMATS
        case 0x8DF9: // GL_NUM_SHADER_BINARY_FORMATS
          ret = 0;
          break;
        case 0x86A2: // GL_NUM_COMPRESSED_TEXTURE_FORMATS
          // WebGL doesn't have GL_NUM_COMPRESSED_TEXTURE_FORMATS (it's obsolete since GL_COMPRESSED_TEXTURE_FORMATS returns a JS array that can be queried for length),
          // so implement it ourselves to allow C++ GLES2 code get the length.
          var formats = GLctx.getParameter(0x86A3 /*GL_COMPRESSED_TEXTURE_FORMATS*/);
          ret = formats ? formats.length : 0;
          break;
  
        case 0x821D: // GL_NUM_EXTENSIONS
          if (GL.currentContext.version < 2) {
            GL.recordError(0x502 /* GL_INVALID_OPERATION */); // Calling GLES3/WebGL2 function with a GLES2/WebGL1 context
            return;
          }
          // .getSupportedExtensions() can return null if context is lost, so coerce to empty array.
          var exts = GLctx.getSupportedExtensions() || [];
          ret = 2 * exts.length; // each extension is duplicated, first in unprefixed WebGL form, and then a second time with "GL_" prefix.
          break;
        case 0x821B: // GL_MAJOR_VERSION
        case 0x821C: // GL_MINOR_VERSION
          if (GL.currentContext.version < 2) {
            GL.recordError(0x500); // GL_INVALID_ENUM
            return;
          }
          ret = name_ == 0x821B ? 3 : 0; // return version 3.0
          break;
      }
  
      if (ret === undefined) {
        var result = GLctx.getParameter(name_);
        switch (typeof(result)) {
          case "number":
            ret = result;
            break;
          case "boolean":
            ret = result ? 1 : 0;
            break;
          case "string":
            GL.recordError(0x500); // GL_INVALID_ENUM
            return;
          case "object":
            if (result === null) {
              // null is a valid result for some (e.g., which buffer is bound - perhaps nothing is bound), but otherwise
              // can mean an invalid name_, which we need to report as an error
              switch (name_) {
                case 0x8894: // ARRAY_BUFFER_BINDING
                case 0x8B8D: // CURRENT_PROGRAM
                case 0x8895: // ELEMENT_ARRAY_BUFFER_BINDING
                case 0x8CA6: // FRAMEBUFFER_BINDING or DRAW_FRAMEBUFFER_BINDING
                case 0x8CA7: // RENDERBUFFER_BINDING
                case 0x8069: // TEXTURE_BINDING_2D
                case 0x85B5: // WebGL 2 GL_VERTEX_ARRAY_BINDING, or WebGL 1 extension OES_vertex_array_object GL_VERTEX_ARRAY_BINDING_OES
                case 0x8F36: // COPY_READ_BUFFER_BINDING or COPY_READ_BUFFER
                case 0x8F37: // COPY_WRITE_BUFFER_BINDING or COPY_WRITE_BUFFER
                case 0x88ED: // PIXEL_PACK_BUFFER_BINDING
                case 0x88EF: // PIXEL_UNPACK_BUFFER_BINDING
                case 0x8CAA: // READ_FRAMEBUFFER_BINDING
                case 0x8919: // SAMPLER_BINDING
                case 0x8C1D: // TEXTURE_BINDING_2D_ARRAY
                case 0x806A: // TEXTURE_BINDING_3D
                case 0x8E25: // TRANSFORM_FEEDBACK_BINDING
                case 0x8C8F: // TRANSFORM_FEEDBACK_BUFFER_BINDING
                case 0x8A28: // UNIFORM_BUFFER_BINDING
                case 0x8514: { // TEXTURE_BINDING_CUBE_MAP
                  ret = 0;
                  break;
                }
                default: {
                  GL.recordError(0x500); // GL_INVALID_ENUM
                  return;
                }
              }
            } else if (result instanceof Float32Array ||
                       result instanceof Uint32Array ||
                       result instanceof Int32Array ||
                       result instanceof Array) {
              for (var i = 0; i < result.length; ++i) {
                switch (type) {
                  case 0: HEAP32[(((p)+(i*4))>>2)] = result[i]; break;
                  case 2: HEAPF32[(((p)+(i*4))>>2)] = result[i]; break;
                  case 4: HEAP8[(((p)+(i))>>0)] = result[i] ? 1 : 0; break;
                }
              }
              return;
            } else {
              try {
                ret = result.name | 0;
              } catch(e) {
                GL.recordError(0x500); // GL_INVALID_ENUM
                err('GL_INVALID_ENUM in glGet' + type + 'v: Unknown object returned from WebGL getParameter(' + name_ + ')! (error: ' + e + ')');
                return;
              }
            }
            break;
          default:
            GL.recordError(0x500); // GL_INVALID_ENUM
            err('GL_INVALID_ENUM in glGet' + type + 'v: Native code calling glGet' + type + 'v(' + name_ + ') and it returns ' + result + ' of type ' + typeof(result) + '!');
            return;
        }
      }
  
      switch (type) {
        case 1: writeI53ToI64(p, ret); break;
        case 0: HEAP32[((p)>>2)] = ret; break;
        case 2:   HEAPF32[((p)>>2)] = ret; break;
        case 4: HEAP8[((p)>>0)] = ret ? 1 : 0; break;
      }
    }
  function _glGetIntegerv(name_, p) {
      emscriptenWebGLGet(name_, p, 0);
    }

  function _glGetProgramInfoLog(program, maxLength, length, infoLog) {
      var log = GLctx.getProgramInfoLog(GL.programs[program]);
      if (log === null) log = '(unknown error)';
      var numBytesWrittenExclNull = (maxLength > 0 && infoLog) ? stringToUTF8(log, infoLog, maxLength) : 0;
      if (length) HEAP32[((length)>>2)] = numBytesWrittenExclNull;
    }

  function _glGetProgramiv(program, pname, p) {
      if (!p) {
        // GLES2 specification does not specify how to behave if p is a null pointer. Since calling this function does not make sense
        // if p == null, issue a GL error to notify user about it.
        GL.recordError(0x501 /* GL_INVALID_VALUE */);
        return;
      }
  
      if (program >= GL.counter) {
        GL.recordError(0x501 /* GL_INVALID_VALUE */);
        return;
      }
  
      program = GL.programs[program];
  
      if (pname == 0x8B84) { // GL_INFO_LOG_LENGTH
        var log = GLctx.getProgramInfoLog(program);
        if (log === null) log = '(unknown error)';
        HEAP32[((p)>>2)] = log.length + 1;
      } else if (pname == 0x8B87 /* GL_ACTIVE_UNIFORM_MAX_LENGTH */) {
        if (!program.maxUniformLength) {
          for (var i = 0; i < GLctx.getProgramParameter(program, 0x8B86/*GL_ACTIVE_UNIFORMS*/); ++i) {
            program.maxUniformLength = Math.max(program.maxUniformLength, GLctx.getActiveUniform(program, i).name.length+1);
          }
        }
        HEAP32[((p)>>2)] = program.maxUniformLength;
      } else if (pname == 0x8B8A /* GL_ACTIVE_ATTRIBUTE_MAX_LENGTH */) {
        if (!program.maxAttributeLength) {
          for (var i = 0; i < GLctx.getProgramParameter(program, 0x8B89/*GL_ACTIVE_ATTRIBUTES*/); ++i) {
            program.maxAttributeLength = Math.max(program.maxAttributeLength, GLctx.getActiveAttrib(program, i).name.length+1);
          }
        }
        HEAP32[((p)>>2)] = program.maxAttributeLength;
      } else if (pname == 0x8A35 /* GL_ACTIVE_UNIFORM_BLOCK_MAX_NAME_LENGTH */) {
        if (!program.maxUniformBlockNameLength) {
          for (var i = 0; i < GLctx.getProgramParameter(program, 0x8A36/*GL_ACTIVE_UNIFORM_BLOCKS*/); ++i) {
            program.maxUniformBlockNameLength = Math.max(program.maxUniformBlockNameLength, GLctx.getActiveUniformBlockName(program, i).length+1);
          }
        }
        HEAP32[((p)>>2)] = program.maxUniformBlockNameLength;
      } else {
        HEAP32[((p)>>2)] = GLctx.getProgramParameter(program, pname);
      }
    }

  function _glGetShaderInfoLog(shader, maxLength, length, infoLog) {
      var log = GLctx.getShaderInfoLog(GL.shaders[shader]);
      if (log === null) log = '(unknown error)';
      var numBytesWrittenExclNull = (maxLength > 0 && infoLog) ? stringToUTF8(log, infoLog, maxLength) : 0;
      if (length) HEAP32[((length)>>2)] = numBytesWrittenExclNull;
    }

  function _glGetShaderiv(shader, pname, p) {
      if (!p) {
        // GLES2 specification does not specify how to behave if p is a null pointer. Since calling this function does not make sense
        // if p == null, issue a GL error to notify user about it.
        GL.recordError(0x501 /* GL_INVALID_VALUE */);
        return;
      }
      if (pname == 0x8B84) { // GL_INFO_LOG_LENGTH
        var log = GLctx.getShaderInfoLog(GL.shaders[shader]);
        if (log === null) log = '(unknown error)';
        // The GLES2 specification says that if the shader has an empty info log,
        // a value of 0 is returned. Otherwise the log has a null char appended.
        // (An empty string is falsey, so we can just check that instead of
        // looking at log.length.)
        var logLength = log ? log.length + 1 : 0;
        HEAP32[((p)>>2)] = logLength;
      } else if (pname == 0x8B88) { // GL_SHADER_SOURCE_LENGTH
        var source = GLctx.getShaderSource(GL.shaders[shader]);
        // source may be a null, or the empty string, both of which are falsey
        // values that we report a 0 length for.
        var sourceLength = source ? source.length + 1 : 0;
        HEAP32[((p)>>2)] = sourceLength;
      } else {
        HEAP32[((p)>>2)] = GLctx.getShaderParameter(GL.shaders[shader], pname);
      }
    }

  function _glGetUniformBlockIndex(program, uniformBlockName) {
      return GLctx['getUniformBlockIndex'](GL.programs[program], UTF8ToString(uniformBlockName));
    }

  /** @noinline */
  function webglGetLeftBracePos(name) {
      return name.slice(-1) == ']' && name.lastIndexOf('[');
    }
  function webglPrepareUniformLocationsBeforeFirstUse(program) {
      var uniformLocsById = program.uniformLocsById, // Maps GLuint -> WebGLUniformLocation
        uniformSizeAndIdsByName = program.uniformSizeAndIdsByName, // Maps name -> [uniform array length, GLuint]
        i, j;
  
      // On the first time invocation of glGetUniformLocation on this shader program:
      // initialize cache data structures and discover which uniforms are arrays.
      if (!uniformLocsById) {
        // maps GLint integer locations to WebGLUniformLocations
        program.uniformLocsById = uniformLocsById = {};
        // maps integer locations back to uniform name strings, so that we can lazily fetch uniform array locations
        program.uniformArrayNamesById = {};
  
        for (i = 0; i < GLctx.getProgramParameter(program, 0x8B86/*GL_ACTIVE_UNIFORMS*/); ++i) {
          var u = GLctx.getActiveUniform(program, i);
          var nm = u.name;
          var sz = u.size;
          var lb = webglGetLeftBracePos(nm);
          var arrayName = lb > 0 ? nm.slice(0, lb) : nm;
  
          // Assign a new location.
          var id = program.uniformIdCounter;
          program.uniformIdCounter += sz;
          // Eagerly get the location of the uniformArray[0] base element.
          // The remaining indices >0 will be left for lazy evaluation to
          // improve performance. Those may never be needed to fetch, if the
          // application fills arrays always in full starting from the first
          // element of the array.
          uniformSizeAndIdsByName[arrayName] = [sz, id];
  
          // Store placeholder integers in place that highlight that these
          // >0 index locations are array indices pending population.
          for(j = 0; j < sz; ++j) {
            uniformLocsById[id] = j;
            program.uniformArrayNamesById[id++] = arrayName;
          }
        }
      }
    }
  function _glGetUniformLocation(program, name) {
  
      name = UTF8ToString(name);
  
      if (program = GL.programs[program]) {
        webglPrepareUniformLocationsBeforeFirstUse(program);
        var uniformLocsById = program.uniformLocsById; // Maps GLuint -> WebGLUniformLocation
        var arrayIndex = 0;
        var uniformBaseName = name;
  
        // Invariant: when populating integer IDs for uniform locations, we must maintain the precondition that
        // arrays reside in contiguous addresses, i.e. for a 'vec4 colors[10];', colors[4] must be at location colors[0]+4.
        // However, user might call glGetUniformLocation(program, "colors") for an array, so we cannot discover based on the user
        // input arguments whether the uniform we are dealing with is an array. The only way to discover which uniforms are arrays
        // is to enumerate over all the active uniforms in the program.
        var leftBrace = webglGetLeftBracePos(name);
  
        // If user passed an array accessor "[index]", parse the array index off the accessor.
        if (leftBrace > 0) {
          arrayIndex = jstoi_q(name.slice(leftBrace + 1)) >>> 0; // "index]", coerce parseInt(']') with >>>0 to treat "foo[]" as "foo[0]" and foo[-1] as unsigned out-of-bounds.
          uniformBaseName = name.slice(0, leftBrace);
        }
  
        // Have we cached the location of this uniform before?
        var sizeAndId = program.uniformSizeAndIdsByName[uniformBaseName]; // A pair [array length, GLint of the uniform location]
  
        // If an uniform with this name exists, and if its index is within the array limits (if it's even an array),
        // query the WebGLlocation, or return an existing cached location.
        if (sizeAndId && arrayIndex < sizeAndId[0]) {
          arrayIndex += sizeAndId[1]; // Add the base location of the uniform to the array index offset.
          if ((uniformLocsById[arrayIndex] = uniformLocsById[arrayIndex] || GLctx.getUniformLocation(program, name))) {
            return arrayIndex;
          }
        }
      }
      else {
        // N.b. we are currently unable to distinguish between GL program IDs that never existed vs GL program IDs that have been deleted,
        // so report GL_INVALID_VALUE in both cases.
        GL.recordError(0x501 /* GL_INVALID_VALUE */);
      }
      return -1;
    }

  function _glLinkProgram(program) {
      program = GL.programs[program];
      GLctx.linkProgram(program);
      // Invalidate earlier computed uniform->ID mappings, those have now become stale
      program.uniformLocsById = 0; // Mark as null-like so that glGetUniformLocation() knows to populate this again.
      program.uniformSizeAndIdsByName = {};
  
    }

  function _glScissor(x0, x1, x2, x3) { GLctx['scissor'](x0, x1, x2, x3) }

  function _glShaderSource(shader, count, string, length) {
      var source = GL.getSource(shader, count, string, length);
  
      GLctx.shaderSource(GL.shaders[shader], source);
    }

  function _glStencilFunc(x0, x1, x2) { GLctx['stencilFunc'](x0, x1, x2) }

  function _glStencilMask(x0) { GLctx['stencilMask'](x0) }

  function _glStencilOp(x0, x1, x2) { GLctx['stencilOp'](x0, x1, x2) }

  function computeUnpackAlignedImageSize(width, height, sizePerPixel, alignment) {
      function roundedToNextMultipleOf(x, y) {
        return (x + y - 1) & -y;
      }
      var plainRowSize = width * sizePerPixel;
      var alignedRowSize = roundedToNextMultipleOf(plainRowSize, alignment);
      return height * alignedRowSize;
    }
  
  function __colorChannelsInGlTextureFormat(format) {
      // Micro-optimizations for size: map format to size by subtracting smallest enum value (0x1902) from all values first.
      // Also omit the most common size value (1) from the list, which is assumed by formats not on the list.
      var colorChannels = {
        // 0x1902 /* GL_DEPTH_COMPONENT */ - 0x1902: 1,
        // 0x1906 /* GL_ALPHA */ - 0x1902: 1,
        5: 3,
        6: 4,
        // 0x1909 /* GL_LUMINANCE */ - 0x1902: 1,
        8: 2,
        29502: 3,
        29504: 4,
        // 0x1903 /* GL_RED */ - 0x1902: 1,
        26917: 2,
        26918: 2,
        // 0x8D94 /* GL_RED_INTEGER */ - 0x1902: 1,
        29846: 3,
        29847: 4
      };
      return colorChannels[format - 0x1902]||1;
    }
  
  function heapObjectForWebGLType(type) {
      // Micro-optimization for size: Subtract lowest GL enum number (0x1400/* GL_BYTE */) from type to compare
      // smaller values for the heap, for shorter generated code size.
      // Also the type HEAPU16 is not tested for explicitly, but any unrecognized type will return out HEAPU16.
      // (since most types are HEAPU16)
      type -= 0x1400;
      if (type == 0) return HEAP8;
  
      if (type == 1) return HEAPU8;
  
      if (type == 2) return HEAP16;
  
      if (type == 4) return HEAP32;
  
      if (type == 6) return HEAPF32;
  
      if (type == 5
        || type == 28922
        || type == 28520
        || type == 30779
        || type == 30782
        )
        return HEAPU32;
  
      return HEAPU16;
    }
  
  function heapAccessShiftForWebGLHeap(heap) {
      return 31 - Math.clz32(heap.BYTES_PER_ELEMENT);
    }
  function emscriptenWebGLGetTexPixelData(type, format, width, height, pixels, internalFormat) {
      var heap = heapObjectForWebGLType(type);
      var shift = heapAccessShiftForWebGLHeap(heap);
      var byteSize = 1<<shift;
      var sizePerPixel = __colorChannelsInGlTextureFormat(format) * byteSize;
      var bytes = computeUnpackAlignedImageSize(width, height, sizePerPixel, GL.unpackAlignment);
      return heap.subarray(pixels >> shift, pixels + bytes >> shift);
    }
  function _glTexImage2D(target, level, internalFormat, width, height, border, format, type, pixels) {
      if (GL.currentContext.version >= 2) {
        // WebGL 2 provides new garbage-free entry points to call to WebGL. Use those always when possible.
        if (GLctx.currentPixelUnpackBufferBinding) {
          GLctx.texImage2D(target, level, internalFormat, width, height, border, format, type, pixels);
        } else if (pixels) {
          var heap = heapObjectForWebGLType(type);
          GLctx.texImage2D(target, level, internalFormat, width, height, border, format, type, heap, pixels >> heapAccessShiftForWebGLHeap(heap));
        } else {
          GLctx.texImage2D(target, level, internalFormat, width, height, border, format, type, null);
        }
        return;
      }
      GLctx.texImage2D(target, level, internalFormat, width, height, border, format, type, pixels ? emscriptenWebGLGetTexPixelData(type, format, width, height, pixels, internalFormat) : null);
    }

  function _glTexParameteri(x0, x1, x2) { GLctx['texParameteri'](x0, x1, x2) }

  function webglGetUniformLocation(location) {
      var p = GLctx.currentProgram;
  
      if (p) {
        var webglLoc = p.uniformLocsById[location];
        // p.uniformLocsById[location] stores either an integer, or a WebGLUniformLocation.
  
        // If an integer, we have not yet bound the location, so do it now. The integer value specifies the array index
        // we should bind to.
        if (typeof webglLoc === 'number') {
          p.uniformLocsById[location] = webglLoc = GLctx.getUniformLocation(p, p.uniformArrayNamesById[location] + (webglLoc > 0 ? '[' + webglLoc + ']' : ''));
        }
        // Else an already cached WebGLUniformLocation, return it.
        return webglLoc;
      } else {
        GL.recordError(0x502/*GL_INVALID_OPERATION*/);
      }
    }
  function _glUniform1f(location, v0) {
      GLctx.uniform1f(webglGetUniformLocation(location), v0);
    }

  function _glUniform1i(location, v0) {
      GLctx.uniform1i(webglGetUniformLocation(location), v0);
    }

  function _glUniform2f(location, v0, v1) {
      GLctx.uniform2f(webglGetUniformLocation(location), v0, v1);
    }

  function _glUniform3f(location, v0, v1, v2) {
      GLctx.uniform3f(webglGetUniformLocation(location), v0, v1, v2);
    }

  function _glUniform4f(location, v0, v1, v2, v3) {
      GLctx.uniform4f(webglGetUniformLocation(location), v0, v1, v2, v3);
    }

  function _glUniformBlockBinding(program, uniformBlockIndex, uniformBlockBinding) {
      program = GL.programs[program];
  
      GLctx['uniformBlockBinding'](program, uniformBlockIndex, uniformBlockBinding);
    }

  var miniTempWebGLFloatBuffers=[];
  function _glUniformMatrix4fv(location, count, transpose, value) {
  
      if (GL.currentContext.version >= 2) { // WebGL 2 provides new garbage-free entry points to call to WebGL. Use those always when possible.
        GLctx.uniformMatrix4fv(webglGetUniformLocation(location), !!transpose, HEAPF32, value>>2, count*16);
        return;
      }
  
      if (count <= 18) {
        // avoid allocation when uploading few enough uniforms
        var view = miniTempWebGLFloatBuffers[16*count-1];
        // hoist the heap out of the loop for size and for pthreads+growth.
        var heap = HEAPF32;
        value >>= 2;
        for (var i = 0; i < 16 * count; i += 16) {
          var dst = value + i;
          view[i] = heap[dst];
          view[i + 1] = heap[dst + 1];
          view[i + 2] = heap[dst + 2];
          view[i + 3] = heap[dst + 3];
          view[i + 4] = heap[dst + 4];
          view[i + 5] = heap[dst + 5];
          view[i + 6] = heap[dst + 6];
          view[i + 7] = heap[dst + 7];
          view[i + 8] = heap[dst + 8];
          view[i + 9] = heap[dst + 9];
          view[i + 10] = heap[dst + 10];
          view[i + 11] = heap[dst + 11];
          view[i + 12] = heap[dst + 12];
          view[i + 13] = heap[dst + 13];
          view[i + 14] = heap[dst + 14];
          view[i + 15] = heap[dst + 15];
        }
      } else
      {
        var view = HEAPF32.subarray((value)>>2, (value+count*64)>>2);
      }
      GLctx.uniformMatrix4fv(webglGetUniformLocation(location), !!transpose, view);
    }

  function _glUseProgram(program) {
      program = GL.programs[program];
      GLctx.useProgram(program);
      // Record the currently active program so that we can access the uniform
      // mapping table of that program.
      GLctx.currentProgram = program;
    }

  function _glVertexAttribDivisor(index, divisor) {
      GLctx['vertexAttribDivisor'](index, divisor);
    }

  function _glVertexAttribIPointer(index, size, type, stride, ptr) {
      GLctx['vertexAttribIPointer'](index, size, type, stride, ptr);
    }

  function _glVertexAttribPointer(index, size, type, normalized, stride, ptr) {
      GLctx.vertexAttribPointer(index, size, type, !!normalized, stride, ptr);
    }

  function _glViewport(x0, x1, x2, x3) { GLctx['viewport'](x0, x1, x2, x3) }

  function _setTempRet0(val) {
      setTempRet0(val);
    }


  function runAndAbortIfError(func) {
      try {
        return func();
      } catch (e) {
        abort(e);
      }
    }
  var Asyncify={State:{Normal:0,Unwinding:1,Rewinding:2,Disabled:3},state:0,StackSize:4096,currData:null,handleSleepReturnValue:0,exportCallStack:[],callStackNameToId:{},callStackIdToName:{},callStackId:0,afterUnwind:null,asyncFinalizers:[],sleepCallbacks:[],getCallStackId:function(funcName) {
        var id = Asyncify.callStackNameToId[funcName];
        if (id === undefined) {
          id = Asyncify.callStackId++;
          Asyncify.callStackNameToId[funcName] = id;
          Asyncify.callStackIdToName[id] = funcName;
        }
        return id;
      },instrumentWasmExports:function(exports) {
        var ret = {};
        for (var x in exports) {
          (function(x) {
            var original = exports[x];
            if (typeof original === 'function') {
              ret[x] = function() {
                Asyncify.exportCallStack.push(x);
                try {
                  return original.apply(null, arguments);
                } finally {
                  if (!ABORT) {
                    var y = Asyncify.exportCallStack.pop();
                    assert(y === x);
                    Asyncify.maybeStopUnwind();
                  }
                }
              };
            } else {
              ret[x] = original;
            }
          })(x);
        }
        return ret;
      },maybeStopUnwind:function() {
        if (Asyncify.currData &&
            Asyncify.state === Asyncify.State.Unwinding &&
            Asyncify.exportCallStack.length === 0) {
          // We just finished unwinding.
          
          Asyncify.state = Asyncify.State.Normal;
          // Keep the runtime alive so that a re-wind can be done later.
          runAndAbortIfError(Module['_asyncify_stop_unwind']);
          if (typeof Fibers !== 'undefined') {
            Fibers.trampoline();
          }
          if (Asyncify.afterUnwind) {
            Asyncify.afterUnwind();
            Asyncify.afterUnwind = null;
          }
        }
      },allocateData:function() {
        // An asyncify data structure has three fields:
        //  0  current stack pos
        //  4  max stack pos
        //  8  id of function at bottom of the call stack (callStackIdToName[id] == name of js function)
        //
        // The Asyncify ABI only interprets the first two fields, the rest is for the runtime.
        // We also embed a stack in the same memory region here, right next to the structure.
        // This struct is also defined as asyncify_data_t in emscripten/fiber.h
        var ptr = _malloc(12 + Asyncify.StackSize);
        Asyncify.setDataHeader(ptr, ptr + 12, Asyncify.StackSize);
        Asyncify.setDataRewindFunc(ptr);
        return ptr;
      },setDataHeader:function(ptr, stack, stackSize) {
        HEAP32[((ptr)>>2)] = stack;
        HEAP32[(((ptr)+(4))>>2)] = stack + stackSize;
      },setDataRewindFunc:function(ptr) {
        var bottomOfCallStack = Asyncify.exportCallStack[0];
        var rewindId = Asyncify.getCallStackId(bottomOfCallStack);
        HEAP32[(((ptr)+(8))>>2)] = rewindId;
      },getDataRewindFunc:function(ptr) {
        var id = HEAP32[(((ptr)+(8))>>2)];
        var name = Asyncify.callStackIdToName[id];
        var func = Module['asm'][name];
        return func;
      },doRewind:function(ptr) {
        var start = Asyncify.getDataRewindFunc(ptr);
        // Once we have rewound and the stack we no longer need to artificially keep
        // the runtime alive.
        
        return start();
      },handleSleep:function(startAsync) {
        if (ABORT) return;
        if (Asyncify.state === Asyncify.State.Normal) {
          // Prepare to sleep. Call startAsync, and see what happens:
          // if the code decided to call our callback synchronously,
          // then no async operation was in fact begun, and we don't
          // need to do anything.
          var reachedCallback = false;
          var reachedAfterCallback = false;
          startAsync(function(handleSleepReturnValue) {
            if (ABORT) return;
            Asyncify.handleSleepReturnValue = handleSleepReturnValue || 0;
            reachedCallback = true;
            if (!reachedAfterCallback) {
              // We are happening synchronously, so no need for async.
              return;
            }
            Asyncify.state = Asyncify.State.Rewinding;
            runAndAbortIfError(function() { Module['_asyncify_start_rewind'](Asyncify.currData) });
            if (typeof Browser !== 'undefined' && Browser.mainLoop.func) {
              Browser.mainLoop.resume();
            }
            var asyncWasmReturnValue = Asyncify.doRewind(Asyncify.currData);
            if (!Asyncify.currData) {
              // All asynchronous execution has finished.
              // `asyncWasmReturnValue` now contains the final
              // return value of the exported async WASM function.
              //
              // Note: `asyncWasmReturnValue` is distinct from
              // `Asyncify.handleSleepReturnValue`.
              // `Asyncify.handleSleepReturnValue` contains the return
              // value of the last C function to have executed
              // `Asyncify.handleSleep()`, where as `asyncWasmReturnValue`
              // contains the return value of the exported WASM function
              // that may have called C functions that
              // call `Asyncify.handleSleep()`.
              var asyncFinalizers = Asyncify.asyncFinalizers;
              Asyncify.asyncFinalizers = [];
              asyncFinalizers.forEach(function(func) {
                func(asyncWasmReturnValue);
              });
            }
          });
          reachedAfterCallback = true;
          if (!reachedCallback) {
            // A true async operation was begun; start a sleep.
            Asyncify.state = Asyncify.State.Unwinding;
            // TODO: reuse, don't alloc/free every sleep
            Asyncify.currData = Asyncify.allocateData();
            runAndAbortIfError(function() { Module['_asyncify_start_unwind'](Asyncify.currData) });
            if (typeof Browser !== 'undefined' && Browser.mainLoop.func) {
              Browser.mainLoop.pause();
            }
          }
        } else if (Asyncify.state === Asyncify.State.Rewinding) {
          // Stop a resume.
          Asyncify.state = Asyncify.State.Normal;
          runAndAbortIfError(Module['_asyncify_stop_rewind']);
          _free(Asyncify.currData);
          Asyncify.currData = null;
          // Call all sleep callbacks now that the sleep-resume is all done.
          Asyncify.sleepCallbacks.forEach(function(func) {
            callUserCallback(func);
          });
        } else {
          abort('invalid state: ' + Asyncify.state);
        }
        return Asyncify.handleSleepReturnValue;
      },handleAsync:function(startAsync) {
        return Asyncify.handleSleep(function(wakeUp) {
          // TODO: add error handling as a second param when handleSleep implements it.
          startAsync().then(wakeUp);
        });
      }};

  var FSNode = /** @constructor */ function(parent, name, mode, rdev) {
    if (!parent) {
      parent = this;  // root node sets parent to itself
    }
    this.parent = parent;
    this.mount = parent.mount;
    this.mounted = null;
    this.id = FS.nextInode++;
    this.name = name;
    this.mode = mode;
    this.node_ops = {};
    this.stream_ops = {};
    this.rdev = rdev;
  };
  var readMode = 292/*292*/ | 73/*73*/;
  var writeMode = 146/*146*/;
  Object.defineProperties(FSNode.prototype, {
   read: {
    get: /** @this{FSNode} */function() {
     return (this.mode & readMode) === readMode;
    },
    set: /** @this{FSNode} */function(val) {
     val ? this.mode |= readMode : this.mode &= ~readMode;
    }
   },
   write: {
    get: /** @this{FSNode} */function() {
     return (this.mode & writeMode) === writeMode;
    },
    set: /** @this{FSNode} */function(val) {
     val ? this.mode |= writeMode : this.mode &= ~writeMode;
    }
   },
   isFolder: {
    get: /** @this{FSNode} */function() {
     return FS.isDir(this.mode);
    }
   },
   isDevice: {
    get: /** @this{FSNode} */function() {
     return FS.isChrdev(this.mode);
    }
   }
  });
  FS.FSNode = FSNode;
  FS.staticInit();Module["FS_createPath"] = FS.createPath;Module["FS_createDataFile"] = FS.createDataFile;Module["FS_createPreloadedFile"] = FS.createPreloadedFile;Module["FS_createLazyFile"] = FS.createLazyFile;Module["FS_createDevice"] = FS.createDevice;Module["FS_unlink"] = FS.unlink;;
Module["requestFullscreen"] = function Module_requestFullscreen(lockPointer, resizeCanvas) { Browser.requestFullscreen(lockPointer, resizeCanvas) };
  Module["requestAnimationFrame"] = function Module_requestAnimationFrame(func) { Browser.requestAnimationFrame(func) };
  Module["setCanvasSize"] = function Module_setCanvasSize(width, height, noUpdates) { Browser.setCanvasSize(width, height, noUpdates) };
  Module["pauseMainLoop"] = function Module_pauseMainLoop() { Browser.mainLoop.pause() };
  Module["resumeMainLoop"] = function Module_resumeMainLoop() { Browser.mainLoop.resume() };
  Module["getUserMedia"] = function Module_getUserMedia() { Browser.getUserMedia() }
  Module["createContext"] = function Module_createContext(canvas, useWebGL, setInModule, webGLContextAttributes) { return Browser.createContext(canvas, useWebGL, setInModule, webGLContextAttributes) };
var GLctx;;
var miniTempWebGLFloatBuffersStorage = new Float32Array(288);
  for (/**@suppress{duplicate}*/var i = 0; i < 288; ++i) {
  miniTempWebGLFloatBuffers[i] = miniTempWebGLFloatBuffersStorage.subarray(0, i+1);
  }
  ;
var ASSERTIONS = false;



/** @type {function(string, boolean=, number=)} */
function intArrayFromString(stringy, dontAddNull, length) {
  var len = length > 0 ? length : lengthBytesUTF8(stringy)+1;
  var u8array = new Array(len);
  var numBytesWritten = stringToUTF8Array(stringy, u8array, 0, u8array.length);
  if (dontAddNull) u8array.length = numBytesWritten;
  return u8array;
}

function intArrayToString(array) {
  var ret = [];
  for (var i = 0; i < array.length; i++) {
    var chr = array[i];
    if (chr > 0xFF) {
      if (ASSERTIONS) {
        assert(false, 'Character code ' + chr + ' (' + String.fromCharCode(chr) + ')  at offset ' + i + ' not in 0x00-0xFF.');
      }
      chr &= 0xFF;
    }
    ret.push(String.fromCharCode(chr));
  }
  return ret.join('');
}


// Copied from https://github.com/strophe/strophejs/blob/e06d027/src/polyfills.js#L149

// This code was written by Tyler Akins and has been placed in the
// public domain.  It would be nice if you left this header intact.
// Base64 code from Tyler Akins -- http://rumkin.com

/**
 * Decodes a base64 string.
 * @param {string} input The string to decode.
 */
var decodeBase64 = typeof atob === 'function' ? atob : function (input) {
  var keyStr = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=';

  var output = '';
  var chr1, chr2, chr3;
  var enc1, enc2, enc3, enc4;
  var i = 0;
  // remove all characters that are not A-Z, a-z, 0-9, +, /, or =
  input = input.replace(/[^A-Za-z0-9\+\/\=]/g, '');
  do {
    enc1 = keyStr.indexOf(input.charAt(i++));
    enc2 = keyStr.indexOf(input.charAt(i++));
    enc3 = keyStr.indexOf(input.charAt(i++));
    enc4 = keyStr.indexOf(input.charAt(i++));

    chr1 = (enc1 << 2) | (enc2 >> 4);
    chr2 = ((enc2 & 15) << 4) | (enc3 >> 2);
    chr3 = ((enc3 & 3) << 6) | enc4;

    output = output + String.fromCharCode(chr1);

    if (enc3 !== 64) {
      output = output + String.fromCharCode(chr2);
    }
    if (enc4 !== 64) {
      output = output + String.fromCharCode(chr3);
    }
  } while (i < input.length);
  return output;
};

// Converts a string of base64 into a byte array.
// Throws error on invalid input.
function intArrayFromBase64(s) {
  if (typeof ENVIRONMENT_IS_NODE === 'boolean' && ENVIRONMENT_IS_NODE) {
    var buf = Buffer.from(s, 'base64');
    return new Uint8Array(buf['buffer'], buf['byteOffset'], buf['byteLength']);
  }

  try {
    var decoded = decodeBase64(s);
    var bytes = new Uint8Array(decoded.length);
    for (var i = 0 ; i < decoded.length ; ++i) {
      bytes[i] = decoded.charCodeAt(i);
    }
    return bytes;
  } catch (_) {
    throw new Error('Converting base64 string to bytes failed.');
  }
}

// If filename is a base64 data URI, parses and returns data (Buffer on node,
// Uint8Array otherwise). If filename is not a base64 data URI, returns undefined.
function tryParseAsDataURI(filename) {
  if (!isDataURI(filename)) {
    return;
  }

  return intArrayFromBase64(filename.slice(dataURIPrefix.length));
}


var asmLibraryArg = {
  "__assert_fail": ___assert_fail,
  "__sys_fcntl64": ___sys_fcntl64,
  "__sys_ioctl": ___sys_ioctl,
  "__sys_open": ___sys_open,
  "__sys_stat64": ___sys_stat64,
  "emscripten_asm_const_int": _emscripten_asm_const_int,
  "emscripten_enter_soft_fullscreen": _emscripten_enter_soft_fullscreen,
  "emscripten_exit_fullscreen": _emscripten_exit_fullscreen,
  "emscripten_get_element_css_size": _emscripten_get_element_css_size,
  "emscripten_get_pointerlock_status": _emscripten_get_pointerlock_status,
  "emscripten_memcpy_big": _emscripten_memcpy_big,
  "emscripten_performance_now": _emscripten_performance_now,
  "emscripten_resize_heap": _emscripten_resize_heap,
  "emscripten_set_canvas_element_size": _emscripten_set_canvas_element_size,
  "emscripten_set_click_callback_on_thread": _emscripten_set_click_callback_on_thread,
  "emscripten_set_fullscreenchange_callback_on_thread": _emscripten_set_fullscreenchange_callback_on_thread,
  "emscripten_set_keydown_callback_on_thread": _emscripten_set_keydown_callback_on_thread,
  "emscripten_set_keypress_callback_on_thread": _emscripten_set_keypress_callback_on_thread,
  "emscripten_set_keyup_callback_on_thread": _emscripten_set_keyup_callback_on_thread,
  "emscripten_set_main_loop": _emscripten_set_main_loop,
  "emscripten_set_mousedown_callback_on_thread": _emscripten_set_mousedown_callback_on_thread,
  "emscripten_set_mouseenter_callback_on_thread": _emscripten_set_mouseenter_callback_on_thread,
  "emscripten_set_mouseleave_callback_on_thread": _emscripten_set_mouseleave_callback_on_thread,
  "emscripten_set_mousemove_callback_on_thread": _emscripten_set_mousemove_callback_on_thread,
  "emscripten_set_mouseup_callback_on_thread": _emscripten_set_mouseup_callback_on_thread,
  "emscripten_set_pointerlockchange_callback_on_thread": _emscripten_set_pointerlockchange_callback_on_thread,
  "emscripten_set_resize_callback_on_thread": _emscripten_set_resize_callback_on_thread,
  "emscripten_set_wheel_callback_on_thread": _emscripten_set_wheel_callback_on_thread,
  "emscripten_sleep": _emscripten_sleep,
  "emscripten_webgl_create_context": _emscripten_webgl_create_context,
  "emscripten_webgl_init_context_attributes": _emscripten_webgl_init_context_attributes,
  "emscripten_webgl_make_context_current": _emscripten_webgl_make_context_current,
  "fd_close": _fd_close,
  "fd_read": _fd_read,
  "fd_seek": _fd_seek,
  "fd_write": _fd_write,
  "glActiveTexture": _glActiveTexture,
  "glAttachShader": _glAttachShader,
  "glBindBuffer": _glBindBuffer,
  "glBindBufferRange": _glBindBufferRange,
  "glBindFramebuffer": _glBindFramebuffer,
  "glBindRenderbuffer": _glBindRenderbuffer,
  "glBindTexture": _glBindTexture,
  "glBindVertexArray": _glBindVertexArray,
  "glBlendEquation": _glBlendEquation,
  "glBlendFunc": _glBlendFunc,
  "glBufferData": _glBufferData,
  "glBufferSubData": _glBufferSubData,
  "glClear": _glClear,
  "glClearColor": _glClearColor,
  "glCompileShader": _glCompileShader,
  "glCreateProgram": _glCreateProgram,
  "glCreateShader": _glCreateShader,
  "glCullFace": _glCullFace,
  "glDeleteProgram": _glDeleteProgram,
  "glDeleteShader": _glDeleteShader,
  "glDepthFunc": _glDepthFunc,
  "glDisable": _glDisable,
  "glDrawArrays": _glDrawArrays,
  "glDrawArraysInstanced": _glDrawArraysInstanced,
  "glDrawElements": _glDrawElements,
  "glDrawElementsInstanced": _glDrawElementsInstanced,
  "glEnable": _glEnable,
  "glEnableVertexAttribArray": _glEnableVertexAttribArray,
  "glFramebufferTexture2D": _glFramebufferTexture2D,
  "glFrontFace": _glFrontFace,
  "glGenBuffers": _glGenBuffers,
  "glGenFramebuffers": _glGenFramebuffers,
  "glGenTextures": _glGenTextures,
  "glGenVertexArrays": _glGenVertexArrays,
  "glGenerateMipmap": _glGenerateMipmap,
  "glGetIntegerv": _glGetIntegerv,
  "glGetProgramInfoLog": _glGetProgramInfoLog,
  "glGetProgramiv": _glGetProgramiv,
  "glGetShaderInfoLog": _glGetShaderInfoLog,
  "glGetShaderiv": _glGetShaderiv,
  "glGetUniformBlockIndex": _glGetUniformBlockIndex,
  "glGetUniformLocation": _glGetUniformLocation,
  "glLinkProgram": _glLinkProgram,
  "glScissor": _glScissor,
  "glShaderSource": _glShaderSource,
  "glStencilFunc": _glStencilFunc,
  "glStencilMask": _glStencilMask,
  "glStencilOp": _glStencilOp,
  "glTexImage2D": _glTexImage2D,
  "glTexParameteri": _glTexParameteri,
  "glUniform1f": _glUniform1f,
  "glUniform1i": _glUniform1i,
  "glUniform2f": _glUniform2f,
  "glUniform3f": _glUniform3f,
  "glUniform4f": _glUniform4f,
  "glUniformBlockBinding": _glUniformBlockBinding,
  "glUniformMatrix4fv": _glUniformMatrix4fv,
  "glUseProgram": _glUseProgram,
  "glVertexAttribDivisor": _glVertexAttribDivisor,
  "glVertexAttribIPointer": _glVertexAttribIPointer,
  "glVertexAttribPointer": _glVertexAttribPointer,
  "glViewport": _glViewport,
  "setTempRet0": _setTempRet0
};
var asm = createWasm();
/** @type {function(...*):?} */
var ___wasm_call_ctors = Module["___wasm_call_ctors"] = function() {
  return (___wasm_call_ctors = Module["___wasm_call_ctors"] = Module["asm"]["__wasm_call_ctors"]).apply(null, arguments);
};

/** @type {function(...*):?} */
var _malloc = Module["_malloc"] = function() {
  return (_malloc = Module["_malloc"] = Module["asm"]["malloc"]).apply(null, arguments);
};

/** @type {function(...*):?} */
var _free = Module["_free"] = function() {
  return (_free = Module["_free"] = Module["asm"]["free"]).apply(null, arguments);
};

/** @type {function(...*):?} */
var _main = Module["_main"] = function() {
  return (_main = Module["_main"] = Module["asm"]["main"]).apply(null, arguments);
};

/** @type {function(...*):?} */
var ___errno_location = Module["___errno_location"] = function() {
  return (___errno_location = Module["___errno_location"] = Module["asm"]["__errno_location"]).apply(null, arguments);
};

/** @type {function(...*):?} */
var _ma_device_process_pcm_frames_capture__webaudio = Module["_ma_device_process_pcm_frames_capture__webaudio"] = function() {
  return (_ma_device_process_pcm_frames_capture__webaudio = Module["_ma_device_process_pcm_frames_capture__webaudio"] = Module["asm"]["ma_device_process_pcm_frames_capture__webaudio"]).apply(null, arguments);
};

/** @type {function(...*):?} */
var _ma_device_process_pcm_frames_playback__webaudio = Module["_ma_device_process_pcm_frames_playback__webaudio"] = function() {
  return (_ma_device_process_pcm_frames_playback__webaudio = Module["_ma_device_process_pcm_frames_playback__webaudio"] = Module["asm"]["ma_device_process_pcm_frames_playback__webaudio"]).apply(null, arguments);
};

/** @type {function(...*):?} */
var _emscripten_main_thread_process_queued_calls = Module["_emscripten_main_thread_process_queued_calls"] = function() {
  return (_emscripten_main_thread_process_queued_calls = Module["_emscripten_main_thread_process_queued_calls"] = Module["asm"]["emscripten_main_thread_process_queued_calls"]).apply(null, arguments);
};

/** @type {function(...*):?} */
var _emscripten_stack_get_base = Module["_emscripten_stack_get_base"] = function() {
  return (_emscripten_stack_get_base = Module["_emscripten_stack_get_base"] = Module["asm"]["emscripten_stack_get_base"]).apply(null, arguments);
};

/** @type {function(...*):?} */
var _emscripten_stack_get_end = Module["_emscripten_stack_get_end"] = function() {
  return (_emscripten_stack_get_end = Module["_emscripten_stack_get_end"] = Module["asm"]["emscripten_stack_get_end"]).apply(null, arguments);
};

/** @type {function(...*):?} */
var stackSave = Module["stackSave"] = function() {
  return (stackSave = Module["stackSave"] = Module["asm"]["stackSave"]).apply(null, arguments);
};

/** @type {function(...*):?} */
var stackRestore = Module["stackRestore"] = function() {
  return (stackRestore = Module["stackRestore"] = Module["asm"]["stackRestore"]).apply(null, arguments);
};

/** @type {function(...*):?} */
var stackAlloc = Module["stackAlloc"] = function() {
  return (stackAlloc = Module["stackAlloc"] = Module["asm"]["stackAlloc"]).apply(null, arguments);
};

/** @type {function(...*):?} */
var _emscripten_stack_set_limits = Module["_emscripten_stack_set_limits"] = function() {
  return (_emscripten_stack_set_limits = Module["_emscripten_stack_set_limits"] = Module["asm"]["emscripten_stack_set_limits"]).apply(null, arguments);
};

/** @type {function(...*):?} */
var dynCall_iiiiii = Module["dynCall_iiiiii"] = function() {
  return (dynCall_iiiiii = Module["dynCall_iiiiii"] = Module["asm"]["dynCall_iiiiii"]).apply(null, arguments);
};

/** @type {function(...*):?} */
var dynCall_viiiiii = Module["dynCall_viiiiii"] = function() {
  return (dynCall_viiiiii = Module["dynCall_viiiiii"] = Module["asm"]["dynCall_viiiiii"]).apply(null, arguments);
};

/** @type {function(...*):?} */
var dynCall_viii = Module["dynCall_viii"] = function() {
  return (dynCall_viii = Module["dynCall_viii"] = Module["asm"]["dynCall_viii"]).apply(null, arguments);
};

/** @type {function(...*):?} */
var dynCall_iiii = Module["dynCall_iiii"] = function() {
  return (dynCall_iiii = Module["dynCall_iiii"] = Module["asm"]["dynCall_iiii"]).apply(null, arguments);
};

/** @type {function(...*):?} */
var dynCall_v = Module["dynCall_v"] = function() {
  return (dynCall_v = Module["dynCall_v"] = Module["asm"]["dynCall_v"]).apply(null, arguments);
};

/** @type {function(...*):?} */
var dynCall_viiii = Module["dynCall_viiii"] = function() {
  return (dynCall_viiii = Module["dynCall_viiii"] = Module["asm"]["dynCall_viiii"]).apply(null, arguments);
};

/** @type {function(...*):?} */
var dynCall_iii = Module["dynCall_iii"] = function() {
  return (dynCall_iii = Module["dynCall_iii"] = Module["asm"]["dynCall_iii"]).apply(null, arguments);
};

/** @type {function(...*):?} */
var dynCall_vii = Module["dynCall_vii"] = function() {
  return (dynCall_vii = Module["dynCall_vii"] = Module["asm"]["dynCall_vii"]).apply(null, arguments);
};

/** @type {function(...*):?} */
var dynCall_ii = Module["dynCall_ii"] = function() {
  return (dynCall_ii = Module["dynCall_ii"] = Module["asm"]["dynCall_ii"]).apply(null, arguments);
};

/** @type {function(...*):?} */
var dynCall_iiiii = Module["dynCall_iiiii"] = function() {
  return (dynCall_iiiii = Module["dynCall_iiiii"] = Module["asm"]["dynCall_iiiii"]).apply(null, arguments);
};

/** @type {function(...*):?} */
var dynCall_vi = Module["dynCall_vi"] = function() {
  return (dynCall_vi = Module["dynCall_vi"] = Module["asm"]["dynCall_vi"]).apply(null, arguments);
};

/** @type {function(...*):?} */
var dynCall_iidiiii = Module["dynCall_iidiiii"] = function() {
  return (dynCall_iidiiii = Module["dynCall_iidiiii"] = Module["asm"]["dynCall_iidiiii"]).apply(null, arguments);
};

/** @type {function(...*):?} */
var dynCall_jiji = Module["dynCall_jiji"] = function() {
  return (dynCall_jiji = Module["dynCall_jiji"] = Module["asm"]["dynCall_jiji"]).apply(null, arguments);
};

/** @type {function(...*):?} */
var _asyncify_start_unwind = Module["_asyncify_start_unwind"] = function() {
  return (_asyncify_start_unwind = Module["_asyncify_start_unwind"] = Module["asm"]["asyncify_start_unwind"]).apply(null, arguments);
};

/** @type {function(...*):?} */
var _asyncify_stop_unwind = Module["_asyncify_stop_unwind"] = function() {
  return (_asyncify_stop_unwind = Module["_asyncify_stop_unwind"] = Module["asm"]["asyncify_stop_unwind"]).apply(null, arguments);
};

/** @type {function(...*):?} */
var _asyncify_start_rewind = Module["_asyncify_start_rewind"] = function() {
  return (_asyncify_start_rewind = Module["_asyncify_start_rewind"] = Module["asm"]["asyncify_start_rewind"]).apply(null, arguments);
};

/** @type {function(...*):?} */
var _asyncify_stop_rewind = Module["_asyncify_stop_rewind"] = function() {
  return (_asyncify_stop_rewind = Module["_asyncify_stop_rewind"] = Module["asm"]["asyncify_stop_rewind"]).apply(null, arguments);
};





// === Auto-generated postamble setup entry stuff ===

Module["addRunDependency"] = addRunDependency;
Module["removeRunDependency"] = removeRunDependency;
Module["FS_createPath"] = FS.createPath;
Module["FS_createDataFile"] = FS.createDataFile;
Module["FS_createPreloadedFile"] = FS.createPreloadedFile;
Module["FS_createLazyFile"] = FS.createLazyFile;
Module["FS_createDevice"] = FS.createDevice;
Module["FS_unlink"] = FS.unlink;

var calledRun;

/**
 * @constructor
 * @this {ExitStatus}
 */
function ExitStatus(status) {
  this.name = "ExitStatus";
  this.message = "Program terminated with exit(" + status + ")";
  this.status = status;
}

var calledMain = false;

dependenciesFulfilled = function runCaller() {
  // If run has never been called, and we should call run (INVOKE_RUN is true, and Module.noInitialRun is not false)
  if (!calledRun) run();
  if (!calledRun) dependenciesFulfilled = runCaller; // try this again later, after new deps are fulfilled
};

function callMain(args) {

  var entryFunction = Module['_main'];

  args = args || [];

  var argc = args.length+1;
  var argv = stackAlloc((argc + 1) * 4);
  HEAP32[argv >> 2] = allocateUTF8OnStack(thisProgram);
  for (var i = 1; i < argc; i++) {
    HEAP32[(argv >> 2) + i] = allocateUTF8OnStack(args[i - 1]);
  }
  HEAP32[(argv >> 2) + argc] = 0;

  try {

    var ret = entryFunction(argc, argv);

    // In PROXY_TO_PTHREAD builds, we should never exit the runtime below, as
    // execution is asynchronously handed off to a pthread.
    // if we're not running an evented main loop, it's time to exit
    exit(ret, /* implicit = */ true);
  }
  catch (e) {
    // Certain exception types we do not treat as errors since they are used for
    // internal control flow.
    // 1. ExitStatus, which is thrown by exit()
    // 2. "unwind", which is thrown by emscripten_unwind_to_js_event_loop() and others
    //    that wish to return to JS event loop.
    if (e instanceof ExitStatus || e == 'unwind') {
      return;
    }
    // Anything else is an unexpected exception and we treat it as hard error.
    var toLog = e;
    if (e && typeof e === 'object' && e.stack) {
      toLog = [e, e.stack];
    }
    err('exception thrown: ' + toLog);
    quit_(1, e);
  } finally {
    calledMain = true;

  }
}

/** @type {function(Array=)} */
function run(args) {
  args = args || arguments_;

  if (runDependencies > 0) {
    return;
  }

  preRun();

  // a preRun added a dependency, run will be called later
  if (runDependencies > 0) {
    return;
  }

  function doRun() {
    // run may have just been called through dependencies being fulfilled just in this very frame,
    // or while the async setStatus time below was happening
    if (calledRun) return;
    calledRun = true;
    Module['calledRun'] = true;

    if (ABORT) return;

    initRuntime();

    preMain();

    if (Module['onRuntimeInitialized']) Module['onRuntimeInitialized']();

    if (shouldRunNow) callMain(args);

    postRun();
  }

  if (Module['setStatus']) {
    Module['setStatus']('Running...');
    setTimeout(function() {
      setTimeout(function() {
        Module['setStatus']('');
      }, 1);
      doRun();
    }, 1);
  } else
  {
    doRun();
  }
}
Module['run'] = run;

/** @param {boolean|number=} implicit */
function exit(status, implicit) {
  EXITSTATUS = status;

  if (keepRuntimeAlive()) {
  } else {

    exitRuntime();

    if (Module['onExit']) Module['onExit'](status);

    ABORT = true;
  }

  quit_(status, new ExitStatus(status));
}

if (Module['preInit']) {
  if (typeof Module['preInit'] == 'function') Module['preInit'] = [Module['preInit']];
  while (Module['preInit'].length > 0) {
    Module['preInit'].pop()();
  }
}

// shouldRunNow refers to calling main(), not run().
var shouldRunNow = true;

if (Module['noInitialRun']) shouldRunNow = false;

run();





